/**
 * Definition file generator for split codegen.
 * Generates separate files for each definition category (scalars, enums, inputs, objects, unions).
 */

export type DefinitionCategory = "enums" | "inputs" | "objects" | "unions";

export type DefinitionVar = {
  readonly name: string;
  readonly code: string;
};

/**
 * Split an array into chunks of the specified size.
 */
export const chunkArray = <T>(array: readonly T[], size: number): T[][] => {
  if (size <= 0) {
    return [Array.from(array)];
  }

  const result: T[][] = [];
  for (let i = 0; i < array.length; i += size) {
    result.push(array.slice(i, i + size));
  }

  return result;
};

/**
 * Determine if chunking is needed based on the number of definitions.
 */
export const needsChunking = (vars: readonly DefinitionVar[], chunkSize: number): boolean => {
  return vars.length > chunkSize;
};

type DefinitionFileOptions = {
  readonly category: DefinitionCategory;
  readonly schemaName: string;
  readonly vars: readonly DefinitionVar[];
  readonly needsDefineEnum: boolean;
};

/**
 * Generate a single definition file content.
 */
export const generateDefinitionFile = (options: DefinitionFileOptions): string => {
  const { category, vars, needsDefineEnum } = options;

  if (vars.length === 0) {
    return `/**
 * ${category} definitions (empty)
 * @generated by @soda-gql/codegen
 */
`;
  }

  const imports: string[] = [];
  if (needsDefineEnum && category === "enums") {
    imports.push('import { defineEnum } from "@soda-gql/core";');
  }

  const importsBlock = imports.length > 0 ? `${imports.join("\n")}\n\n` : "";
  const exportStatements = vars.map((v) => `export ${v.code}`).join("\n");

  return `/**
 * ${category} definitions
 * @generated by @soda-gql/codegen
 */
${importsBlock}${exportStatements}
`;
};

type ChunkFileOptions = {
  readonly category: DefinitionCategory;
  readonly schemaName: string;
  readonly vars: readonly DefinitionVar[];
  readonly chunkIndex: number;
  readonly needsDefineEnum: boolean;
};

/**
 * Generate a chunk file content.
 */
export const generateChunkFile = (options: ChunkFileOptions): string => {
  const { category, vars, chunkIndex, needsDefineEnum } = options;

  if (vars.length === 0) {
    return `/**
 * ${category} chunk ${chunkIndex} (empty)
 * @generated by @soda-gql/codegen
 */
`;
  }

  const imports: string[] = [];
  if (needsDefineEnum && category === "enums") {
    imports.push('import { defineEnum } from "@soda-gql/core";');
  }

  const importsBlock = imports.length > 0 ? `${imports.join("\n")}\n\n` : "";
  const exportStatements = vars.map((v) => `export ${v.code}`).join("\n");

  return `/**
 * ${category} chunk ${chunkIndex}
 * @generated by @soda-gql/codegen
 */
${importsBlock}${exportStatements}
`;
};

type ChunkIndexOptions = {
  readonly category: DefinitionCategory;
  readonly chunkCount: number;
  readonly varNames: readonly string[];
};

/**
 * Generate the index file that re-exports all chunks.
 */
export const generateChunkIndex = (options: ChunkIndexOptions): string => {
  const { category, chunkCount } = options;

  const reExports = Array.from({ length: chunkCount }, (_, i) => `export * from "./chunk-${i}";`).join("\n");

  return `/**
 * ${category} index (re-exports all chunks)
 * @generated by @soda-gql/codegen
 */
${reExports}
`;
};

export type ChunkedDefinitionFiles = {
  readonly indexContent: string;
  readonly chunks: ReadonlyArray<{
    readonly chunkIndex: number;
    readonly content: string;
    readonly varNames: readonly string[];
  }>;
};

/**
 * Generate chunked definition files.
 */
export const generateChunkedDefinitionFiles = (
  category: DefinitionCategory,
  schemaName: string,
  vars: readonly DefinitionVar[],
  chunkSize: number,
): ChunkedDefinitionFiles => {
  const chunks = chunkArray(vars, chunkSize);
  const needsDefineEnum = category === "enums";

  const chunkContents = chunks.map((chunkVars, chunkIndex) => ({
    chunkIndex,
    content: generateChunkFile({
      category,
      schemaName,
      vars: chunkVars,
      chunkIndex,
      needsDefineEnum,
    }),
    varNames: chunkVars.map((v) => v.name),
  }));

  const allVarNames = vars.map((v) => v.name);
  const indexContent = generateChunkIndex({
    category,
    chunkCount: chunks.length,
    varNames: allVarNames,
  });

  return {
    indexContent,
    chunks: chunkContents,
  };
};

type DefsDirectoryStructure = {
  readonly files: ReadonlyArray<{
    readonly relativePath: string;
    readonly content: string;
  }>;
  readonly importPaths: Record<DefinitionCategory, string>;
};

export type CategoryVars = {
  readonly enums: readonly DefinitionVar[];
  readonly inputs: readonly DefinitionVar[];
  readonly objects: readonly DefinitionVar[];
  readonly unions: readonly DefinitionVar[];
};

/**
 * Generate the complete _defs directory structure.
 */
export const generateDefsStructure = (
  schemaName: string,
  categoryVars: CategoryVars,
  chunkSize: number,
): DefsDirectoryStructure => {
  const files: Array<{ relativePath: string; content: string }> = [];
  const importPaths: Record<DefinitionCategory, string> = {
    enums: "./_defs/enums",
    inputs: "./_defs/inputs",
    objects: "./_defs/objects",
    unions: "./_defs/unions",
  };

  const categories: DefinitionCategory[] = ["enums", "inputs", "objects", "unions"];

  for (const category of categories) {
    const vars = categoryVars[category];
    const needsDefineEnum = category === "enums";

    if (needsChunking(vars, chunkSize)) {
      // Generate chunked files
      const chunked = generateChunkedDefinitionFiles(category, schemaName, vars, chunkSize);

      // Update import path to point to the directory (which has index.ts)
      importPaths[category] = `./_defs/${category}`;

      // Add index file
      files.push({
        relativePath: `_defs/${category}/index.ts`,
        content: chunked.indexContent,
      });

      // Add chunk files
      for (const chunk of chunked.chunks) {
        files.push({
          relativePath: `_defs/${category}/chunk-${chunk.chunkIndex}.ts`,
          content: chunk.content,
        });
      }
    } else {
      // Generate single file
      const content = generateDefinitionFile({
        category,
        schemaName,
        vars,
        needsDefineEnum,
      });

      files.push({
        relativePath: `_defs/${category}.ts`,
        content,
      });
    }
  }

  return { files, importPaths };
};

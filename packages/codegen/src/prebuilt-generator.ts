/**
 * Prebuilt module generator for bundler-compatible type resolution.
 *
 * Generates a prebuilt version of the gql composer that uses
 * PrebuiltTypes for type lookup instead of complex inference.
 *
 * @module
 */

import type { DocumentNode } from "graphql";

type PrebuiltGeneratorOptions = {
  /**
   * Relative import path to the main gql module.
   * Example: "../index" (from prebuilt/index.ts to index.ts)
   */
  readonly mainModulePath: string;
  /**
   * Per-schema injection config (adapter import paths).
   */
  readonly injection?: Map<
    string,
    {
      readonly adapterImportPath?: string;
    }
  >;
};

type PrebuiltGeneratedModule = {
  /** The generated code for prebuilt/index.ts */
  readonly indexCode: string;
  /** The generated code for prebuilt/types.ts (placeholder) */
  readonly typesCode: string;
};

/**
 * Generate the prebuilt module code.
 *
 * This generates:
 * - prebuilt/index.ts: Uses createPrebuiltGqlElementComposer with types from PrebuiltTypes
 * - prebuilt/types.ts: Placeholder types that builder will populate
 */
export const generatePrebuiltModule = (
  schemas: Map<string, DocumentNode>,
  options: PrebuiltGeneratorOptions,
): PrebuiltGeneratedModule => {
  const schemaNames = Array.from(schemas.keys());

  // Generate type imports from main module
  const typeImports: string[] = [];
  // Generate runtime imports from main module (the __ prefixed exports)
  const runtimeImports: string[] = [];

  for (const name of schemaNames) {
    // Type imports
    typeImports.push(`Schema_${name}`, `FragmentBuilders_${name}`);

    // Runtime imports
    runtimeImports.push(`__schema_${name}`, `__inputTypeMethods_${name}`, `__directiveMethods_${name}`);

    // Check if adapter is used for this schema
    const hasAdapter = options.injection?.get(name)?.adapterImportPath !== undefined;
    if (hasAdapter) {
      typeImports.push(`Adapter_${name}`);
      runtimeImports.push(`__adapter_${name}`);
    }
  }

  // Generate gql entries with createPrebuiltGqlElementComposer
  const gqlEntries: string[] = [];
  const contextTypes: string[] = [];

  for (const name of schemaNames) {
    const document = schemas.get(name);
    if (!document) continue;

    const hasAdapter = options.injection?.get(name)?.adapterImportPath !== undefined;

    // Generate context type for this schema
    contextTypes.push(`
/** Context type for ${name} schema */
type Context_${name} = {
  fragment: FragmentBuilders_${name};
  query: { operation: ReturnType<typeof import("@soda-gql/core").createGqlElementComposer<Schema_${name}, FragmentBuilders_${name}, typeof __directiveMethods_${name}>> extends (composeElement: (ctx: infer C) => unknown) => unknown ? C["query"]["operation"] : never };
  mutation: { operation: ReturnType<typeof import("@soda-gql/core").createGqlElementComposer<Schema_${name}, FragmentBuilders_${name}, typeof __directiveMethods_${name}>> extends (composeElement: (ctx: infer C) => unknown) => unknown ? C["mutation"]["operation"] : never };
  subscription: { operation: ReturnType<typeof import("@soda-gql/core").createGqlElementComposer<Schema_${name}, FragmentBuilders_${name}, typeof __directiveMethods_${name}>> extends (composeElement: (ctx: infer C) => unknown) => unknown ? C["subscription"]["operation"] : never };
  $var: import("@soda-gql/core").InputTypeMethods<Schema_${name}>;
  $dir: typeof __directiveMethods_${name};
  $colocate: ReturnType<typeof import("@soda-gql/core").createColocateHelper>;
};`);

    // Generate gql entry with PrebuiltGqlElementComposer
    if (hasAdapter) {
      gqlEntries.push(
        `  ${name}: createPrebuiltGqlElementComposer<Schema_${name}, PrebuiltTypes_${name}, FragmentBuilders_${name}, typeof __directiveMethods_${name}, Context_${name}, Adapter_${name}>(__schema_${name}, { adapter: __adapter_${name}, inputTypeMethods: __inputTypeMethods_${name}, directiveMethods: __directiveMethods_${name} })`,
      );
    } else {
      gqlEntries.push(
        `  ${name}: createPrebuiltGqlElementComposer<Schema_${name}, PrebuiltTypes_${name}, FragmentBuilders_${name}, typeof __directiveMethods_${name}, Context_${name}>(__schema_${name}, { inputTypeMethods: __inputTypeMethods_${name}, directiveMethods: __directiveMethods_${name} })`,
      );
    }
  }

  // Generate the prebuilt/index.ts code
  const indexCode = `\
/**
 * Prebuilt GQL module for bundler-compatible type resolution.
 *
 * This module uses createPrebuiltGqlElementComposer which looks up types
 * from PrebuiltTypes instead of using complex type inference.
 *
 * @module
 * @generated by @soda-gql/codegen
 */

import { createPrebuiltGqlElementComposer, type InputTypeMethods, createColocateHelper } from "@soda-gql/core";
import {
  ${runtimeImports.join(",\n  ")},
  type ${typeImports.join(",\n  type ")},
} from "${options.mainModulePath}";
import type { ${schemaNames.map((name) => `PrebuiltTypes_${name}`).join(", ")} } from "./types";
${contextTypes.join("\n")}

export const gql = {
${gqlEntries.join(",\n")}
};

// Re-export types from main module
export type { ${typeImports.join(", ")} };
`;

  // Generate the prebuilt/types.ts placeholder
  const typesCode = `\
/**
 * Prebuilt type registry.
 *
 * This file contains placeholder types that will be populated by the builder
 * when running \`soda-gql build\` command.
 *
 * @module
 * @generated by @soda-gql/codegen
 */

import type { EmptyPrebuiltTypeRegistry } from "@soda-gql/core";

${schemaNames.map((name) => `// Placeholder for ${name} schema - populated by builder\nexport type PrebuiltTypes_${name} = EmptyPrebuiltTypeRegistry;`).join("\n\n")}
`;

  return {
    indexCode,
    typesCode,
  };
};

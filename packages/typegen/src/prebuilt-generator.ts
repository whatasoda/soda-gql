/**
 * Prebuilt module generator for bundler-compatible type resolution.
 *
 * Generates index.prebuilt.ts in the output directory (flat layout).
 * This module creates prebuilt gql composers that use PrebuiltTypes
 * for type lookup instead of complex inference.
 *
 * Generated file structure (in outdir):
 * - index.prebuilt.ts: Prebuilt gql composers
 * - types.prebuilt.ts: Type registry (generated by emitter.ts)
 *
 * Type resolution strategy (v2):
 * - Types are resolved at the fragment/operation builder level using TKey/TName
 * - No ResolvePrebuiltElement needed at composer level
 * - This enables proper typing for fields, metadata, and other builder arguments
 *
 * @module
 */

import type { DocumentNode } from "graphql";

export type PrebuiltGeneratorOptions = {
  /**
   * Relative import path to the internal module.
   * Example: "./_internal" (from index.prebuilt.ts to _internal.ts)
   */
  readonly internalModulePath: string;
  /**
   * Relative import path to the injects module.
   * Example: "./_internal-injects" (from index.prebuilt.ts to _internal-injects.ts)
   */
  readonly injectsModulePath: string;
  /**
   * Per-schema injection config.
   * Maps schema name to whether it has an adapter.
   */
  readonly injection?: Map<
    string,
    {
      readonly hasAdapter?: boolean;
    }
  >;
};

export type PrebuiltGeneratedModule = {
  /** The generated code for index.prebuilt.ts */
  readonly indexCode: string;
};

/**
 * Generate the prebuilt index module code.
 *
 * Generates index.prebuilt.ts with builder-level type resolution.
 * Types are resolved at the fragment/operation builder level using TKey/TName,
 * eliminating the need for ResolvePrebuiltElement at the composer level.
 */
export const generatePrebuiltModule = (
  schemas: Map<string, DocumentNode>,
  options: PrebuiltGeneratorOptions,
): PrebuiltGeneratedModule => {
  const schemaNames = Array.from(schemas.keys());
  const injection = options.injection ?? new Map();

  // Generate adapter imports from _internal-injects.ts
  const adapterImports: string[] = [];
  for (const name of schemaNames) {
    const config = injection.get(name);
    if (config?.hasAdapter) {
      adapterImports.push(`adapter_${name}`);
    }
  }

  // Generate internal imports (runtime values and types needed for composer creation)
  const internalImports = schemaNames.flatMap((name) => [
    `__schema_${name}`,
    `__inputTypeMethods_${name}`,
    `__directiveMethods_${name}`,
  ]);

  // Generate type imports for schema types
  const internalTypeImports = schemaNames.map((name) => `Schema_${name}`);

  // Generate resolver types and context types for each schema
  const contextTypes = schemaNames
    .map(
      (name) => `
/**
 * Resolve fragment types at builder level using TKey.
 * If TKey is a known key in PrebuiltTypes, return resolved types.
 * Otherwise, return PrebuiltEntryNotFound.
 */
type ResolveFragmentAtBuilder_${name}<
  TTypeName extends string,
  TKey extends string | undefined
> = TKey extends keyof PrebuiltTypes_${name}["fragments"]
  ? Fragment<
      TTypeName,
      PrebuiltTypes_${name}["fragments"][TKey]["input"] extends infer TInput
        ? TInput extends void ? void : Partial<TInput & object>
        : void,
      Partial<AnyFields>,
      PrebuiltTypes_${name}["fragments"][TKey]["output"] & object,
      TKey
    >
  : TKey extends undefined
    ? Fragment<TTypeName, PrebuiltEntryNotFound<"(undefined)", "fragment">, Partial<AnyFields>, PrebuiltEntryNotFound<"(undefined)", "fragment">, TKey>
    : Fragment<TTypeName, PrebuiltEntryNotFound<TKey & string, "fragment">, Partial<AnyFields>, PrebuiltEntryNotFound<TKey & string, "fragment">, TKey>;

/**
 * Resolve operation types at builder level using TName.
 */
type ResolveOperationAtBuilder_${name}<
  TOperationType extends OperationType,
  TName extends string
> = TName extends keyof PrebuiltTypes_${name}["operations"]
  ? Operation<
      TOperationType,
      TName,
      string[],
      PrebuiltTypes_${name}["operations"][TName]["input"] & AnyConstAssignableInput,
      Partial<AnyFields>,
      PrebuiltTypes_${name}["operations"][TName]["output"] & object
    >
  : Operation<
      TOperationType,
      TName,
      string[],
      PrebuiltEntryNotFound<TName, "operation">,
      Partial<AnyFields>,
      PrebuiltEntryNotFound<TName, "operation">
    >;

/**
 * Fragment builder that resolves types at builder level using TKey.
 */
type PrebuiltFragmentBuilder_${name} = <TTypeName extends string, TKey extends string | undefined = undefined>(
  options: { key?: TKey; [key: string]: unknown }
) => ResolveFragmentAtBuilder_${name}<TTypeName, TKey>;

/**
 * Operation builder that resolves types at builder level using TName.
 */
type PrebuiltOperationBuilder_${name}<TOperationType extends OperationType> = <TName extends string>(
  options: { name: TName; [key: string]: unknown }
) => ResolveOperationAtBuilder_${name}<TOperationType, TName>;

/**
 * Prebuilt context with builder-level type resolution for schema "${name}".
 */
type PrebuiltContext_${name} = {
  readonly fragment: { [K: string]: PrebuiltFragmentBuilder_${name} };
  readonly query: { readonly operation: PrebuiltOperationBuilder_${name}<"query"> };
  readonly mutation: { readonly operation: PrebuiltOperationBuilder_${name}<"mutation"> };
  readonly subscription: { readonly operation: PrebuiltOperationBuilder_${name}<"subscription"> };
  readonly $var: unknown;
  readonly $dir: StandardDirectives;
  readonly $colocate: unknown;
};`,
    )
    .join("\n");

  // Generate gql entries using createGqlElementComposer with type cast
  const gqlEntries = schemaNames.map((name) => {
    const config = injection.get(name);
    const adapterArg = config?.hasAdapter ? `adapter: adapter_${name},` : "";

    return `  ${name}: createGqlElementComposer(
    __schema_${name} as AnyGraphqlSchema,
    {
      inputTypeMethods: __inputTypeMethods_${name},
      directiveMethods: __directiveMethods_${name},
      ${adapterArg}
    }
  ) as unknown as GqlComposer_${name}`;
  });

  // Build injects import line
  const injectsImportSpecifiers = adapterImports.length > 0 ? adapterImports.join(", ") : "";
  const injectsImportLine = injectsImportSpecifiers
    ? `import { ${injectsImportSpecifiers} } from "${options.injectsModulePath}";`
    : "";

  // Generate index.prebuilt.ts code with builder-level type resolution
  const indexCode = `\
/**
 * Prebuilt GQL module with builder-level type resolution.
 *
 * Types are resolved at the fragment/operation builder level using TKey/TName,
 * not at the composer level. This enables proper typing for builder arguments
 * and eliminates the need for ResolvePrebuiltElement.
 *
 * @module
 * @generated by @soda-gql/typegen
 */

import {
  createGqlElementComposer,
  type AnyConstAssignableInput,
  type AnyFields,
  type AnyGraphqlSchema,
  type Fragment,
  type Operation,
  type OperationType,
  type PrebuiltEntryNotFound,
  type StandardDirectives,
} from "@soda-gql/core";
${injectsImportLine}
import { ${internalImports.join(", ")}, type ${internalTypeImports.join(", type ")} } from "${options.internalModulePath}";
import type { ${schemaNames.map((name) => `PrebuiltTypes_${name}`).join(", ")} } from "./types.prebuilt";

${contextTypes}

// Export context types for explicit annotation
${schemaNames.map((name) => `export type { PrebuiltContext_${name} };`).join("\n")}

// Composer type - TResult already has resolved types from builders, no ResolvePrebuiltElement needed
${schemaNames.map((name) => `type GqlComposer_${name} = {
  <TResult>(composeElement: (context: PrebuiltContext_${name}) => TResult): TResult;
  readonly $schema: AnyGraphqlSchema;
};`).join("\n")}

/**
 * Prebuilt GQL composers with builder-level type resolution.
 *
 * These composers have the same runtime behavior as the base composers,
 * but their return types are resolved from the prebuilt type registry
 * at the builder level instead of using ResolvePrebuiltElement.
 */
export const gql: { ${schemaNames.map((name) => `${name}: GqlComposer_${name}`).join("; ")} } = {
${gqlEntries.join(",\n")}
};
`;

  return {
    indexCode,
  };
};

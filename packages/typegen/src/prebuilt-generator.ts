/**
 * Prebuilt module generator for bundler-compatible type resolution.
 *
 * Generates index.prebuilt.ts in the output directory (flat layout).
 * This module creates prebuilt gql composers that use PrebuiltTypes
 * for type lookup instead of complex inference.
 *
 * Generated file structure (in outdir):
 * - index.prebuilt.ts: Prebuilt gql composers
 * - types.prebuilt.ts: Type registry (generated by emitter.ts)
 *
 * Import strategy for lightweight type serialization:
 * - Adapters from _internal-injects.ts (scalar, adapter)
 * - Runtime values from _internal.ts (__schema_*, etc.)
 * - Generates minimal Context types that preserve TKey and TOperationName
 *
 * @module
 */

import type { DocumentNode } from "graphql";

export type PrebuiltGeneratorOptions = {
  /**
   * Relative import path to the internal module.
   * Example: "./_internal" (from index.prebuilt.ts to _internal.ts)
   */
  readonly internalModulePath: string;
  /**
   * Relative import path to the injects module.
   * Example: "./_internal-injects" (from index.prebuilt.ts to _internal-injects.ts)
   */
  readonly injectsModulePath: string;
  /**
   * Per-schema injection config.
   * Maps schema name to whether it has an adapter.
   */
  readonly injection?: Map<
    string,
    {
      readonly hasAdapter?: boolean;
    }
  >;
};

export type PrebuiltGeneratedModule = {
  /** The generated code for index.prebuilt.ts */
  readonly indexCode: string;
};

/**
 * Generate the prebuilt index module code.
 *
 * Generates index.prebuilt.ts with prebuilt gql composers using
 * createGqlElementComposer with explicit type casts. The generated module uses:
 * - Adapters from _internal-injects.ts
 * - Runtime values from _internal.ts
 * - Explicit PrebuiltContext types that preserve TKey and TOperationName
 */
export const generatePrebuiltModule = (
  schemas: Map<string, DocumentNode>,
  options: PrebuiltGeneratorOptions,
): PrebuiltGeneratedModule => {
  const schemaNames = Array.from(schemas.keys());
  const injection = options.injection ?? new Map();

  // Generate adapter imports from _internal-injects.ts
  const adapterImports: string[] = [];
  for (const name of schemaNames) {
    const config = injection.get(name);
    if (config?.hasAdapter) {
      adapterImports.push(`adapter_${name}`);
    }
  }

  // Generate internal imports (runtime values and types needed for composer creation)
  const internalImports = schemaNames.flatMap((name) => [
    `__schema_${name}`,
    `__inputTypeMethods_${name}`,
    `__directiveMethods_${name}`,
  ]);

  // Generate type imports for schema types
  const internalTypeImports = schemaNames.map((name) => `Schema_${name}`);

  // Generate context types that preserve TKey and TOperationName
  // Uses 'any' for constrained type parameters since actual types come from ResolvePrebuiltElement
  // Uses a generic fragment builder instead of mapped type for better type resolution
  const contextTypes = schemaNames
    .map(
      (name) => `
// Minimal context with explicit types that preserve TKey and TOperationName
// biome-ignore lint/suspicious/noExplicitAny: Required for type constraint compatibility
type PrebuiltContext_${name} = {
  readonly fragment: Record<string, <TTypeName extends string, TKey extends string | undefined = undefined>(
    options: { key?: TKey; [key: string]: unknown }
  ) => Fragment<TTypeName, any, Partial<AnyFields>, object, TKey>>;
  readonly query: { readonly operation: <TName extends string>(
    options: { name: TName; [key: string]: unknown }
  ) => Operation<OperationType, TName, string[], any, Partial<AnyFields>, object> };
  readonly mutation: { readonly operation: <TName extends string>(
    options: { name: TName; [key: string]: unknown }
  ) => Operation<OperationType, TName, string[], any, Partial<AnyFields>, object> };
  readonly subscription: { readonly operation: <TName extends string>(
    options: { name: TName; [key: string]: unknown }
  ) => Operation<OperationType, TName, string[], any, Partial<AnyFields>, object> };
  readonly $var: unknown;
  readonly $dir: StandardDirectives;
  readonly $colocate: unknown;
};`,
    )
    .join("\n");

  // Generate gql entries using createGqlElementComposer with type cast
  // This avoids type resolution issues with createPrebuiltGqlElementComposer
  const gqlEntries = schemaNames.map((name) => {
    const config = injection.get(name);
    const adapterArg = config?.hasAdapter ? `adapter: adapter_${name},` : "";

    return `  ${name}: createGqlElementComposer(
    __schema_${name} as AnyGraphqlSchema,
    {
      inputTypeMethods: __inputTypeMethods_${name},
      directiveMethods: __directiveMethods_${name},
      ${adapterArg}
    }
  ) as unknown as GqlComposer_${name}`;
  });

  // Build injects import line
  const injectsImportSpecifiers = adapterImports.length > 0 ? adapterImports.join(", ") : "";
  const injectsImportLine = injectsImportSpecifiers
    ? `import { ${injectsImportSpecifiers} } from "${options.injectsModulePath}";`
    : "";

  // Generate index.prebuilt.ts code with context types that preserve TKey/TOperationName
  const indexCode = `\
/**
 * Prebuilt GQL module for bundler-compatible type resolution.
 *
 * This module creates prebuilt composers using createPrebuiltGqlElementComposer
 * that look up types from PrebuiltTypes instead of complex inference.
 *
 * Uses lightweight imports and generates minimal Context types that preserve
 * TKey (for fragments) and TOperationName (for operations) type parameters.
 *
 * @module
 * @generated by @soda-gql/typegen
 */

import {
  createGqlElementComposer,
  type AnyFields,
  type AnyGraphqlSchema,
  type Fragment,
  type Operation,
  type OperationType,
  type ResolvePrebuiltElement,
  type StandardDirectives,
} from "@soda-gql/core";
${injectsImportLine}
import { ${internalImports.join(", ")}, type ${internalTypeImports.join(", type ")} } from "${options.internalModulePath}";
import type { ${schemaNames.map((name) => `PrebuiltTypes_${name}`).join(", ")} } from "./types.prebuilt";

${contextTypes}

// Export context types for explicit annotation
${schemaNames.map((name) => `export type { PrebuiltContext_${name} };`).join("\n")}

// Define standalone composer type that explicitly preserves context type
// This avoids potential issues with intersection types in PrebuiltGqlElementComposerWithSchema
${schemaNames.map((name) => `type GqlComposer_${name} = {
  <TResult>(composeElement: (context: PrebuiltContext_${name}) => TResult): ResolvePrebuiltElement<TResult, PrebuiltTypes_${name}>;
  readonly $schema: AnyGraphqlSchema;
};`).join("\n")}

/**
 * Prebuilt GQL composers with strict type resolution from PrebuiltTypeRegistry.
 *
 * These composers have the same runtime behavior as the base composers,
 * but their return types are resolved from the prebuilt type registry
 * instead of using complex type inference.
 */
export const gql: { ${schemaNames.map((name) => `${name}: GqlComposer_${name}`).join("; ")} } = {
${gqlEntries.join(",\n")}
};
`;

  return {
    indexCode,
  };
};

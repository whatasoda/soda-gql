import { beforeEach, describe, expect, it } from "bun:test";
import type { AnyComposedOperation } from "@soda-gql/core";
import { __resetRuntimeRegistry } from "@soda-gql/core/runtime";
import type { FormattedExecutionResult } from "graphql";
import { parse } from "graphql";
import { createExecutor, executeOperation } from "./executor";
import type {
  ExecutorConfig,
  GraffleHeadersInit,
  GraphQLClient,
} from "./types";

// Mock GraphQL client
const createMockClient = (
  mockResponse: FormattedExecutionResult | Error
): GraphQLClient => ({
  async request<
    TData extends object = Record<string, unknown>,
    TVariables = Record<string, unknown>,
    TExtensions extends object = Record<string, unknown>
  >(
    _doc: string,
    _vars?: TVariables,
    _headers?: GraffleHeadersInit
  ): Promise<FormattedExecutionResult<TData, TExtensions>> {
    if (mockResponse instanceof Error) {
      throw mockResponse;
    }
    return mockResponse as FormattedExecutionResult<TData, TExtensions>;
  },
});

// Sample operation for testing
const createTestOperation = (): AnyComposedOperation => {
  const document = parse(`
    query GetUser($id: ID!) {
      user(id: $id) {
        id
        name
      }
    }
  `);

  // Create a mock operation that mimics the structure generated by soda-gql
  return {
    operationType: "query",
    operationName: "GetUser",
    variableNames: ["id"],
    document,
    parse: (result: any) => {
      // Simple mock parser that returns the result as-is
      if (result.type === "graphql") {
        return { user: result.body.data };
      }
      if (result.type === "non-graphql-error") {
        return { error: result.error };
      }
      return { empty: true };
    },
    projectionPathGraph: {
      matches: [],
      children: {},
    },
  } as unknown as AnyComposedOperation;
};

describe("graffle-client executor", () => {
  beforeEach(() => {
    __resetRuntimeRegistry();
  });

  describe("executeOperation", () => {
    it("should execute a successful GraphQL query", async () => {
      const mockResponse: FormattedExecutionResult = {
        data: {
          user: {
            id: "1",
            name: "Alice",
          },
        },
      };

      const client = createMockClient(mockResponse);
      const config: ExecutorConfig = { client };
      const operation = createTestOperation();

      const result = await executeOperation(
        config,
        operation,
        { id: "1" },
        undefined
      );

      expect(result.isOk()).toBe(true);
      if (result.isOk()) {
        expect(result.value).toEqual({
          user: {
            user: {
              id: "1",
              name: "Alice",
            },
          },
        });
      }
    });

    it("should handle GraphQL errors", async () => {
      const mockResponse: FormattedExecutionResult = {
        data: null,
        errors: [
          {
            message: "User not found",
            path: ["user"],
          },
        ],
      };

      const client = createMockClient(mockResponse);
      const config: ExecutorConfig = { client };
      const operation = createTestOperation();

      const result = await executeOperation(
        config,
        operation,
        { id: "999" },
        undefined
      );

      expect(result.isOk()).toBe(true);
      if (result.isOk()) {
        // The parser receives the graphql result (with data = null)
        // In this simple mock, data is null so user is null
        expect(result.value).toEqual({
          user: null,
        });
      }
    });

    it("should handle network errors", async () => {
      const networkError = new Error("Network request failed");
      networkError.name = "TypeError";

      const client = createMockClient(networkError);
      const config: ExecutorConfig = { client };
      const operation = createTestOperation();

      const result = await executeOperation(
        config,
        operation,
        { id: "1" },
        undefined
      );

      expect(result.isOk()).toBe(true);
      if (result.isOk()) {
        // The parser receives the non-graphql error
        expect(result.value).toHaveProperty("error");
        const value = result.value as any;
        expect(value.error.code).toBe("NETWORK_ERROR");
      }
    });

    it("should merge headers from config and options", async () => {
      let capturedHeaders: GraffleHeadersInit | undefined;

      const mockClient: GraphQLClient = {
        async request<
          TData extends object = Record<string, unknown>,
          TVariables = Record<string, unknown>,
          TExtensions extends object = Record<string, unknown>
        >(
          _doc: string,
          _vars?: TVariables,
          headers?: GraffleHeadersInit
        ): Promise<FormattedExecutionResult<TData, TExtensions>> {
          capturedHeaders = headers;
          return {
            data: { user: { id: "1", name: "Alice" } },
          } as FormattedExecutionResult<TData, TExtensions>;
        },
      };

      const config: ExecutorConfig = {
        client: mockClient,
        headers: { Authorization: "Bearer token" },
      };

      const operation = createTestOperation();

      await executeOperation(
        config,
        operation,
        { id: "1" },
        { headers: { "X-Request-ID": "123" } }
      );

      expect(capturedHeaders).toEqual({
        Authorization: "Bearer token",
        "X-Request-ID": "123",
      });
    });
  });

  describe("createExecutor", () => {
    it("should create an executor bound to config", async () => {
      const mockResponse: FormattedExecutionResult = {
        data: {
          user: {
            id: "1",
            name: "Alice",
          },
        },
      };

      const client = createMockClient(mockResponse);
      const config: ExecutorConfig = { client };
      const executor = createExecutor(config);
      const operation = createTestOperation();

      const result = await executor.execute(operation, { id: "1" });

      expect(result.isOk()).toBe(true);
      if (result.isOk()) {
        expect(result.value).toEqual({
          user: {
            user: {
              id: "1",
              name: "Alice",
            },
          },
        });
      }
    });
  });
});

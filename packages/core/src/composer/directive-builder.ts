/**
 * Directive builder utilities for creating field-level directives.
 *
 * Provides type-safe methods for creating directive references that can be
 * applied to field selections. The builder follows a similar pattern to
 * the variable builder ($var).
 *
 * @module
 */

import { type AnyDirectiveRef, type DirectiveLocation, DirectiveRef } from "../types/type-foundation/directive-ref";
import type { AnyVarRef } from "../types/type-foundation/var-ref";

/**
 * A method that creates a DirectiveRef with specific type information.
 * The TArgs type defines the expected argument shape for the directive.
 */
export type DirectiveMethod<TDirectiveName extends string, TLocations extends readonly DirectiveLocation[], TArgs> = (
  args: TArgs,
) => DirectiveRef<{
  directiveName: TDirectiveName;
  locations: TLocations;
}>;

/**
 * Type for directive arguments that can include VarRef values.
 * This allows using variables in directive arguments like `{ if: $.shouldSkip }`.
 */
export type DirectiveArgValue = boolean | string | number | null | AnyVarRef;

/**
 * Standard GraphQL directives that are always available.
 */
export type StandardDirectives = {
  /**
   * @skip directive - conditionally skip a field.
   * @example
   * ```typescript
   * f.email({}, { directives: [$directive.skip({ if: $.hideEmail })] })
   * ```
   */
  skip: DirectiveMethod<"skip", readonly ["FIELD", "FRAGMENT_SPREAD", "INLINE_FRAGMENT"], { if: DirectiveArgValue }>;

  /**
   * @include directive - conditionally include a field.
   * @example
   * ```typescript
   * f.email({}, { directives: [$directive.include({ if: $.showEmail })] })
   * ```
   */
  include: DirectiveMethod<"include", readonly ["FIELD", "FRAGMENT_SPREAD", "INLINE_FRAGMENT"], { if: DirectiveArgValue }>;
};

/**
 * Creates a directive method factory for a specific directive.
 *
 * @param name - The directive name (without @)
 * @param locations - Valid locations where the directive can be applied
 * @returns A function that creates DirectiveRef instances
 *
 * @example
 * ```typescript
 * const skipMethod = createDirectiveMethod("skip", ["FIELD", "FRAGMENT_SPREAD", "INLINE_FRAGMENT"] as const);
 * const skipDirective = skipMethod({ if: true });
 * ```
 */
export const createDirectiveMethod = <TDirectiveName extends string, const TLocations extends readonly DirectiveLocation[]>(
  name: TDirectiveName,
  locations: TLocations,
): (<TArgs extends Record<string, unknown>>(
  args: TArgs,
) => DirectiveRef<{
  directiveName: TDirectiveName;
  locations: TLocations;
}>) => {
  return (args) =>
    new DirectiveRef({
      name,
      arguments: args,
      locations,
    }) as DirectiveRef<{
      directiveName: TDirectiveName;
      locations: TLocations;
    }>;
};

/**
 * Standard directive locations for @skip and @include.
 */
const CONDITIONAL_DIRECTIVE_LOCATIONS = ["FIELD", "FRAGMENT_SPREAD", "INLINE_FRAGMENT"] as const;

/**
 * Creates the standard GraphQL directives (@skip, @include).
 * These are always available regardless of schema definition.
 *
 * @returns Object containing skip and include directive methods
 *
 * @example
 * ```typescript
 * const $directive = createStandardDirectives();
 * const skipDirective = $directive.skip({ if: true });
 * ```
 */
export const createStandardDirectives = (): StandardDirectives => ({
  skip: createDirectiveMethod("skip", CONDITIONAL_DIRECTIVE_LOCATIONS),
  include: createDirectiveMethod("include", CONDITIONAL_DIRECTIVE_LOCATIONS),
});

/**
 * Type for any directive method (type-erased).
 */
// biome-ignore lint/suspicious/noExplicitAny: intentionally erased for flexibility
export type AnyDirectiveMethod = (args: any) => AnyDirectiveRef;

/**
 * Type for the directive builder that includes standard directives
 * and can be extended with schema-specific directives.
 */
export type DirectiveBuilder<TCustomDirectives extends Record<string, AnyDirectiveMethod> = {}> = StandardDirectives &
  TCustomDirectives;

/**
 * Creates a directive builder with standard directives and optional custom directives.
 *
 * @param customDirectives - Additional directive methods from schema (generated by codegen)
 * @returns Combined directive builder with all available directives
 *
 * @internal Used by codegen to create schema-specific directive builders
 */
export const createDirectiveBuilder = <TCustomDirectives extends Record<string, AnyDirectiveMethod> = {}>(
  customDirectives?: TCustomDirectives,
): DirectiveBuilder<TCustomDirectives> => {
  return {
    ...createStandardDirectives(),
    ...(customDirectives ?? ({} as TCustomDirectives)),
  };
};

/**
 * Type guard to check if a value is a DirectiveRef.
 *
 * @param value - Value to check
 * @returns True if value is a DirectiveRef instance
 */
export const isDirectiveRef = (value: unknown): value is AnyDirectiveRef => {
  return value instanceof DirectiveRef;
};

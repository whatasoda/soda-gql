/**
 * Prebuilt element composer for bundler-compatible type resolution.
 *
 * This composer provides the same functionality as the standard composer,
 * but looks up types from a prebuilt registry instead of using complex
 * type inference that may be lost during bundling.
 *
 * @module
 */

import type { AnyFragment, Fragment, Operation } from "../types/element";
import type { AnyAssignableInput, AnyFields } from "../types/fragment";
import type { AnyAdapter, DefaultAdapter } from "../types/metadata";
import type { AnyConstAssignableInput, AnyGraphqlSchema, OperationType } from "../types/schema";
import type { PrebuiltTypeRegistry } from "../prebuilt/types";
import { createGqlElementComposer, type GqlElementComposerOptions } from "./gql-composer";
import type { StandardDirectives } from "./directive-builder";

/**
 * Resolves the output type for a prebuilt element.
 *
 * For Operations: Looks up by operation name in the registry
 * For Fragments: Looks up by fragment key in the registry
 * Falls back to the element's original type if not found in registry
 */
export type ResolvePrebuiltElement<TElement, TPrebuilt extends PrebuiltTypeRegistry> =
  // Handle Operation types
  TElement extends Operation<
    infer TOperationType extends OperationType,
    infer TOperationName extends string,
    infer TVariableNames extends string[],
    // biome-ignore lint/suspicious/noExplicitAny: Required for conditional type matching
    any,
    infer TFields extends Partial<AnyFields>,
    // biome-ignore lint/suspicious/noExplicitAny: Required for conditional type matching
    any
  >
    ? TOperationName extends keyof TPrebuilt["operations"]
      ? Operation<
          TOperationType,
          TOperationName,
          TVariableNames,
          TPrebuilt["operations"][TOperationName]["input"] & AnyConstAssignableInput,
          TFields,
          TPrebuilt["operations"][TOperationName]["output"] & object
        >
      : TElement
    : // Handle Fragment types
      TElement extends Fragment<
          infer TTypeName extends string,
          // biome-ignore lint/suspicious/noExplicitAny: Required for conditional type matching
          any,
          infer TFields extends Partial<AnyFields>,
          // biome-ignore lint/suspicious/noExplicitAny: Required for conditional type matching
          any,
          infer TKey extends string | undefined
        >
      ? TKey extends keyof TPrebuilt["fragments"]
        ? Fragment<
            TTypeName,
            TPrebuilt["fragments"][TKey]["input"] extends infer TInput
              ? TInput extends AnyAssignableInput
                ? Partial<TInput>
                : void
              : void,
            TFields,
            TPrebuilt["fragments"][TKey]["output"] & object,
            TKey
          >
        : TElement
      : TElement;

/**
 * Prebuilt element composer that resolves types from a registry.
 */
export type PrebuiltGqlElementComposer<TContext, TPrebuilt extends PrebuiltTypeRegistry> = <
  TResult extends AnyFragment | Operation<OperationType, string, string[], AnyConstAssignableInput, AnyFields, object>,
>(
  composeElement: (context: TContext) => TResult,
) => ResolvePrebuiltElement<TResult, TPrebuilt>;

/**
 * Creates a prebuilt GQL element composer for a given schema.
 *
 * This composer has the same runtime behavior as `createGqlElementComposer`,
 * but the returned elements have their types resolved from the PrebuiltTypeRegistry
 * instead of using complex type inference.
 *
 * Use this when bundling with tools like tsdown that may lose type information.
 *
 * @param schema - The GraphQL schema definition
 * @param options - Configuration including input type methods and optional adapter
 * @returns Prebuilt element composer function
 *
 * @example
 * ```typescript
 * // Generated by codegen in prebuilt/index.ts
 * import type { PrebuiltTypes } from "./types";
 *
 * const gql = createPrebuiltGqlElementComposer<
 *   Schema,
 *   PrebuiltTypes,
 *   FragmentBuilders,
 *   DirectiveMethods,
 *   Context
 * >(schema, { inputTypeMethods });
 *
 * // Types are resolved from PrebuiltTypes registry
 * const GetUser = gql(({ query }) =>
 *   query.operation({
 *     name: "GetUser",
 *     fields: ({ f }) => ({ ...f.user({ id: "1" })(({ f }) => ({ ...f.id() })) }),
 *   })
 * );
 * // GetUser.$infer.output is PrebuiltTypes["operations"]["GetUser"]["output"]
 * ```
 */
export const createPrebuiltGqlElementComposer = <
  TSchema extends AnyGraphqlSchema,
  TPrebuilt extends PrebuiltTypeRegistry,
  TFragmentBuilders,
  TDirectiveMethods extends StandardDirectives,
  TContext,
  TAdapter extends AnyAdapter = DefaultAdapter,
>(
  schema: NoInfer<TSchema>,
  options: GqlElementComposerOptions<NoInfer<TSchema>, NoInfer<TDirectiveMethods>, NoInfer<TAdapter>>,
): PrebuiltGqlElementComposer<TContext, TPrebuilt> => {
  // Use the standard composer internally - same runtime behavior
  const baseComposer = createGqlElementComposer<TSchema, TFragmentBuilders, TDirectiveMethods, TAdapter>(
    schema,
    options,
  );

  // Cast to prebuilt composer type - types are resolved from registry
  return baseComposer as unknown as PrebuiltGqlElementComposer<TContext, TPrebuilt>;
};

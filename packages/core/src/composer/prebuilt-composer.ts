/**
 * Prebuilt element composer for bundler-compatible type resolution.
 *
 * This composer provides the same functionality as the standard composer,
 * but looks up types from a prebuilt registry instead of using complex
 * type inference that may be lost during bundling.
 *
 * @module
 */

import type { PrebuiltEntryNotFound, PrebuiltTypeRegistry, PrebuiltUnknownElement } from "../prebuilt/types";
import type { AnyFragment, Fragment, Operation } from "../types/element";
import type { AnyAssignableInput, AnyFields } from "../types/fragment";
import type { AnyAdapter, DefaultAdapter } from "../types/metadata";
import type { AnyConstAssignableInput, AnyGraphqlSchema, OperationType } from "../types/schema";
import type { StandardDirectives } from "./directive-builder";
import { createGqlElementComposer, type GqlElementComposerOptions } from "./gql-composer";

/**
 * Resolves the output type for a prebuilt element (strict mode).
 *
 * For Operations: Looks up by operation name in the registry
 * For Fragments: Looks up by fragment key in the registry
 *
 * Returns `PrebuiltEntryNotFound` error type if the element is not found
 * in the registry, forcing users to ensure all elements are properly
 * registered via typegen.
 */
export type ResolvePrebuiltElement<TElement, TPrebuilt extends PrebuiltTypeRegistry> = TElement extends Operation<
  // Handle Operation types
  infer TOperationType extends OperationType,
  infer TOperationName extends string,
  infer TVariableNames extends string[],
  // biome-ignore lint/suspicious/noExplicitAny: Required for conditional type matching
  any,
  infer TFields extends Partial<AnyFields>,
  // biome-ignore lint/suspicious/noExplicitAny: Required for conditional type matching
  any
>
  ? TOperationName extends keyof TPrebuilt["operations"]
    ? Operation<
        TOperationType,
        TOperationName,
        TVariableNames,
        TPrebuilt["operations"][TOperationName]["input"] & AnyConstAssignableInput,
        TFields,
        TPrebuilt["operations"][TOperationName]["output"] & object
      >
    : Operation<
        TOperationType,
        TOperationName,
        TVariableNames,
        PrebuiltEntryNotFound<TOperationName, "operation">,
        TFields,
        PrebuiltEntryNotFound<TOperationName, "operation">
      >
  : // Handle Fragment types
    TElement extends Fragment<
        infer TTypeName extends string,
        // biome-ignore lint/suspicious/noExplicitAny: Required for conditional type matching
        any,
        infer TFields extends Partial<AnyFields>,
        // biome-ignore lint/suspicious/noExplicitAny: Required for conditional type matching
        any,
        infer TKey extends string | undefined
      >
    ? TKey extends string
      ? TKey extends keyof TPrebuilt["fragments"]
        ? Fragment<
            TTypeName,
            TPrebuilt["fragments"][TKey]["input"] extends infer TInput
              ? TInput extends AnyAssignableInput
                ? Partial<TInput>
                : void
              : void,
            TFields,
            TPrebuilt["fragments"][TKey]["output"] & object,
            TKey
          >
        : Fragment<TTypeName, PrebuiltEntryNotFound<TKey, "fragment">, TFields, PrebuiltEntryNotFound<TKey, "fragment">, TKey>
      : Fragment<
          TTypeName,
          PrebuiltEntryNotFound<"(undefined)", "fragment">,
          TFields,
          PrebuiltEntryNotFound<"(undefined)", "fragment">,
          TKey
        >
    : PrebuiltUnknownElement<TElement>;

/**
 * Prebuilt element composer that resolves types from a registry.
 */
export type PrebuiltGqlElementComposer<TContext, TPrebuilt extends PrebuiltTypeRegistry> = <
  TResult extends AnyFragment | Operation<OperationType, string, string[], AnyConstAssignableInput, AnyFields, object>,
>(
  composeElement: (context: TContext) => TResult,
) => ResolvePrebuiltElement<TResult, TPrebuilt>;

/**
 * Prebuilt element composer with schema access.
 *
 * Extends the prebuilt composer function with a `$schema` property that provides
 * runtime access to the schema definition.
 */
export type PrebuiltGqlElementComposerWithSchema<
  TContext,
  TPrebuilt extends PrebuiltTypeRegistry,
  TSchema extends AnyGraphqlSchema,
> = PrebuiltGqlElementComposer<TContext, TPrebuilt> & {
  /**
   * The GraphQL schema definition used by this composer.
   */
  readonly $schema: TSchema;
};

/**
 * Creates a prebuilt GQL element composer for a given schema.
 *
 * This composer has the same runtime behavior as `createGqlElementComposer`,
 * but the returned elements have their types resolved from the PrebuiltTypeRegistry
 * instead of using complex type inference.
 *
 * Use this when bundling with tools like tsdown that may lose type information.
 *
 * @param schema - The GraphQL schema definition
 * @param options - Configuration including input type methods and optional adapter
 * @returns Prebuilt element composer function
 *
 * @example
 * ```typescript
 * // Generated by codegen in prebuilt/index.ts
 * import type { PrebuiltTypes } from "./types";
 *
 * const gql = createPrebuiltGqlElementComposer<
 *   Schema,
 *   PrebuiltTypes,
 *   FragmentBuilders,
 *   DirectiveMethods,
 *   Context
 * >(schema, { inputTypeMethods });
 *
 * // Types are resolved from PrebuiltTypes registry
 * const GetUser = gql(({ query }) =>
 *   query.operation({
 *     name: "GetUser",
 *     fields: ({ f }) => ({ ...f.user({ id: "1" })(({ f }) => ({ ...f.id() })) }),
 *   })
 * );
 * // GetUser.$infer.output is PrebuiltTypes["operations"]["GetUser"]["output"]
 * ```
 */
export const createPrebuiltGqlElementComposer = <
  TSchema extends AnyGraphqlSchema,
  TPrebuilt extends PrebuiltTypeRegistry,
  TFragmentBuilders,
  TDirectiveMethods extends StandardDirectives,
  TContext,
  TAdapter extends AnyAdapter = DefaultAdapter,
>(
  schema: NoInfer<TSchema>,
  options: GqlElementComposerOptions<NoInfer<TSchema>, NoInfer<TDirectiveMethods>, NoInfer<TAdapter>>,
): PrebuiltGqlElementComposerWithSchema<TContext, TPrebuilt, TSchema> => {
  // Use the standard composer internally - same runtime behavior
  // Note: baseComposer already has $schema attached by createGqlElementComposer
  const baseComposer = createGqlElementComposer<TSchema, TFragmentBuilders, TDirectiveMethods, TAdapter>(schema, options);

  // Type-only cast: The prebuilt composer has identical runtime behavior to the standard
  // composer. The difference is purely in the type signature - PrebuiltGqlElementComposer
  // resolves element types from the PrebuiltTypeRegistry instead of using complex type
  // inference that may be lost during bundling. This cast is safe because:
  // 1. Runtime behavior is unchanged (same underlying createGqlElementComposer call)
  // 2. Only the return type's type parameters differ (TPrebuilt vs inferred types)
  // 3. $schema property is already attached by the base composer
  return baseComposer as unknown as PrebuiltGqlElementComposerWithSchema<TContext, TPrebuilt, TSchema>;
};

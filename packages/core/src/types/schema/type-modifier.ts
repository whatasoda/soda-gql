import "./type-modifier.generated";

export declare namespace TypeModifierNS {
  export interface TypeProfile {
    readonly kind: "scalar" | "enum" | "input";
    readonly name: string;
    readonly value: any;
  }

  export type SpecialValueType = keyof SpecialValueFactory<any, any, any>;
  // biome-ignore lint/suspicious/noEmptyInterface: This is placeholder
  interface SpecialValueFactory<TType extends TypeProfile, TModifier extends TypeModifier, TWithDefault extends boolean> {}

  type Special<
    TType extends TypeProfile,
    TModifier extends TypeModifier,
    TWithDefault extends boolean,
    TRefMode extends SpecialValueType,
  > = SpecialValueFactory<TType, TModifier, TWithDefault>[TRefMode];

  export type TypeModifier = keyof Modified<any>;
  export type ApplyTypeModifier<T, M extends TypeModifier> = Modified<T>[M];
  export type GetModifiedType<T extends TypeProfile, M extends TypeModifier> = Modified<T["value"]>[M];
  export type GetAssignableType<
    TType extends TypeProfile,
    TModifier extends TypeModifier,
    TWithDefault extends boolean,
    TRefMode extends SpecialValueType,
  > = Assignable<TType, TWithDefault, TRefMode>[TModifier];

  interface Modified<T> {
    // depth = 0
    "?": T | null | undefined;
    "!": T;

    // NOTE: rest of the modifiers are generated by the script
  }

  interface Assignable<T extends TypeProfile, D extends boolean, S extends SpecialValueType> {
    // depth = 0
    "?": Special<T, "?", D, S> | Modified<T["value"]>["?"];
    "!": Special<T, "!", D, S> | Modified<T["value"]>["!"];

    // NOTE: rest of the modifiers are generated by the script
  }
}

export type TypeModifier = TypeModifierNS.TypeModifier;
export type TypeProfile = TypeModifierNS.TypeProfile;
export type SpecialValueType = TypeModifierNS.SpecialValueType;
export type ApplyTypeModifier<T, M extends TypeModifier> = TypeModifierNS.ApplyTypeModifier<T, M>;
export type GetModifiedType<T extends TypeProfile, M extends TypeModifier> = TypeModifierNS.GetModifiedType<T, M>;
export type GetAssignableType<
  T extends TypeProfile,
  M extends TypeModifier,
  D extends boolean,
  S extends SpecialValueType,
> = TypeModifierNS.GetAssignableType<T, M, D, S>;

export type ModifiedTypeName<TName extends string, TModifier extends TypeModifier> = `${TName}:${TModifier}`;

export function parseModifiedTypeName<TName extends string, TModifier extends TypeModifier>(
  nameAndModifier: ModifiedTypeName<TName, TModifier>,
) {
  if (typeof nameAndModifier !== "string") {
    throw new Error(`Invalid modified type name: ${nameAndModifier}`);
  }

  const [name, modifier] = nameAndModifier.split(":") as [TName, TModifier];
  return { name, modifier };
}

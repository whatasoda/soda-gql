import type { WithTypeMeta } from "../../utils/type-meta";
import type {
  AnyDefaultValue,
  DecrementDepth,
  DepthCounter,
  GetInputTypeDepth,
  InputDepthOverrides,
  InputEnumSpecifier,
  InputScalarSpecifier,
  InputTypeSpecifier,
  InputTypeSpecifiers,
  IsDepthExhausted,
  OutputInferrableTypeSpecifier,
  OutputScalarSpecifier,
  OutputTypeSpecifiers,
  OutputUnionSpecifier,
  TypeModifier,
  TypeProfile,
} from "../type-foundation";

export type OperationType = keyof OperationRoots;
export type AnyTypeName = string;
export type AnyFieldName = string;

export type AnyGraphqlSchema = {
  readonly label: string;
  readonly operations: OperationRoots;
  readonly scalar: { readonly [name: string]: ScalarDefinition<any> };
  readonly enum: { readonly [name: string]: EnumDefinition<any> };
  readonly input: { readonly [name: string]: InputDefinition };
  readonly object: { readonly [name: string]: ObjectDefinition };
  readonly union: { readonly [name: string]: UnionDefinition };
  /**
   * Optional default depth for input type inference.
   * Used when no per-type override is specified.
   * Generated by codegen when defaultInputDepth is specified in config.
   */
  readonly __defaultInputDepth?: number;
  /**
   * Optional depth overrides for input type inference.
   * Maps input type names to their maximum inference depth.
   * Generated by codegen when inputDepthOverrides is specified in config.
   */
  readonly __inputDepthOverrides?: InputDepthOverrides;
  /**
   * Optional typename mode for type inference.
   * - "always": Include __typename in all object types
   * - "union-only": Include __typename only in union member types (default)
   * - "never": Never auto-include __typename
   * Generated by codegen when typenameMode is specified in config.
   */
  readonly __typenameMode?: "always" | "union-only" | "never";
  // directives: {
  //   query: { [typename: string]: Directive<any> }
  //   mutation: { [typename: string]: true };
  //   subscription: { [typename: string]: true };
  //   parameter: { [typename: string]: true };
  // };
};

export type OperationRoots = {
  readonly query: string | null;
  readonly mutation: string | null;
  readonly subscription: string | null;
};

export interface ScalarDefinition<T extends { name: string; input: unknown; output: unknown }>
  extends WithTypeMeta<{
    input: T["input"];
    inputProfile: {
      kind: "scalar";
      name: T["name"];
      value: T["input"];
    };
    output: T["output"];
    outputProfile: {
      kind: "scalar";
      name: T["name"];
      value: T["output"];
    };
  }> {
  readonly name: T["name"];
}

export interface EnumDefinition<T extends { name: string; values: string }>
  extends WithTypeMeta<{
    name: T["name"];
    inputProfile: {
      kind: "enum";
      name: T["name"];
      value: T["values"];
    };
    outputProfile: {
      kind: "enum";
      name: T["name"];
      value: T["values"];
    };
  }> {
  readonly name: T["name"];

  readonly values: { readonly [_ in T["values"]]: true };
}

export interface InputDefinition {
  readonly name: string;

  readonly fields: InputTypeSpecifiers;

  // TODO: implement
  // oneOf: boolean;
}

export type ObjectDefinition = {
  readonly name: string;

  readonly fields: OutputTypeSpecifiers;
};

export type UnionDefinition = {
  readonly name: string;

  readonly types: { [typename: string]: true };
};

/**
 * Infers a TypeProfile from an input type specifier.
 *
 * @typeParam TSchema - The GraphQL schema
 * @typeParam TSpecifier - The input type specifier to infer from
 * @typeParam TDepth - Depth counter to limit recursion (default from schema overrides or schema default or 3 levels)
 *
 * When depth is exhausted, returns `never` to cause a type error.
 * This prevents infinite recursion in self-referential types like `bool_exp`.
 */
export type InferInputProfile<
  TSchema extends AnyGraphqlSchema,
  TSpecifier extends InputTypeSpecifier,
  TDepth extends DepthCounter = GetInputTypeDepth<
    TSchema["__inputDepthOverrides"],
    TSpecifier["name"],
    TSchema["__defaultInputDepth"]
  >,
> = {
  [_ in TSchema["label"]]: IsDepthExhausted<TDepth> extends true
    ? never
    : [
        TSpecifier extends InputScalarSpecifier
          ? TSchema["scalar"][TSpecifier["name"]]["$type"]["inputProfile"]
          : TSpecifier extends InputEnumSpecifier
            ? TSchema["enum"][TSpecifier["name"]]["$type"]["inputProfile"]
            : TSchema["input"][TSpecifier["name"]]["fields"] extends infer TFields
              ? {
                  kind: "input";
                  name: TSpecifier["name"];
                  fields: {
                    [K in keyof TFields]: TFields[K] extends InputTypeSpecifier
                      ? InferInputProfile<TSchema, TFields[K], DecrementDepth<TDepth>>
                      : never;
                  };
                }
              : never,
        TSpecifier["modifier"],
        TSpecifier["defaultValue"] extends AnyDefaultValue ? TypeProfile.WITH_DEFAULT_INPUT : undefined,
      ];
}[TSchema["label"]];

export type InferOutputProfile<TSchema extends AnyGraphqlSchema, TSpecifier extends OutputInferrableTypeSpecifier> = {
  [_ in TSchema["label"]]: (TSpecifier extends OutputScalarSpecifier
    ? TSchema["scalar"][TSpecifier["name"]]
    : TSchema["enum"][TSpecifier["name"]])["$type"]["outputProfile"];
}[TSchema["label"]];

export type PickTypeSpecifierByFieldName<
  TSchema extends AnyGraphqlSchema,
  TTypeName extends keyof TSchema["object"],
  TFieldName extends keyof TSchema["object"][TTypeName]["fields"],
> = TSchema["object"][TTypeName]["fields"][TFieldName];

export type InputFieldRecord<
  TSchema extends AnyGraphqlSchema,
  TSpecifier extends InputTypeSpecifier,
> = TSchema["input"][TSpecifier["name"]]["fields"];

export type ObjectFieldRecord<TSchema extends AnyGraphqlSchema, TTypeName extends keyof TSchema["object"]> = {
  readonly [TFieldName in keyof TSchema["object"][TTypeName]["fields"]]: TSchema["object"][TTypeName]["fields"][TFieldName];
};

export type UnionTypeRecord<TSchema extends AnyGraphqlSchema, TSpecifier extends OutputUnionSpecifier> = {
  readonly [TTypeName in UnionMemberName<TSchema, TSpecifier>]: TSchema["object"][TTypeName];
};

export type UnionMemberName<TSchema extends AnyGraphqlSchema, TSpecifier extends OutputUnionSpecifier> = Extract<
  keyof TSchema["object"],
  keyof TSchema["union"][TSpecifier["name"]]["types"]
> &
  string;

/**
 * Union of all input type names in a schema (scalars, enums, and input objects).
 */
export type AllInputTypeNames<TSchema extends AnyGraphqlSchema> =
  | (keyof TSchema["scalar"] & string)
  | (keyof TSchema["enum"] & string)
  | (keyof TSchema["input"] & string);

/**
 * Infers the input type kind from a type name.
 */
export type InferInputKind<
  TSchema extends AnyGraphqlSchema,
  TName extends AllInputTypeNames<TSchema>,
> = TName extends keyof TSchema["scalar"]
  ? "scalar"
  : TName extends keyof TSchema["enum"]
    ? "enum"
    : TName extends keyof TSchema["input"]
      ? "input"
      : never;

/**
 * Resolves a TypeProfile from VarRefMetaV2 parameters (typeName + kind).
 * This is used by schema-aware functions like getValueAt to resolve type structure
 * from the schema at call site, rather than storing full profile in VarRef.
 *
 * @typeParam TSchema - The GraphQL schema
 * @typeParam TTypeName - The GraphQL type name (e.g., "String", "UserInput")
 * @typeParam TKind - The type kind ("scalar" | "enum" | "input")
 * @typeParam TModifier - The type modifier (e.g., "!", "?", "![]!")
 */
export type ResolveInputProfileFromMeta<
  TSchema extends AnyGraphqlSchema,
  TTypeName extends string,
  TKind extends "scalar" | "enum" | "input",
  TModifier extends TypeModifier,
> = TKind extends "scalar"
  ? InferInputProfile<
      TSchema,
      {
        kind: "scalar";
        name: TTypeName;
        modifier: TModifier;
        defaultValue: null;
        directives: {};
      }
    >
  : TKind extends "enum"
    ? InferInputProfile<
        TSchema,
        {
          kind: "enum";
          name: TTypeName;
          modifier: TModifier;
          defaultValue: null;
          directives: {};
        }
      >
    : InferInputProfile<
        TSchema,
        {
          kind: "input";
          name: TTypeName;
          modifier: TModifier;
          defaultValue: null;
          directives: {};
        }
      >;

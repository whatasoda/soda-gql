import { afterEach, beforeEach, describe, expect, test } from "bun:test";
import { existsSync, mkdirSync, mkdtempSync, readFileSync, rmSync, statSync, writeFileSync } from "node:fs";
import { tmpdir } from "node:os";
import { join } from "node:path";
import { ensureWrapperTransformer, generateCacheKey, generateWrapperContent } from "./wrapper-generator";

describe("wrapper-generator", () => {
  describe("generateCacheKey", () => {
    test("returns same hash for same input", () => {
      const path = "/path/to/transformer.js";
      const hash1 = generateCacheKey(path);
      const hash2 = generateCacheKey(path);

      expect(hash1).toBe(hash2);
      expect(hash1).toHaveLength(12);
    });

    test("returns different hash for different input", () => {
      const hash1 = generateCacheKey("/path/to/transformer1.js");
      const hash2 = generateCacheKey("/path/to/transformer2.js");

      expect(hash1).not.toBe(hash2);
    });
  });

  describe("generateWrapperContent", () => {
    test("includes correct module import", () => {
      const content = generateWrapperContent("/path/to/upstream.js");

      expect(content).toContain('require("@soda-gql/metro-plugin/transformer")');
      expect(content).toContain("createTransformerWithUpstream");
    });

    test("includes JSON.stringified upstream path", () => {
      const upstreamPath = "/path/to/upstream.js";
      const content = generateWrapperContent(upstreamPath);

      expect(content).toContain(JSON.stringify(upstreamPath));
    });

    test("includes required exports", () => {
      const content = generateWrapperContent("/path/to/upstream.js");

      expect(content).toContain("module.exports = transformer");
      expect(content).toContain("module.exports.transform = transformer.transform");
      expect(content).toContain("module.exports.getCacheKey = transformer.getCacheKey");
    });

    test("includes comment header with upstream path", () => {
      const upstreamPath = "/path/to/upstream.js";
      const content = generateWrapperContent(upstreamPath);

      expect(content).toContain("// Generated by @soda-gql/metro-plugin");
      expect(content).toContain("// DO NOT EDIT");
      expect(content).toContain(`// Upstream: ${upstreamPath}`);
    });
  });

  describe("ensureWrapperTransformer", () => {
    let testDir: string;

    beforeEach(() => {
      testDir = mkdtempSync(join(tmpdir(), "metro-plugin-test-"));
    });

    afterEach(() => {
      rmSync(testDir, { recursive: true, force: true });
    });

    test("creates new file when not exists", () => {
      const upstreamPath = "/path/to/upstream.js";
      const result = ensureWrapperTransformer({
        upstreamTransformerPath: upstreamPath,
        projectRoot: testDir,
      });

      expect(existsSync(result)).toBe(true);
      expect(result).toContain(testDir);
      expect(result).toContain("metro-transformer-wrapper.js");

      const content = readFileSync(result, "utf-8");
      expect(content).toContain(JSON.stringify(upstreamPath));
    });

    test("skips regeneration when existing file has same content", () => {
      const upstreamPath = "/path/to/upstream.js";
      const options = {
        upstreamTransformerPath: upstreamPath,
        projectRoot: testDir,
      };

      // First call creates the file
      const result1 = ensureWrapperTransformer(options);
      const stat1 = statSync(result1);

      // Wait a bit to ensure mtime would change if file was rewritten
      const originalMtime = stat1.mtimeMs;

      // Second call should skip regeneration
      const result2 = ensureWrapperTransformer(options);
      const stat2 = statSync(result2);

      expect(result1).toBe(result2);
      expect(stat2.mtimeMs).toBe(originalMtime);
    });

    test("regenerates when existing file has different content", () => {
      const upstreamPath = "/path/to/upstream.js";
      const cacheDir = join(testDir, "node_modules/.cache/soda-gql");

      // Create cache directory and write a file with wrong content
      mkdirSync(cacheDir, { recursive: true });

      // First create with one path to get the file location
      const result1 = ensureWrapperTransformer({
        upstreamTransformerPath: upstreamPath,
        projectRoot: testDir,
      });

      // Overwrite with different content
      writeFileSync(result1, "// wrong content", "utf-8");

      // Call again - should regenerate
      const result2 = ensureWrapperTransformer({
        upstreamTransformerPath: upstreamPath,
        projectRoot: testDir,
      });

      expect(result2).toBe(result1);
      const content = readFileSync(result2, "utf-8");
      expect(content).toContain(JSON.stringify(upstreamPath));
      expect(content).not.toBe("// wrong content");
    });

    test("creates cache directory when not exists", () => {
      const cacheDir = join(testDir, "node_modules/.cache/soda-gql");
      expect(existsSync(cacheDir)).toBe(false);

      ensureWrapperTransformer({
        upstreamTransformerPath: "/path/to/upstream.js",
        projectRoot: testDir,
      });

      expect(existsSync(cacheDir)).toBe(true);
    });

    test("generates different files for different upstream paths", () => {
      const result1 = ensureWrapperTransformer({
        upstreamTransformerPath: "/path/to/upstream1.js",
        projectRoot: testDir,
      });

      const result2 = ensureWrapperTransformer({
        upstreamTransformerPath: "/path/to/upstream2.js",
        projectRoot: testDir,
      });

      expect(result1).not.toBe(result2);
    });
  });
});

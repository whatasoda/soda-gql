import { createHash } from "node:crypto";
import { existsSync, mkdirSync, readFileSync, writeFileSync } from "node:fs";
import { join } from "node:path";

/** Cache directory location relative to project root */
const CACHE_DIR = "node_modules/.cache/soda-gql";

/** Wrapper file name suffix */
const WRAPPER_FILE = "metro-transformer-wrapper.js";

/**
 * Options for generating wrapper transformer.
 */
export type WrapperGeneratorOptions = {
  /** Absolute path to the upstream transformer to chain */
  readonly upstreamTransformerPath: string;
  /** Absolute path to the project root */
  readonly projectRoot: string;
};

/**
 * Generate a deterministic hash for cache key.
 * Includes version prefix for cache invalidation on plugin updates.
 */
function generateCacheKey(upstreamPath: string): string {
  const hash = createHash("md5");
  hash.update("@soda-gql/metro-plugin:wrapper:v1");
  hash.update(upstreamPath);
  return hash.digest("hex").slice(0, 12);
}

/**
 * Generate wrapper transformer content.
 * The generated file imports soda-gql transformer factory and creates
 * a transformer instance with the hardcoded upstream path.
 */
function generateWrapperContent(upstreamPath: string): string {
  return `// Generated by @soda-gql/metro-plugin
// DO NOT EDIT - This file is auto-generated
// Upstream: ${upstreamPath}

const { createTransformerWithUpstream } = require("@soda-gql/metro-plugin/transformer");

const transformer = createTransformerWithUpstream(${JSON.stringify(upstreamPath)});

module.exports = transformer;
module.exports.transform = transformer.transform;
module.exports.getCacheKey = transformer.getCacheKey;
`;
}

/**
 * Get or create wrapper transformer file.
 * Returns the absolute path to the wrapper file.
 *
 * The wrapper file is cached based on the upstream transformer path.
 * If the file already exists with the same content, it is reused.
 *
 * @param options - Wrapper generator options
 * @returns Absolute path to the wrapper transformer file
 */
export function ensureWrapperTransformer(options: WrapperGeneratorOptions): string {
  const { upstreamTransformerPath, projectRoot } = options;

  const cacheDir = join(projectRoot, CACHE_DIR);
  const cacheKey = generateCacheKey(upstreamTransformerPath);
  const wrapperPath = join(cacheDir, `${cacheKey}-${WRAPPER_FILE}`);

  // Generate expected content
  const expectedContent = generateWrapperContent(upstreamTransformerPath);

  // Check if wrapper needs regeneration
  if (existsSync(wrapperPath)) {
    try {
      const existingContent = readFileSync(wrapperPath, "utf-8");
      if (existingContent === expectedContent) {
        return wrapperPath;
      }
    } catch {
      // File exists but couldn't be read, regenerate
    }
  }

  // Create cache directory if it doesn't exist
  mkdirSync(cacheDir, { recursive: true });

  // Write wrapper file
  writeFileSync(wrapperPath, expectedContent, "utf-8");

  return wrapperPath;
}

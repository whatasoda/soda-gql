import { readdir, readFile, writeFile, access, mkdir } from "node:fs/promises";
import { join, relative, dirname, extname, basename } from "node:path";
import { constants } from "node:fs";

const REPO_ROOT = join(import.meta.dir, "..");
const PACKAGES_DIR = join(REPO_ROOT, "packages");
const GENERATED_DIR = join(REPO_ROOT, "scripts/generated");
const STATIC_EXPORTS = ["./package.json"];

interface ExportsJson {
  [key: string]: string;
}

interface PackageJson {
  name: string;
  main?: string;
  module?: string;
  types?: string;
  exports?: Record<string, unknown>;
  [key: string]: unknown;
}

async function validateSourceFile(packageDir: string, sourcePath: string): Promise<void> {
  const absolutePath = join(packageDir, sourcePath);
  try {
    await access(absolutePath, constants.F_OK);
  } catch {
    throw new Error(`Source file does not exist: ${sourcePath}`);
  }
}

function sourceToDistPath(sourcePath: string, ext: "js" | "cjs" | "d.ts"): string {
  const withoutSrc = sourcePath.replace(/^\.\/src\//, "./dist/");
  const withoutExt = withoutSrc.replace(/\.(ts|tsx|mts|cts)$/, "");
  return ext === "d.ts" ? `${withoutExt}.d.ts` : `${withoutExt}.${ext}`;
}

function generateExportsEntry(sourcePath: string) {
  return {
    development: sourcePath,
    types: sourceToDistPath(sourcePath, "d.ts"),
    import: sourceToDistPath(sourcePath, "js"),
    require: sourceToDistPath(sourcePath, "cjs"),
    default: sourceToDistPath(sourcePath, "js"),
  };
}

function normalizeEntryKey(exportKey: string, sourcePath: string): string {
  if (exportKey === ".") {
    return "index";
  }

  let entryKey = exportKey.replace(/^\.\//, "");

  // If the source path ends with /index.ts, add /index to the entry key
  if (sourcePath.endsWith("/index.ts")) {
    entryKey = entryKey + "/index";
  }

  return entryKey;
}

interface PackageManifest {
  name: string;
  entries: Record<string, string>;
}

async function syncPackageExports(
  packageName: string,
  aggregate: Record<string, Record<string, string>>
): Promise<void> {
  const packageDir = join(PACKAGES_DIR, packageName);
  const exportsJsonPath = join(packageDir, "exports.json");
  const packageJsonPath = join(packageDir, "package.json");

  // Check if exports.json exists
  let exportsJson: ExportsJson;
  try {
    const content = await readFile(exportsJsonPath, "utf-8");
    exportsJson = JSON.parse(content);
  } catch {
    console.log(`  ⚠ Skipping ${packageName}: no exports.json found`);
    return;
  }

  // Validate all source files exist
  for (const [key, sourcePath] of Object.entries(exportsJson)) {
    await validateSourceFile(packageDir, sourcePath);
  }

  // Read existing package.json
  const packageJsonContent = await readFile(packageJsonPath, "utf-8");
  const packageJson: PackageJson = JSON.parse(packageJsonContent);

  // Generate exports object
  const exports: Record<string, unknown> = {};

  // Build aggregate for tsdown manifest
  aggregate[packageJson.name] = {};

  for (const [key, sourcePath] of Object.entries(exportsJson)) {
    exports[key] = generateExportsEntry(sourcePath);

    // Add to aggregate with normalized entry key
    const entryKey = normalizeEntryKey(key, sourcePath);
    // @ts-expect-error - aggregate[packageJson.name] is initialized above
    aggregate[packageJson.name][entryKey] = join("packages", packageName, sourcePath);
  }

  // Add static exports
  for (const staticExport of STATIC_EXPORTS) {
    exports[staticExport] = staticExport;
  }

  // Update main/module/types from the default export (".")
  const defaultExport = exportsJson["."];
  if (defaultExport) {
    packageJson.main = sourceToDistPath(defaultExport, "js");
    packageJson.module = sourceToDistPath(defaultExport, "js");
    packageJson.types = sourceToDistPath(defaultExport, "d.ts");
  }

  packageJson.exports = exports;

  // Write updated package.json
  await writeFile(packageJsonPath, JSON.stringify(packageJson, null, 2) + "\n");

  const exportCount = Object.keys(exportsJson).length;
  console.log(`  ✓ ${packageName}: ${exportCount} export${exportCount === 1 ? "" : "s"}`);
}

async function main() {
  console.log("Syncing package exports...\n");

  const packages = await readdir(PACKAGES_DIR, { withFileTypes: true });
  const packageDirs = packages
    .filter((dirent) => dirent.isDirectory())
    .map((dirent) => dirent.name);

  const aggregate: Record<string, Record<string, string>> = {};

  for (const packageName of packageDirs) {
    try {
      await syncPackageExports(packageName, aggregate);
    } catch (error) {
      console.error(`  ✗ ${packageName}: ${error instanceof Error ? error.message : String(error)}`);
      process.exit(1);
    }
  }

  // Generate exports manifest for tsdown
  await mkdir(GENERATED_DIR, { recursive: true });
  const manifestTsContent = `// Auto-generated by scripts/sync-exports.ts
// Do not edit this file manually

export const packageEntries = ${JSON.stringify(aggregate, null, 2)} as const;

export function getPackageEntries(name: keyof typeof packageEntries): Record<string, string> {
  return packageEntries[name] ?? {};
}
`;

  const manifestJsContent = `// Auto-generated by scripts/sync-exports.ts
// Do not edit this file manually

export const packageEntries = ${JSON.stringify(aggregate, null, 2)};

export function getPackageEntries(name) {
  return packageEntries[name] ?? {};
}
`;

  await writeFile(join(GENERATED_DIR, "exports-manifest.ts"), manifestTsContent);
  await writeFile(join(GENERATED_DIR, "exports-manifest.js"), manifestJsContent);

  console.log("\n✓ All packages synchronized");
  console.log(`✓ Generated exports manifest: scripts/generated/exports-manifest.{ts,js}`);
}

main();

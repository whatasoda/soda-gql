#!/usr/bin/env bun
import * as fs from "node:fs/promises";
import * as path from "node:path";
import type { FixtureScale } from "./process-results";

export interface FixtureConfig extends FixtureScale {
  name: string;
}

/**
 * Predefined fixture scales.
 */
export const FIXTURE_PRESETS: Record<string, FixtureConfig> = {
  small: {
    name: "small",
    totalFiles: 50,
    gqlRatio: 0.2,
    objectTypes: 10,
    models: 5,
    slices: 5,
    operations: 5,
  },
  medium: {
    name: "medium",
    totalFiles: 200,
    gqlRatio: 0.15,
    objectTypes: 30,
    models: 15,
    slices: 15,
    operations: 15,
  },
  large: {
    name: "large",
    totalFiles: 500,
    gqlRatio: 0.12,
    objectTypes: 60,
    models: 30,
    slices: 30,
    operations: 30,
  },
  xlarge: {
    name: "xlarge",
    totalFiles: 1000,
    gqlRatio: 0.1,
    objectTypes: 100,
    models: 50,
    slices: 50,
    operations: 50,
  },
};

/**
 * Generate GraphQL schema SDL.
 */
function generateSchema(config: FixtureConfig): string {
  const lines: string[] = [
    "# Auto-generated schema for builder runtime benchmarking",
    "# DO NOT EDIT - this file is generated by generate-fixtures.ts",
    "",
  ];

  // Scalar definitions
  lines.push("scalar DateTime");
  lines.push("");

  // Query type
  lines.push("type Query {");
  for (let i = 0; i < config.objectTypes; i++) {
    lines.push(`  entity${i}(id: ID!): Entity${i}`);
    lines.push(`  entity${i}List(limit: Int, offset: Int): [Entity${i}!]!`);
  }
  lines.push("}");
  lines.push("");

  // Mutation type
  lines.push("type Mutation {");
  for (let i = 0; i < config.objectTypes; i++) {
    lines.push(`  createEntity${i}(name: String!, value: Int): Entity${i}!`);
    lines.push(`  updateEntity${i}(id: ID!, name: String): Entity${i}`);
    lines.push(`  deleteEntity${i}(id: ID!): Boolean!`);
  }
  lines.push("}");
  lines.push("");

  // Object types with varied field complexity
  for (let i = 0; i < config.objectTypes; i++) {
    const relatedIndex = (i + 1) % config.objectTypes;
    lines.push(`type Entity${i} {`);
    lines.push("  id: ID!");
    lines.push("  name: String!");
    lines.push("  description: String");
    lines.push("  value: Int");
    lines.push("  score: Float");
    lines.push("  isActive: Boolean!");
    lines.push("  createdAt: DateTime!");
    lines.push("  updatedAt: DateTime");
    lines.push(`  related: Entity${relatedIndex}`);
    lines.push(`  relatedList(limit: Int): [Entity${relatedIndex}!]!`);
    lines.push("}");
    lines.push("");
  }

  return lines.join("\n");
}

/**
 * Generate graphql-inject.ts with runtime adapter and scalars.
 */
function generateGraphqlInject(): string {
  return `// Auto-generated graphql-inject for builder runtime benchmarking
// DO NOT EDIT - this file is generated by generate-fixtures.ts

import { defineScalar } from "@soda-gql/core";
import { createRuntimeAdapter } from "@soda-gql/core/runtime";

export const scalar = {
  ...defineScalar<"ID", string, string>("ID"),
  ...defineScalar<"String", string, string>("String"),
  ...defineScalar<"Int", number, number>("Int"),
  ...defineScalar<"Float", number, number>("Float"),
  ...defineScalar<"Boolean", boolean, boolean>("Boolean"),
  ...defineScalar<"DateTime", string, Date>("DateTime"),
} as const;

export const adapter = createRuntimeAdapter(({ type }) => ({
  nonGraphqlErrorType: type<{ type: "non-graphql-error"; cause: unknown }>(),
}));
`;
}

/**
 * Generate soda-gql.config.ts.
 */
function generateConfig(): string {
  return `// Auto-generated config for builder runtime benchmarking
// DO NOT EDIT - this file is generated by generate-fixtures.ts

import { defineConfig } from "@soda-gql/config";

export default defineConfig({
  outdir: "graphql-system",
  include: ["src/**/*.ts"],
  exclude: ["src/**/*.test.ts", "src/**/*.spec.ts"],
  schemas: {
    default: {
      schema: "./schema.graphql",
      runtimeAdapter: "./graphql-inject.ts",
      scalars: "./graphql-inject.ts",
    },
  },
});
`;
}

/**
 * Generate a model file.
 */
function generateModelFile(index: number, entityIndex: number): string {
  return `// Auto-generated model for builder runtime benchmarking
import { gql } from "../../graphql-system";

export const model${index} = gql.default(({ model }) =>
  model.Entity${entityIndex}(
    {},
    ({ f }) => [
      f.id(),
      f.name(),
      f.description(),
      f.value(),
      f.isActive(),
      f.createdAt(),
      f.related()(({ f }) => [
        f.id(),
        f.name(),
        f.value(),
      ]),
      f.relatedList({ limit: 5 })(({ f }) => [
        f.id(),
        f.name(),
      ]),
    ],
    (selection) => ({
      id: selection.id,
      name: selection.name,
      description: selection.description,
      value: selection.value,
      isActive: selection.isActive,
      createdAt: selection.createdAt,
      related: selection.related,
      relatedList: selection.relatedList,
    }),
  ),
);
`;
}

/**
 * Generate a slice file.
 */
function generateSliceFile(index: number, entityIndex: number): string {
  const entityName = `entity${entityIndex}`;
  const isListSlice = index % 2 !== 0;

  if (isListSlice) {
    return `// Auto-generated slice for builder runtime benchmarking
import { gql } from "../../graphql-system";

export const slice${index} = gql.default(({ query }, { $var }) =>
  query.slice(
    {
      variables: [$var("limit").scalar("Int:?"), $var("offset").scalar("Int:?")],
    },
    ({ f, $ }) => [
      f.${entityName}List({ limit: $.limit, offset: $.offset })(({ f }) => [
        f.id(),
        f.name(),
        f.description(),
        f.value(),
        f.isActive(),
      ]),
    ],
    ({ select }) => select(["$.${entityName}List"], (result) => result),
  ),
);
`;
  }

  return `// Auto-generated slice for builder runtime benchmarking
import { gql } from "../../graphql-system";

export const slice${index} = gql.default(({ query }, { $var }) =>
  query.slice(
    {
      variables: [$var("id").scalar("ID:!")],
    },
    ({ f, $ }) => [
      f.${entityName}({ id: $.id })(({ f }) => [
        f.id(),
        f.name(),
        f.description(),
        f.value(),
        f.isActive(),
      ]),
    ],
    ({ select }) => select(["$.${entityName}"], (result) =>
      result.safeUnwrap((data) => data)
    ),
  ),
);
`;
}

/**
 * Generate an operation file.
 */
function generateOperationFile(index: number, sliceCount: number): string {
  const slicesPerOp = Math.min(3, sliceCount);
  const sliceImports: string[] = [];
  const sliceEmbeds: string[] = [];
  const sliceVars: string[] = [];

  for (let j = 0; j < slicesPerOp; j++) {
    const sliceIndex = (index * slicesPerOp + j) % sliceCount;
    const isListSlice = sliceIndex % 2 !== 0;

    sliceImports.push(`slice${sliceIndex}`);

    if (isListSlice) {
      sliceEmbeds.push(`      result${j}: slice${sliceIndex}.embed({ limit: $.limit${j}, offset: $.offset${j} }),`);
      sliceVars.push(`$var("limit${j}").scalar("Int:?")`);
      sliceVars.push(`$var("offset${j}").scalar("Int:?")`);
    } else {
      sliceEmbeds.push(`      result${j}: slice${sliceIndex}.embed({ id: $.id${j} }),`);
      sliceVars.push(`$var("id${j}").scalar("ID:!")`);
    }
  }

  // Generate individual imports for each slice
  const individualImports = sliceImports.map((s) => `import { ${s} } from "../entities/${s}";`).join("\n");

  return `// Auto-generated operation for builder runtime benchmarking
import { gql } from "../../graphql-system";
${individualImports}

export const operation${index} = gql.default(({ query }, { $var }) =>
  query.composed(
    {
      operationName: "Operation${index}",
      variables: [${sliceVars.join(", ")}],
    },
    ({ $ }) => ({
${sliceEmbeds.join("\n")}
    }),
  ),
);
`;
}

/**
 * Generate a noise component file (no gql).
 */
function generateNoiseComponent(index: number): string {
  return `// Auto-generated noise component (no gql)
import { useState, useCallback } from "react";

interface Props {
  title: string;
  onAction?: () => void;
}

export function Component${index}({ title, onAction }: Props) {
  const [count, setCount] = useState(0);

  const handleClick = useCallback(() => {
    setCount((c) => c + 1);
    onAction?.();
  }, [onAction]);

  return {
    title,
    count,
    handleClick,
  };
}

export function useComponent${index}Logic() {
  const [state, setState] = useState<Record<string, unknown>>({});

  return {
    state,
    setState,
    reset: () => setState({}),
  };
}
`;
}

/**
 * Generate a noise utility file (no gql).
 */
function generateNoiseUtil(index: number): string {
  return `// Auto-generated noise utility (no gql)

export function formatValue${index}(value: unknown): string {
  if (value === null || value === undefined) return "";
  if (typeof value === "string") return value;
  if (typeof value === "number") return value.toLocaleString();
  return JSON.stringify(value);
}

export function parseValue${index}(input: string): unknown {
  try {
    return JSON.parse(input);
  } catch {
    return input;
  }
}

export function validateInput${index}(input: unknown): boolean {
  return input !== null && input !== undefined;
}

export const CONSTANTS_${index} = {
  MAX_LENGTH: 100,
  MIN_LENGTH: 1,
  DEFAULT_VALUE: "default",
} as const;
`;
}

/**
 * Generate a noise hook file (no gql).
 */
function generateNoiseHook(index: number): string {
  return `// Auto-generated noise hook (no gql)
import { useState, useEffect, useCallback, useMemo } from "react";

export function useHook${index}<T>(initialValue: T) {
  const [value, setValue] = useState<T>(initialValue);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<Error | null>(null);

  const reset = useCallback(() => {
    setValue(initialValue);
    setLoading(false);
    setError(null);
  }, [initialValue]);

  const update = useCallback((newValue: T) => {
    setLoading(true);
    try {
      setValue(newValue);
    } catch (e) {
      setError(e instanceof Error ? e : new Error(String(e)));
    } finally {
      setLoading(false);
    }
  }, []);

  const derived = useMemo(() => ({
    hasValue: value !== null && value !== undefined,
    isLoading: loading,
    hasError: error !== null,
  }), [value, loading, error]);

  useEffect(() => {
    // Cleanup on unmount
    return () => {
      setLoading(false);
    };
  }, []);

  return { value, loading, error, reset, update, derived };
}
`;
}

/**
 * Generate a noise type file (no gql).
 */
function generateNoiseType(index: number): string {
  return `// Auto-generated noise types (no gql)

export interface Entity${index}Data {
  id: string;
  name: string;
  value: number;
  metadata: Record<string, unknown>;
}

export type Entity${index}Status = "active" | "inactive" | "pending";

export interface Entity${index}Config {
  enabled: boolean;
  timeout: number;
  retries: number;
  options: Entity${index}Options;
}

export interface Entity${index}Options {
  verbose: boolean;
  strict: boolean;
  cache: boolean;
}

export type Entity${index}Handler = (data: Entity${index}Data) => Promise<void>;

export function isEntity${index}Data(value: unknown): value is Entity${index}Data {
  return (
    typeof value === "object" &&
    value !== null &&
    "id" in value &&
    "name" in value &&
    "value" in value
  );
}
`;
}

/**
 * Generate all fixtures for a given configuration.
 */
export async function generateFixtures(config: FixtureConfig): Promise<void> {
  const fixturesDir = path.join(import.meta.dirname, "..", "fixtures", config.name);

  // Clean and create directories
  await fs.rm(fixturesDir, { recursive: true, force: true });
  await fs.mkdir(fixturesDir, { recursive: true });
  await fs.mkdir(path.join(fixturesDir, "src", "entities"), { recursive: true });
  await fs.mkdir(path.join(fixturesDir, "src", "pages"), { recursive: true });
  await fs.mkdir(path.join(fixturesDir, "src", "components"), { recursive: true });
  await fs.mkdir(path.join(fixturesDir, "src", "utils"), { recursive: true });
  await fs.mkdir(path.join(fixturesDir, "src", "hooks"), { recursive: true });
  await fs.mkdir(path.join(fixturesDir, "src", "types"), { recursive: true });

  // Calculate file distribution
  const gqlFileCount = Math.floor(config.totalFiles * config.gqlRatio);
  const noiseFileCount = config.totalFiles - gqlFileCount;

  // Distribute gql files among models, slices, and operations
  // Each model/slice file contains one definition, operations file contains one operation
  const modelFiles = config.models;
  const sliceFiles = config.slices;
  const operationFiles = config.operations;

  // Distribute noise files among components, utils, hooks, types
  const noisePerCategory = Math.floor(noiseFileCount / 4);
  const componentCount = noisePerCategory;
  const utilCount = noisePerCategory;
  const hookCount = noisePerCategory;
  const typeCount = noiseFileCount - componentCount - utilCount - hookCount;

  console.log(`Generating fixtures for "${config.name}"...`);
  console.log(`  Total files: ${config.totalFiles}`);
  console.log(`  GQL files: ${gqlFileCount} (${(config.gqlRatio * 100).toFixed(0)}%)`);
  console.log(`  Noise files: ${noiseFileCount}`);

  // Generate schema
  await fs.writeFile(path.join(fixturesDir, "schema.graphql"), generateSchema(config));
  console.log("  Generated: schema.graphql");

  // Generate graphql-inject.ts
  await fs.writeFile(path.join(fixturesDir, "graphql-inject.ts"), generateGraphqlInject());
  console.log("  Generated: graphql-inject.ts");

  // Generate config
  await fs.writeFile(path.join(fixturesDir, "soda-gql.config.ts"), generateConfig());
  console.log("  Generated: soda-gql.config.ts");

  // Generate model files
  const modelsContent: string[] = [];
  for (let i = 0; i < modelFiles; i++) {
    const entityIndex = i % config.objectTypes;
    await fs.writeFile(
      path.join(fixturesDir, "src", "entities", `model${i}.ts`),
      generateModelFile(i, entityIndex)
    );
    modelsContent.push(`export { model${i} } from "./model${i}";`);
  }
  await fs.writeFile(
    path.join(fixturesDir, "src", "entities", "models.ts"),
    `// Auto-generated model index\n${modelsContent.join("\n")}\n`
  );
  console.log(`  Generated: ${modelFiles} model files`);

  // Generate slice files
  const slicesContent: string[] = [];
  for (let i = 0; i < sliceFiles; i++) {
    const entityIndex = i % config.objectTypes;
    await fs.writeFile(
      path.join(fixturesDir, "src", "entities", `slice${i}.ts`),
      generateSliceFile(i, entityIndex)
    );
    slicesContent.push(`export { slice${i} } from "./slice${i}";`);
  }
  await fs.writeFile(
    path.join(fixturesDir, "src", "entities", "slices.ts"),
    `// Auto-generated slice index\n${slicesContent.join("\n")}\n`
  );
  console.log(`  Generated: ${sliceFiles} slice files`);

  // Generate operation files
  for (let i = 0; i < operationFiles; i++) {
    await fs.writeFile(
      path.join(fixturesDir, "src", "pages", `operation${i}.ts`),
      generateOperationFile(i, sliceFiles)
    );
  }
  console.log(`  Generated: ${operationFiles} operation files`);

  // Generate noise files
  for (let i = 0; i < componentCount; i++) {
    await fs.writeFile(
      path.join(fixturesDir, "src", "components", `Component${i}.ts`),
      generateNoiseComponent(i)
    );
  }
  console.log(`  Generated: ${componentCount} component files`);

  for (let i = 0; i < utilCount; i++) {
    await fs.writeFile(
      path.join(fixturesDir, "src", "utils", `util${i}.ts`),
      generateNoiseUtil(i)
    );
  }
  console.log(`  Generated: ${utilCount} util files`);

  for (let i = 0; i < hookCount; i++) {
    await fs.writeFile(
      path.join(fixturesDir, "src", "hooks", `useHook${i}.ts`),
      generateNoiseHook(i)
    );
  }
  console.log(`  Generated: ${hookCount} hook files`);

  for (let i = 0; i < typeCount; i++) {
    await fs.writeFile(
      path.join(fixturesDir, "src", "types", `types${i}.ts`),
      generateNoiseType(i)
    );
  }
  console.log(`  Generated: ${typeCount} type files`);

  console.log(`\nFixtures generated successfully at: ${fixturesDir}`);
}

// CLI entry point
if (import.meta.main) {
  const args = process.argv.slice(2);

  // Parse fixture name or use default
  let fixtureName = "small";
  const fixtureIndex = args.indexOf("--fixture");
  const fixtureArg = args[fixtureIndex + 1];
  if (fixtureIndex !== -1 && fixtureArg) {
    fixtureName = fixtureArg;
  }

  // Get base config from preset or create default
  const preset = FIXTURE_PRESETS[fixtureName];
  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
  const baseConfig: FixtureConfig = preset ?? FIXTURE_PRESETS.small!;
  const config: FixtureConfig = {
    name: preset ? baseConfig.name : fixtureName,
    totalFiles: baseConfig.totalFiles,
    gqlRatio: baseConfig.gqlRatio,
    objectTypes: baseConfig.objectTypes,
    models: baseConfig.models,
    slices: baseConfig.slices,
    operations: baseConfig.operations,
  };

  // Parse custom options
  const parseArg = (name: string): number | undefined => {
    const index = args.indexOf(`--${name}`);
    const argValue = args[index + 1];
    if (index !== -1 && argValue) {
      const value = parseFloat(argValue);
      return isNaN(value) ? undefined : value;
    }
    return undefined;
  };

  config.totalFiles = parseArg("total-files") ?? config.totalFiles;
  config.gqlRatio = parseArg("gql-ratio") ?? config.gqlRatio;
  config.objectTypes = parseArg("object-types") ?? config.objectTypes;
  config.models = parseArg("models") ?? config.models;
  config.slices = parseArg("slices") ?? config.slices;
  config.operations = parseArg("operations") ?? config.operations;

  await generateFixtures(config);
}

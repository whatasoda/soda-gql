#!/usr/bin/env bun
import * as fs from "node:fs/promises";
import * as path from "node:path";
import type { FixtureScale } from "./process-results";

export interface FixtureConfig extends FixtureScale {
  name: string;
}

/**
 * Predefined fixture scales.
 */
export const FIXTURE_PRESETS: Record<string, FixtureConfig> = {
  small: {
    name: "small",
    totalFiles: 50,
    gqlRatio: 0.2,
    objectTypes: 10,
    models: 5,
    slices: 5,
    operations: 5,
  },
  medium: {
    name: "medium",
    totalFiles: 200,
    gqlRatio: 0.15,
    objectTypes: 30,
    models: 15,
    slices: 15,
    operations: 15,
  },
  large: {
    name: "large",
    totalFiles: 500,
    gqlRatio: 0.12,
    objectTypes: 60,
    models: 30,
    slices: 30,
    operations: 30,
  },
  xlarge: {
    name: "xlarge",
    totalFiles: 1000,
    gqlRatio: 0.1,
    objectTypes: 100,
    models: 50,
    slices: 50,
    operations: 50,
  },
};

/**
 * Generate GraphQL schema SDL.
 */
function generateSchema(config: FixtureConfig): string {
  const lines: string[] = [
    "# Auto-generated schema for builder runtime benchmarking",
    "# DO NOT EDIT - this file is generated by generate-fixtures.ts",
    "",
  ];

  // Scalar definitions
  lines.push("scalar DateTime");
  lines.push("");

  // Query type
  lines.push("type Query {");
  for (let i = 0; i < config.objectTypes; i++) {
    lines.push(`  entity${i}(id: ID!): Entity${i}`);
    lines.push(`  entity${i}List(limit: Int, offset: Int): [Entity${i}!]!`);
  }
  lines.push("}");
  lines.push("");

  // Mutation type
  lines.push("type Mutation {");
  for (let i = 0; i < config.objectTypes; i++) {
    lines.push(`  createEntity${i}(name: String!, value: Int): Entity${i}!`);
    lines.push(`  updateEntity${i}(id: ID!, name: String): Entity${i}`);
    lines.push(`  deleteEntity${i}(id: ID!): Boolean!`);
  }
  lines.push("}");
  lines.push("");

  // Object types with varied field complexity
  for (let i = 0; i < config.objectTypes; i++) {
    const relatedIndex = (i + 1) % config.objectTypes;
    lines.push(`type Entity${i} {`);
    lines.push("  id: ID!");
    lines.push("  name: String!");
    lines.push("  description: String");
    lines.push("  value: Int");
    lines.push("  score: Float");
    lines.push("  isActive: Boolean!");
    lines.push("  createdAt: DateTime!");
    lines.push("  updatedAt: DateTime");
    lines.push(`  related: Entity${relatedIndex}`);
    lines.push(`  relatedList(limit: Int): [Entity${relatedIndex}!]!`);
    lines.push("}");
    lines.push("");
  }

  return lines.join("\n");
}

/**
 * Generate graphql-inject.ts with scalars, helpers, and metadata for inject config.
 */
function generateGraphqlInject(): string {
  return `// Auto-generated graphql-inject for builder runtime benchmarking
// DO NOT EDIT - this file is generated by generate-fixtures.ts

import { defineAdapter, defineScalar } from "@soda-gql/core/adapter";

export const scalar = {
  ...defineScalar<"ID", string, string>("ID"),
  ...defineScalar<"String", string, string>("String"),
  ...defineScalar<"Int", number, number>("Int"),
  ...defineScalar<"Float", number, number>("Float"),
  ...defineScalar<"Boolean", boolean, boolean>("Boolean"),
  ...defineScalar<"DateTime", string, Date>("DateTime"),
} as const;

export const adapter = defineAdapter({
  helpers: {},
  metadata: {
    aggregateFragmentMetadata: (fragments) => fragments.map((m) => m.metadata),
  },
});
`;
}

/**
 * Generate soda-gql.config.ts.
 */
function generateConfig(): string {
  return `// Auto-generated config for builder runtime benchmarking
// DO NOT EDIT - this file is generated by generate-fixtures.ts

import { defineConfig } from "@soda-gql/config";

export default defineConfig({
  outdir: "graphql-system",
  include: ["src/**/*.ts"],
  exclude: ["src/**/*.test.ts", "src/**/*.spec.ts"],
  schemas: {
    default: {
      schema: "./schema.graphql",
      inject: "./graphql-inject.ts",
    },
  },
});
`;
}

/**
 * Generate a model file (using fragment).
 */
function generateModelFile(index: number, entityIndex: number): string {
  return `// Auto-generated model for builder runtime benchmarking
import { gql } from "../../graphql-system";

export const model${index} = gql.default(({ fragment }) =>
  fragment.Entity${entityIndex}({
    fields: ({ f }) => ({
      ...f.id(),
      ...f.name(),
      ...f.description(),
      ...f.value(),
      ...f.isActive(),
      ...f.createdAt(),
      ...f.related()(({ f }) => ({
        ...f.id(),
        ...f.name(),
        ...f.value(),
      })),
      ...f.relatedList({ limit: 5 })(({ f }) => ({
        ...f.id(),
        ...f.name(),
      })),
    }),
  }),
);
`;
}

/**
 * Generate an operation file (simple query operation).
 */
function generateQueryOperationFile(index: number, entityIndex: number): string {
  const entityName = `entity${entityIndex}`;
  const isListQuery = index % 2 !== 0;

  if (isListQuery) {
    return `// Auto-generated query operation for builder runtime benchmarking
import { gql } from "../../graphql-system";

export const query${index} = gql.default(({ query, $var }) =>
  query.operation({
    name: "Query${index}",
    variables: { ...$var("limit").Int("?"), ...$var("offset").Int("?") },
    fields: ({ f, $ }) => ({
      ...f.${entityName}List({ limit: $.limit, offset: $.offset })(({ f }) => ({
        ...f.id(),
        ...f.name(),
        ...f.description(),
        ...f.value(),
        ...f.isActive(),
      })),
    }),
  }),
);
`;
  }

  return `// Auto-generated query operation for builder runtime benchmarking
import { gql } from "../../graphql-system";

export const query${index} = gql.default(({ query, $var }) =>
  query.operation({
    name: "Query${index}",
    variables: { ...$var("id").ID("!") },
    fields: ({ f, $ }) => ({
      ...f.${entityName}({ id: $.id })(({ f }) => ({
        ...f.id(),
        ...f.name(),
        ...f.description(),
        ...f.value(),
        ...f.isActive(),
      })),
    }),
  }),
);
`;
}

/**
 * Generate an operation file that uses model spreading.
 */
function generateOperationWithModelsFile(index: number, modelCount: number): string {
  const modelsPerOp = Math.min(3, modelCount);
  const modelImports: string[] = [];
  const modelSpreads: string[] = [];

  for (let j = 0; j < modelsPerOp; j++) {
    const modelIndex = (index * modelsPerOp + j) % modelCount;
    modelImports.push(`model${modelIndex}`);
    modelSpreads.push(`        ...model${modelIndex}.spread(),`);
  }

  // Generate individual imports for each model (from ../entities/ since operations are in src/pages/)
  const individualImports = modelImports.map((m) => `import { ${m} } from "../entities/${m}";`).join("\n");
  const entityIndex = index % 10; // Use modulo to cycle through entity types

  return `// Auto-generated operation for builder runtime benchmarking
import { gql } from "../../graphql-system";
${individualImports}

export const operation${index} = gql.default(({ query, $var }) =>
  query.operation({
    name: "Operation${index}",
    variables: { ...$var("id").ID("!") },
    fields: ({ f, $ }) => ({
      ...f.entity${entityIndex}({ id: $.id })(({ f }) => ({
${modelSpreads.join("\n")}
      })),
    }),
  }),
);
`;
}

/**
 * Generate a noise component file (no gql).
 */
function generateNoiseComponent(index: number): string {
  return `// Auto-generated noise component (no gql)
import { useState, useCallback } from "react";

interface Props {
  title: string;
  onAction?: () => void;
}

export function Component${index}({ title, onAction }: Props) {
  const [count, setCount] = useState(0);

  const handleClick = useCallback(() => {
    setCount((c) => c + 1);
    onAction?.();
  }, [onAction]);

  return {
    title,
    count,
    handleClick,
  };
}

export function useComponent${index}Logic() {
  const [state, setState] = useState<Record<string, unknown>>({});

  return {
    state,
    setState,
    reset: () => setState({}),
  };
}
`;
}

/**
 * Generate a noise utility file (no gql).
 */
function generateNoiseUtil(index: number): string {
  return `// Auto-generated noise utility (no gql)

export function formatValue${index}(value: unknown): string {
  if (value === null || value === undefined) return "";
  if (typeof value === "string") return value;
  if (typeof value === "number") return value.toLocaleString();
  return JSON.stringify(value);
}

export function parseValue${index}(input: string): unknown {
  try {
    return JSON.parse(input);
  } catch {
    return input;
  }
}

export function validateInput${index}(input: unknown): boolean {
  return input !== null && input !== undefined;
}

export const CONSTANTS_${index} = {
  MAX_LENGTH: 100,
  MIN_LENGTH: 1,
  DEFAULT_VALUE: "default",
} as const;
`;
}

/**
 * Generate a noise hook file (no gql).
 */
function generateNoiseHook(index: number): string {
  return `// Auto-generated noise hook (no gql)
import { useState, useEffect, useCallback, useMemo } from "react";

export function useHook${index}<T>(initialValue: T) {
  const [value, setValue] = useState<T>(initialValue);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<Error | null>(null);

  const reset = useCallback(() => {
    setValue(initialValue);
    setLoading(false);
    setError(null);
  }, [initialValue]);

  const update = useCallback((newValue: T) => {
    setLoading(true);
    try {
      setValue(newValue);
    } catch (e) {
      setError(e instanceof Error ? e : new Error(String(e)));
    } finally {
      setLoading(false);
    }
  }, []);

  const derived = useMemo(() => ({
    hasValue: value !== null && value !== undefined,
    isLoading: loading,
    hasError: error !== null,
  }), [value, loading, error]);

  useEffect(() => {
    // Cleanup on unmount
    return () => {
      setLoading(false);
    };
  }, []);

  return { value, loading, error, reset, update, derived };
}
`;
}

/**
 * Generate a noise type file (no gql).
 */
function generateNoiseType(index: number): string {
  return `// Auto-generated noise types (no gql)

export interface Entity${index}Data {
  id: string;
  name: string;
  value: number;
  metadata: Record<string, unknown>;
}

export type Entity${index}Status = "active" | "inactive" | "pending";

export interface Entity${index}Config {
  enabled: boolean;
  timeout: number;
  retries: number;
  options: Entity${index}Options;
}

export interface Entity${index}Options {
  verbose: boolean;
  strict: boolean;
  cache: boolean;
}

export type Entity${index}Handler = (data: Entity${index}Data) => Promise<void>;

export function isEntity${index}Data(value: unknown): value is Entity${index}Data {
  return (
    typeof value === "object" &&
    value !== null &&
    "id" in value &&
    "name" in value &&
    "value" in value
  );
}
`;
}

/**
 * Generate all fixtures for a given configuration.
 */
export async function generateFixtures(config: FixtureConfig): Promise<void> {
  const fixturesDir = path.join(import.meta.dirname, "..", "fixtures", config.name);

  // Clean and create directories
  await fs.rm(fixturesDir, { recursive: true, force: true });
  await fs.mkdir(fixturesDir, { recursive: true });
  await fs.mkdir(path.join(fixturesDir, "src", "entities"), { recursive: true });
  await fs.mkdir(path.join(fixturesDir, "src", "pages"), { recursive: true });
  await fs.mkdir(path.join(fixturesDir, "src", "components"), { recursive: true });
  await fs.mkdir(path.join(fixturesDir, "src", "utils"), { recursive: true });
  await fs.mkdir(path.join(fixturesDir, "src", "hooks"), { recursive: true });
  await fs.mkdir(path.join(fixturesDir, "src", "types"), { recursive: true });

  // Calculate file distribution
  const gqlFileCount = Math.floor(config.totalFiles * config.gqlRatio);
  const noiseFileCount = config.totalFiles - gqlFileCount;

  // Distribute gql files among models, slices, and operations
  // Each model/slice file contains one definition, operations file contains one operation
  const modelFiles = config.models;
  const sliceFiles = config.slices;
  const operationFiles = config.operations;

  // Distribute noise files among components, utils, hooks, types
  const noisePerCategory = Math.floor(noiseFileCount / 4);
  const componentCount = noisePerCategory;
  const utilCount = noisePerCategory;
  const hookCount = noisePerCategory;
  const typeCount = noiseFileCount - componentCount - utilCount - hookCount;

  console.log(`Generating fixtures for "${config.name}"...`);
  console.log(`  Total files: ${config.totalFiles}`);
  console.log(`  GQL files: ${gqlFileCount} (${(config.gqlRatio * 100).toFixed(0)}%)`);
  console.log(`  Noise files: ${noiseFileCount}`);

  // Generate schema
  await fs.writeFile(path.join(fixturesDir, "schema.graphql"), generateSchema(config));
  console.log("  Generated: schema.graphql");

  // Generate graphql-inject.ts
  await fs.writeFile(path.join(fixturesDir, "graphql-inject.ts"), generateGraphqlInject());
  console.log("  Generated: graphql-inject.ts");

  // Generate config
  await fs.writeFile(path.join(fixturesDir, "soda-gql.config.ts"), generateConfig());
  console.log("  Generated: soda-gql.config.ts");

  // Generate model files
  const modelsContent: string[] = [];
  for (let i = 0; i < modelFiles; i++) {
    const entityIndex = i % config.objectTypes;
    await fs.writeFile(
      path.join(fixturesDir, "src", "entities", `model${i}.ts`),
      generateModelFile(i, entityIndex)
    );
    modelsContent.push(`export { model${i} } from "./model${i}";`);
  }
  await fs.writeFile(
    path.join(fixturesDir, "src", "entities", "models.ts"),
    `// Auto-generated model index\n${modelsContent.join("\n")}\n`
  );
  console.log(`  Generated: ${modelFiles} model files`);

  // Generate query operation files (replacing slices)
  const queriesContent: string[] = [];
  for (let i = 0; i < sliceFiles; i++) {
    const entityIndex = i % config.objectTypes;
    await fs.writeFile(
      path.join(fixturesDir, "src", "entities", `query${i}.ts`),
      generateQueryOperationFile(i, entityIndex)
    );
    queriesContent.push(`export { query${i} } from "./query${i}";`);
  }
  await fs.writeFile(
    path.join(fixturesDir, "src", "entities", "queries.ts"),
    `// Auto-generated query index\n${queriesContent.join("\n")}\n`
  );
  console.log(`  Generated: ${sliceFiles} query operation files`);

  // Generate operation files with model spreading
  for (let i = 0; i < operationFiles; i++) {
    await fs.writeFile(
      path.join(fixturesDir, "src", "pages", `operation${i}.ts`),
      generateOperationWithModelsFile(i, modelFiles)
    );
  }
  console.log(`  Generated: ${operationFiles} operation files`);

  // Generate noise files
  for (let i = 0; i < componentCount; i++) {
    await fs.writeFile(
      path.join(fixturesDir, "src", "components", `Component${i}.ts`),
      generateNoiseComponent(i)
    );
  }
  console.log(`  Generated: ${componentCount} component files`);

  for (let i = 0; i < utilCount; i++) {
    await fs.writeFile(
      path.join(fixturesDir, "src", "utils", `util${i}.ts`),
      generateNoiseUtil(i)
    );
  }
  console.log(`  Generated: ${utilCount} util files`);

  for (let i = 0; i < hookCount; i++) {
    await fs.writeFile(
      path.join(fixturesDir, "src", "hooks", `useHook${i}.ts`),
      generateNoiseHook(i)
    );
  }
  console.log(`  Generated: ${hookCount} hook files`);

  for (let i = 0; i < typeCount; i++) {
    await fs.writeFile(
      path.join(fixturesDir, "src", "types", `types${i}.ts`),
      generateNoiseType(i)
    );
  }
  console.log(`  Generated: ${typeCount} type files`);

  console.log(`\nFixtures generated successfully at: ${fixturesDir}`);
}

// CLI entry point
if (import.meta.main) {
  const args = process.argv.slice(2);

  // Parse fixture name or use default
  let fixtureName = "small";
  const fixtureIndex = args.indexOf("--fixture");
  const fixtureArg = args[fixtureIndex + 1];
  if (fixtureIndex !== -1 && fixtureArg) {
    fixtureName = fixtureArg;
  }

  // Get base config from preset or create default
  const preset = FIXTURE_PRESETS[fixtureName];
  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
  const baseConfig: FixtureConfig = preset ?? FIXTURE_PRESETS.small!;
  const config: FixtureConfig = {
    name: preset ? baseConfig.name : fixtureName,
    totalFiles: baseConfig.totalFiles,
    gqlRatio: baseConfig.gqlRatio,
    objectTypes: baseConfig.objectTypes,
    models: baseConfig.models,
    slices: baseConfig.slices,
    operations: baseConfig.operations,
  };

  // Parse custom options
  const parseArg = (name: string): number | undefined => {
    const index = args.indexOf(`--${name}`);
    const argValue = args[index + 1];
    if (index !== -1 && argValue) {
      const value = parseFloat(argValue);
      return isNaN(value) ? undefined : value;
    }
    return undefined;
  };

  config.totalFiles = parseArg("total-files") ?? config.totalFiles;
  config.gqlRatio = parseArg("gql-ratio") ?? config.gqlRatio;
  config.objectTypes = parseArg("object-types") ?? config.objectTypes;
  config.models = parseArg("models") ?? config.models;
  config.slices = parseArg("slices") ?? config.slices;
  config.operations = parseArg("operations") ?? config.operations;

  await generateFixtures(config);
}

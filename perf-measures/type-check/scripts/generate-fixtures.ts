#!/usr/bin/env bun
import * as fs from "node:fs/promises";
import * as path from "node:path";

interface FixtureConfig {
  objectTypes: number;
  models: number;
  slices: number;
  operations: number;
}

const DEFAULT_CONFIG: FixtureConfig = {
  objectTypes: 10,
  models: 10,
  slices: 8,
  operations: 5,
};

function generateSchema(config: FixtureConfig): string {
  const objectTypes: string[] = [];

  // Query type with fields for each object type
  const queryFields: string[] = [];
  for (let i = 0; i < config.objectTypes; i++) {
    const typeName = `Entity${i}`;
    queryFields.push(`      ${typeName.toLowerCase()}: unsafeOutputType.object("${typeName}:?", { arguments: {
        id: unsafeInputType.scalar("ID:!", { default: null, directives: {} }),
      } }),`);
    queryFields.push(`      ${typeName.toLowerCase()}List: unsafeOutputType.object("${typeName}:![]!", { arguments: {
        limit: unsafeInputType.scalar("Int:?", { default: null, directives: {} }),
        offset: unsafeInputType.scalar("Int:?", { default: null, directives: {} }),
      } }),`);
  }

  // Mutation type with create/update/delete for each object type
  const mutationFields: string[] = [];
  for (let i = 0; i < config.objectTypes; i++) {
    const typeName = `Entity${i}`;
    mutationFields.push(`      create${typeName}: unsafeOutputType.object("${typeName}:!", { arguments: {
        name: unsafeInputType.scalar("String:!", { default: null, directives: {} }),
        value: unsafeInputType.scalar("Int:?", { default: null, directives: {} }),
      } }),`);
    mutationFields.push(`      update${typeName}: unsafeOutputType.object("${typeName}:?", { arguments: {
        id: unsafeInputType.scalar("ID:!", { default: null, directives: {} }),
        name: unsafeInputType.scalar("String:?", { default: null, directives: {} }),
      } }),`);
    mutationFields.push(`      delete${typeName}: unsafeOutputType.scalar("Boolean:!", { arguments: {
        id: unsafeInputType.scalar("ID:!", { default: null, directives: {} }),
      } }),`);
  }

  // Object types with varied field complexity
  for (let i = 0; i < config.objectTypes; i++) {
    const typeName = `Entity${i}`;
    const relatedType = `Entity${(i + 1) % config.objectTypes}`;

    objectTypes.push(`    ${typeName}: define("${typeName}").object({
      id: unsafeOutputType.scalar("ID:!", { arguments: {} }),
      name: unsafeOutputType.scalar("String:!", { arguments: {} }),
      description: unsafeOutputType.scalar("String:?", { arguments: {} }),
      value: unsafeOutputType.scalar("Int:?", { arguments: {} }),
      score: unsafeOutputType.scalar("Float:?", { arguments: {} }),
      isActive: unsafeOutputType.scalar("Boolean:!", { arguments: {} }),
      createdAt: unsafeOutputType.scalar("String:!", { arguments: {} }),
      updatedAt: unsafeOutputType.scalar("String:?", { arguments: {} }),
      related: unsafeOutputType.object("${relatedType}:?", { arguments: {} }),
      relatedList: unsafeOutputType.object("${relatedType}:![]!", { arguments: {
        limit: unsafeInputType.scalar("Int:?", { default: null, directives: {} }),
      } }),
    }),`);
  }

  return `// Auto-generated schema for type-check benchmarking
// DO NOT EDIT - this file is generated by generate-fixtures.ts

import {
  type AnyGraphqlSchema,
  createGqlElementComposer,
  define,
  defineOperationRoots,
  defineScalar,
  unsafeInputType,
  unsafeOutputType,
} from "@soda-gql/core";
import { createRuntimeAdapter } from "@soda-gql/core/runtime";

const scalars = {
  ...defineScalar<"ID", string, string>("ID"),
  ...defineScalar<"String", string, string>("String"),
  ...defineScalar<"Int", number, number>("Int"),
  ...defineScalar<"Float", number, number>("Float"),
  ...defineScalar<"Boolean", boolean, boolean>("Boolean"),
} as const;

const adapter = createRuntimeAdapter(({ type }) => ({
  nonGraphqlErrorType: type<{ type: "non-graphql-error"; cause: unknown }>(),
}));

const schema = {
  label: "benchmark" as const,
  operations: defineOperationRoots({
    query: "Query",
    mutation: "Mutation",
    subscription: null,
  }),
  scalar: scalars,
  enum: {},
  input: {},
  object: {
    Query: define("Query").object({
${queryFields.join("\n")}
    }),
    Mutation: define("Mutation").object({
${mutationFields.join("\n")}
    }),
${objectTypes.join("\n")}
  },
  union: {},
} satisfies AnyGraphqlSchema;

export type Schema = typeof schema & { _?: never };
export type Adapter = typeof adapter & { _?: never };

export const gql = {
  default: createGqlElementComposer<Schema, Adapter>(schema),
};

export { schema };
`;
}

function generateModels(config: FixtureConfig): string {
  const models: string[] = [];

  for (let i = 0; i < config.models; i++) {
    const entityIndex = i % config.objectTypes;
    const typeName = `Entity${entityIndex}`;

    models.push(`
// Model ${i}: ${typeName} with nested selection
export const model${i} = gql.default(({ model }) =>
  model.${typeName}(
    {},
    ({ f }) => [
      f.id(),
      f.name(),
      f.description(),
      f.value(),
      f.isActive(),
      f.createdAt(),
      f.related()(({ f }) => [
        f.id(),
        f.name(),
        f.value(),
      ]),
      f.relatedList({ limit: 5 })(({ f }) => [
        f.id(),
        f.name(),
      ]),
    ],
    (selection) => ({
      id: selection.id,
      name: selection.name,
      description: selection.description,
      value: selection.value,
      isActive: selection.isActive,
      createdAt: selection.createdAt,
      related: selection.related,
      relatedList: selection.relatedList,
    }),
  ),
);`);
  }

  return `// Auto-generated models for type-check benchmarking
// DO NOT EDIT - this file is generated by generate-fixtures.ts

import { gql } from "./schema";
${models.join("\n")}
`;
}

function generateSlices(config: FixtureConfig): string {
  const slices: string[] = [];

  for (let i = 0; i < config.slices; i++) {
    const entityIndex = i % config.objectTypes;
    const typeName = `Entity${entityIndex}`;

    // Alternate between single entity and list queries
    if (i % 2 === 0) {
      slices.push(`
// Slice ${i}: Get single ${typeName} by ID
export const slice${i} = gql.default(({ query }, { $var }) =>
  query.slice(
    {
      variables: [$var("id").scalar("ID:!")],
    },
    ({ f, $ }) => [
      f.${typeName.toLowerCase()}({ id: $.id })(({ f }) => [
        f.id(),
        f.name(),
        f.description(),
        f.value(),
        f.isActive(),
      ]),
    ],
    ({ select }) => select(["$.${typeName.toLowerCase()}"], (result) =>
      result.safeUnwrap((data) => data)
    ),
  ),
);`);
    } else {
      slices.push(`
// Slice ${i}: Get list of ${typeName}
export const slice${i} = gql.default(({ query }, { $var }) =>
  query.slice(
    {
      variables: [$var("limit").scalar("Int:?"), $var("offset").scalar("Int:?")],
    },
    ({ f, $ }) => [
      f.${typeName.toLowerCase()}List({ limit: $.limit, offset: $.offset })(({ f }) => [
        f.id(),
        f.name(),
        f.description(),
        f.value(),
        f.isActive(),
      ]),
    ],
    ({ select }) => select(["$.${typeName.toLowerCase()}List"], (result) => result),
  ),
);`);
    }
  }

  return `// Auto-generated slices for type-check benchmarking
// DO NOT EDIT - this file is generated by generate-fixtures.ts

import { gql } from "./schema";
${slices.join("\n")}
`;
}

function generateOperations(config: FixtureConfig): string {
  const operations: string[] = [];

  for (let i = 0; i < config.operations; i++) {
    // Compose multiple slices per operation
    const sliceCount = Math.min(3, config.slices);
    const sliceEmbeds: string[] = [];
    const sliceVars: string[] = [];

    for (let j = 0; j < sliceCount; j++) {
      const sliceIndex = (i * sliceCount + j) % config.slices;
      const isListSlice = sliceIndex % 2 !== 0;

      if (isListSlice) {
        sliceEmbeds.push(`        result${j}: slice${sliceIndex}.embed({ limit: $.limit${j}, offset: $.offset${j} }),`);
        sliceVars.push(`$var("limit${j}").scalar("Int:?")`);
        sliceVars.push(`$var("offset${j}").scalar("Int:?")`);
      } else {
        sliceEmbeds.push(`        result${j}: slice${sliceIndex}.embed({ id: $.id${j} }),`);
        sliceVars.push(`$var("id${j}").scalar("ID:!")`);
      }
    }

    operations.push(`
// Operation ${i}: Composed operation with ${sliceCount} slices
export const operation${i} = gql.default(({ query }, { $var }) =>
  query.composed(
    {
      name: "Operation${i}",
      variables: [${sliceVars.join(", ")}],
    },
    ({ $ }) => ({
${sliceEmbeds.join("\n")}
    }),
  ),
);`);
  }

  // Add import for slices
  const sliceImports = Array.from({ length: config.slices }, (_, i) => `slice${i}`).join(", ");

  return `// Auto-generated operations for type-check benchmarking
// DO NOT EDIT - this file is generated by generate-fixtures.ts

import { gql } from "./schema";
import { ${sliceImports} } from "./slices";
${operations.join("\n")}
`;
}

export async function generateFixtures(config: FixtureConfig = DEFAULT_CONFIG): Promise<void> {
  const generatedDir = path.join(import.meta.dirname, "..", "generated");

  await fs.mkdir(generatedDir, { recursive: true });

  const files = [
    { name: "schema.ts", content: generateSchema(config) },
    { name: "models.ts", content: generateModels(config) },
    { name: "slices.ts", content: generateSlices(config) },
    { name: "operations.ts", content: generateOperations(config) },
  ];

  for (const file of files) {
    await fs.writeFile(path.join(generatedDir, file.name), file.content, "utf-8");
    console.log(`Generated: ${file.name}`);
  }

  console.log(`\nFixtures generated with config:`);
  console.log(`  Object types: ${config.objectTypes}`);
  console.log(`  Models: ${config.models}`);
  console.log(`  Slices: ${config.slices}`);
  console.log(`  Operations: ${config.operations}`);
}

// CLI entry point
if (import.meta.main) {
  const args = process.argv.slice(2);
  const config: FixtureConfig = { ...DEFAULT_CONFIG };

  for (let i = 0; i < args.length; i += 2) {
    const key = args[i]?.replace("--", "");
    const value = parseInt(args[i + 1] ?? "", 10);
    if (key && !isNaN(value) && key in config) {
      (config as unknown as Record<string, number>)[key] = value;
    }
  }

  generateFixtures(config).catch(console.error);
}

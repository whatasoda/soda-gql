#!/usr/bin/env bun
import * as fs from "node:fs/promises";
import * as path from "node:path";

interface FixtureConfig {
  objectTypes: number;
  models: number;
  slices: number;
  operations: number;
}

const DEFAULT_CONFIG: FixtureConfig = {
  objectTypes: 10,
  models: 10,
  slices: 8,
  operations: 5,
};

function generateSchema(config: FixtureConfig): string {
  // Generate split object definitions using plain object literals with as const
  const objectDefinitions: string[] = [];

  // Query object definition - using direct object literal without function calls
  const queryFields: string[] = [];
  for (let i = 0; i < config.objectTypes; i++) {
    const typeName = `Entity${i}`;
    queryFields.push(`    ${typeName.toLowerCase()}: { kind: "object", name: "${typeName}", modifier: "?", arguments: {
      id: { kind: "scalar", name: "ID", modifier: "!", defaultValue: null, directives: {} },
    } },`);
    queryFields.push(`    ${typeName.toLowerCase()}List: { kind: "object", name: "${typeName}", modifier: "![]!", arguments: {
      limit: { kind: "scalar", name: "Int", modifier: "?", defaultValue: null, directives: {} },
      offset: { kind: "scalar", name: "Int", modifier: "?", defaultValue: null, directives: {} },
    } },`);
  }
  objectDefinitions.push(`const Query = {
  name: "Query",
  fields: {
${queryFields.join("\n")}
  },
} as const;`);

  // Mutation object definition
  const mutationFields: string[] = [];
  for (let i = 0; i < config.objectTypes; i++) {
    const typeName = `Entity${i}`;
    mutationFields.push(`    create${typeName}: { kind: "object", name: "${typeName}", modifier: "!", arguments: {
      name: { kind: "scalar", name: "String", modifier: "!", defaultValue: null, directives: {} },
      value: { kind: "scalar", name: "Int", modifier: "?", defaultValue: null, directives: {} },
    } },`);
    mutationFields.push(`    update${typeName}: { kind: "object", name: "${typeName}", modifier: "?", arguments: {
      id: { kind: "scalar", name: "ID", modifier: "!", defaultValue: null, directives: {} },
      name: { kind: "scalar", name: "String", modifier: "?", defaultValue: null, directives: {} },
    } },`);
    mutationFields.push(`    delete${typeName}: { kind: "scalar", name: "Boolean", modifier: "!", arguments: {
      id: { kind: "scalar", name: "ID", modifier: "!", defaultValue: null, directives: {} },
    } },`);
  }
  objectDefinitions.push(`const Mutation = {
  name: "Mutation",
  fields: {
${mutationFields.join("\n")}
  },
} as const;`);

  // Entity object definitions
  for (let i = 0; i < config.objectTypes; i++) {
    const typeName = `Entity${i}`;
    const relatedType = `Entity${(i + 1) % config.objectTypes}`;

    objectDefinitions.push(`const ${typeName} = {
  name: "${typeName}",
  fields: {
    id: { kind: "scalar", name: "ID", modifier: "!", arguments: {} },
    name: { kind: "scalar", name: "String", modifier: "!", arguments: {} },
    description: { kind: "scalar", name: "String", modifier: "?", arguments: {} },
    value: { kind: "scalar", name: "Int", modifier: "?", arguments: {} },
    score: { kind: "scalar", name: "Float", modifier: "?", arguments: {} },
    isActive: { kind: "scalar", name: "Boolean", modifier: "!", arguments: {} },
    createdAt: { kind: "scalar", name: "String", modifier: "!", arguments: {} },
    updatedAt: { kind: "scalar", name: "String", modifier: "?", arguments: {} },
    related: { kind: "object", name: "${relatedType}", modifier: "?", arguments: {} },
    relatedList: { kind: "object", name: "${relatedType}", modifier: "![]!", arguments: {
      limit: { kind: "scalar", name: "Int", modifier: "?", defaultValue: null, directives: {} },
    } },
  },
} as const;`);
  }

  // Object references for schema composition
  const objectRefs = ["Query", "Mutation"];
  for (let i = 0; i < config.objectTypes; i++) {
    objectRefs.push(`Entity${i}`);
  }
  const objectComposition = objectRefs.map((name) => `    ${name},`).join("\n");

  // Generate FragmentBuilders type entries with adapter type for metadata propagation
  const fragmentBuilderEntries = objectRefs.map(
    (name) => `  readonly ${name}: FragmentBuilderFor<Schema, "${name}", ExtractMetadataAdapter<Adapter>>;`
  ).join("\n");

  return `// Auto-generated schema for type-check benchmarking
// DO NOT EDIT - this file is generated by generate-fixtures.ts

import { createGqlElementComposer, createVarMethodFactory, type ExtractMetadataAdapter, type FragmentBuilderFor, type InputTypeMethods } from "@soda-gql/core";
import { defineAdapter, defineScalar } from "@soda-gql/core/adapter";

const scalars = {
  ...defineScalar<"ID", string, string>("ID"),
  ...defineScalar<"String", string, string>("String"),
  ...defineScalar<"Int", number, number>("Int"),
  ...defineScalar<"Float", number, number>("Float"),
  ...defineScalar<"Boolean", boolean, boolean>("Boolean"),
} as const;

const adapter = defineAdapter({
  helpers: {},
  metadata: {
    aggregateFragmentMetadata: (fragments) => fragments.map((m) => m.metadata),
  },
});

// Split object definitions with as const assertions
${objectDefinitions.join("\n\n")}

// Compose schema with as const
const schema = {
  label: "benchmark",
  operations: { query: "Query", mutation: "Mutation", subscription: null },
  scalar: scalars,
  enum: {},
  input: {},
  object: {
${objectComposition}
  },
  union: {},
} as const;

export type Schema = typeof schema & { _?: never };
export type Adapter = typeof adapter & { _?: never };

// Pre-generated fragment builder type for optimization
type FragmentBuilders = {
${fragmentBuilderEntries}
};

const createMethod = createVarMethodFactory<Schema>();
const inputTypeMethods = {
  ID: createMethod("scalar", "ID"),
  String: createMethod("scalar", "String"),
  Int: createMethod("scalar", "Int"),
  Float: createMethod("scalar", "Float"),
  Boolean: createMethod("scalar", "Boolean"),
} satisfies InputTypeMethods<Schema>;

export const gql = {
  default: createGqlElementComposer<Schema, FragmentBuilders, Adapter>(schema, { adapter, inputTypeMethods }),
};

export { schema };
`;
}

function generateModels(config: FixtureConfig): string {
  const models: string[] = [];

  for (let i = 0; i < config.models; i++) {
    const entityIndex = i % config.objectTypes;
    const typeName = `Entity${entityIndex}`;

    models.push(`
// Model ${i}: ${typeName} with nested selection
export const model${i} = gql.default(({ model }) =>
  model.${typeName}(
    {},
    ({ f }) => ({
      ...f.id(),
      ...f.name(),
      ...f.description(),
      ...f.value(),
      ...f.isActive(),
      ...f.createdAt(),
      ...f.related()(({ f }) => ({
        ...f.id(),
        ...f.name(),
        ...f.value(),
      })),
      ...f.relatedList({ limit: 5 })(({ f }) => ({
        ...f.id(),
        ...f.name(),
      })),
    }),
    (selection) => ({
      id: selection.id,
      name: selection.name,
      description: selection.description,
      value: selection.value,
      isActive: selection.isActive,
      createdAt: selection.createdAt,
      related: selection.related,
      relatedList: selection.relatedList,
    }),
  ),
);`);
  }

  return `// Auto-generated models for type-check benchmarking
// DO NOT EDIT - this file is generated by generate-fixtures.ts

import { gql } from "./schema";
${models.join("\n")}
`;
}

function generateSlices(config: FixtureConfig): string {
  const slices: string[] = [];

  for (let i = 0; i < config.slices; i++) {
    const entityIndex = i % config.objectTypes;
    const typeName = `Entity${entityIndex}`;

    // Alternate between single entity and list queries
    if (i % 2 === 0) {
      slices.push(`
// Slice ${i}: Get single ${typeName} by ID
export const slice${i} = gql.default(({ query, $var }) =>
  query.slice(
    {
      variables: { ...$var("id").ID("!") },
    },
    ({ f, $ }) => ({
      ...f.${typeName.toLowerCase()}({ id: $.id })(({ f }) => ({
        ...f.id(),
        ...f.name(),
        ...f.description(),
        ...f.value(),
        ...f.isActive(),
      })),
    }),
    ({ select }) => select(["$.${typeName.toLowerCase()}"], (result) =>
      result.safeUnwrap((data) => data)
    ),
  ),
);`);
    } else {
      slices.push(`
// Slice ${i}: Get list of ${typeName}
export const slice${i} = gql.default(({ query, $var }) =>
  query.slice(
    {
      variables: { ...$var("limit").Int("?"), ...$var("offset").Int("?") },
    },
    ({ f, $ }) => ({
      ...f.${typeName.toLowerCase()}List({ limit: $.limit, offset: $.offset })(({ f }) => ({
        ...f.id(),
        ...f.name(),
        ...f.description(),
        ...f.value(),
        ...f.isActive(),
      })),
    }),
    ({ select }) => select(["$.${typeName.toLowerCase()}List"], (result) => result),
  ),
);`);
    }
  }

  return `// Auto-generated slices for type-check benchmarking
// DO NOT EDIT - this file is generated by generate-fixtures.ts

import { gql } from "./schema";
${slices.join("\n")}
`;
}

function generateOperations(config: FixtureConfig): string {
  const operations: string[] = [];

  for (let i = 0; i < config.operations; i++) {
    // Compose multiple slices per operation
    const sliceCount = Math.min(3, config.slices);
    const sliceSpreads: string[] = [];
    const sliceVars: string[] = [];

    for (let j = 0; j < sliceCount; j++) {
      const sliceIndex = (i * sliceCount + j) % config.slices;
      const isListSlice = sliceIndex % 2 !== 0;

      if (isListSlice) {
        sliceSpreads.push(`        result${j}: slice${sliceIndex}.spread({ limit: $.limit${j}, offset: $.offset${j} }),`);
        sliceVars.push(`...$var("limit${j}").Int("?")`);
        sliceVars.push(`...$var("offset${j}").Int("?")`);
      } else {
        sliceSpreads.push(`        result${j}: slice${sliceIndex}.spread({ id: $.id${j} }),`);
        sliceVars.push(`...$var("id${j}").ID("!")`);
      }
    }

    operations.push(`
// Operation ${i}: Composed operation with ${sliceCount} slices
export const operation${i} = gql.default(({ query, $var }) =>
  query.composed(
    {
      name: "Operation${i}",
      variables: { ${sliceVars.join(", ")} },
    },
    ({ $ }) => ({
${sliceSpreads.join("\n")}
    }),
  ),
);`);
  }

  // Add import for slices
  const sliceImports = Array.from({ length: config.slices }, (_, i) => `slice${i}`).join(", ");

  return `// Auto-generated operations for type-check benchmarking
// DO NOT EDIT - this file is generated by generate-fixtures.ts

import { gql } from "./schema";
import { ${sliceImports} } from "./slices";
${operations.join("\n")}
`;
}

export async function generateFixtures(config: FixtureConfig = DEFAULT_CONFIG): Promise<void> {
  const generatedDir = path.join(import.meta.dirname, "..", "generated");

  await fs.mkdir(generatedDir, { recursive: true });

  const files = [
    { name: "schema.ts", content: generateSchema(config) },
    { name: "models.ts", content: generateModels(config) },
    { name: "slices.ts", content: generateSlices(config) },
    { name: "operations.ts", content: generateOperations(config) },
  ];

  for (const file of files) {
    await fs.writeFile(path.join(generatedDir, file.name), file.content, "utf-8");
    console.log(`Generated: ${file.name}`);
  }

  console.log(`\nFixtures generated with config:`);
  console.log(`  Object types: ${config.objectTypes}`);
  console.log(`  Models: ${config.models}`);
  console.log(`  Slices: ${config.slices}`);
  console.log(`  Operations: ${config.operations}`);
}

// CLI entry point
if (import.meta.main) {
  const args = process.argv.slice(2);
  const config: FixtureConfig = { ...DEFAULT_CONFIG };

  for (let i = 0; i < args.length; i += 2) {
    const key = args[i]?.replace("--", "");
    const value = parseInt(args[i + 1] ?? "", 10);
    if (key && !isNaN(value) && key in config) {
      (config as unknown as Record<string, number>)[key] = value;
    }
  }

  generateFixtures(config).catch(console.error);
}

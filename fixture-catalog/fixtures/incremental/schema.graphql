schema {
  query: Query
  mutation: Mutation
  subscription: Subscription
}

# ============================================================================
# Custom Scalars
# ============================================================================

scalar DateTime
scalar JSON
scalar BigInt

# ============================================================================
# Interfaces
# ============================================================================

interface Node {
  id: ID!
}

interface Timestamped {
  createdAt: DateTime!
  updatedAt: DateTime
}

# ============================================================================
# Enums
# ============================================================================

enum ProjectStatus {
  PLANNING
  IN_PROGRESS
  ON_HOLD
  COMPLETED
  CANCELLED
}

enum EmployeeRole {
  ENGINEER
  MANAGER
  DIRECTOR
  EXECUTIVE
  INTERN
}

enum TaskPriority {
  LOW
  MEDIUM
  HIGH
  URGENT
}

enum SortOrder {
  ASC
  DESC
}

# ============================================================================
# Object Types (5-level deep nesting)
# ============================================================================

# Level 1: Company (root entity)
type Company implements Node & Timestamped {
  id: ID!
  name: String!
  industry: String
  createdAt: DateTime!
  updatedAt: DateTime
  departments: [Department!]!
  employees(role: EmployeeRole, limit: Int): [Employee!]!
}

# Level 2: Department
type Department implements Node & Timestamped {
  id: ID!
  name: String!
  budget: BigInt
  createdAt: DateTime!
  updatedAt: DateTime
  company: Company!
  teams: [Team!]!
  manager: Employee
}

# Level 3: Team
type Team implements Node {
  id: ID!
  name: String!
  department: Department!
  members(limit: Int): [Employee!]!
  lead: Employee
  projects(status: ProjectStatus, limit: Int): [Project!]!
}

# Level 4: Project
type Project implements Node & Timestamped {
  id: ID!
  title: String!
  description: String
  status: ProjectStatus!
  priority: Int
  metadata: JSON
  createdAt: DateTime!
  updatedAt: DateTime
  team: Team!
  tasks(completed: Boolean, limit: Int): [Task!]!
  assignees: [Employee!]!
}

# Level 5: Task
type Task implements Node & Timestamped {
  id: ID!
  title: String!
  completed: Boolean!
  priority: TaskPriority
  dueDate: DateTime
  estimatedHours: Float
  createdAt: DateTime!
  updatedAt: DateTime
  project: Project!
  assignee: Employee
  comments(limit: Int): [Comment!]!
}

# Employee with recursive relations (manager/reports)
type Employee implements Node & Timestamped {
  id: ID!
  name: String!
  email: String!
  role: EmployeeRole!
  salary: BigInt
  createdAt: DateTime!
  updatedAt: DateTime
  department: Department
  team: Team
  manager: Employee
  reports(limit: Int): [Employee!]!
  tasks(completed: Boolean, limit: Int): [Task!]!
  comments: [Comment!]!
}

# Comment with recursive relations (parent/replies)
type Comment implements Node & Timestamped {
  id: ID!
  body: String!
  createdAt: DateTime!
  updatedAt: DateTime
  author: Employee!
  task: Task
  parent: Comment
  replies(limit: Int): [Comment!]!
}

# ============================================================================
# Union Types
# ============================================================================

union SearchResult = Employee | Project | Task | Comment
union ActivityItem = Task | Comment | Project

# ============================================================================
# Input Types - Filters
# ============================================================================

input StringFilter {
  _eq: String
  _neq: String
  _contains: String
  _startsWith: String
  _endsWith: String
  _in: [String!]
  _nin: [String!]
}

input IntFilter {
  _eq: Int
  _neq: Int
  _gt: Int
  _gte: Int
  _lt: Int
  _lte: Int
  _in: [Int!]
  _nin: [Int!]
}

input BigIntFilter {
  _eq: BigInt
  _neq: BigInt
  _gt: BigInt
  _gte: BigInt
  _lt: BigInt
  _lte: BigInt
}

input DateTimeFilter {
  _eq: DateTime
  _neq: DateTime
  _gt: DateTime
  _gte: DateTime
  _lt: DateTime
  _lte: DateTime
}

input BooleanFilter {
  _eq: Boolean
}

input ProjectStatusFilter {
  _eq: ProjectStatus
  _neq: ProjectStatus
  _in: [ProjectStatus!]
  _nin: [ProjectStatus!]
}

input EmployeeRoleFilter {
  _eq: EmployeeRole
  _neq: EmployeeRole
  _in: [EmployeeRole!]
  _nin: [EmployeeRole!]
}

input TaskPriorityFilter {
  _eq: TaskPriority
  _neq: TaskPriority
  _in: [TaskPriority!]
  _nin: [TaskPriority!]
}

# Complex filter inputs with nesting and logical operators
input ProjectFilterInput {
  title: StringFilter
  status: ProjectStatusFilter
  priority: IntFilter
  createdAt: DateTimeFilter
  team: TeamFilterInput
  _and: [ProjectFilterInput!]
  _or: [ProjectFilterInput!]
  _not: ProjectFilterInput
}

input TeamFilterInput {
  name: StringFilter
  department: DepartmentFilterInput
}

input DepartmentFilterInput {
  name: StringFilter
  budget: BigIntFilter
}

input EmployeeFilterInput {
  name: StringFilter
  email: StringFilter
  role: EmployeeRoleFilter
  department: DepartmentFilterInput
  _and: [EmployeeFilterInput!]
  _or: [EmployeeFilterInput!]
  _not: EmployeeFilterInput
}

input TaskFilterInput {
  title: StringFilter
  completed: BooleanFilter
  priority: TaskPriorityFilter
  dueDate: DateTimeFilter
  project: ProjectFilterInput
  _and: [TaskFilterInput!]
  _or: [TaskFilterInput!]
  _not: TaskFilterInput
}

# ============================================================================
# Input Types - Mutations
# ============================================================================

input CreateProjectInput {
  title: String!
  description: String
  status: ProjectStatus
  priority: Int
  metadata: JSON
  teamId: ID!
  tasks: [CreateTaskInput!]
  assigneeIds: [ID!]
}

input UpdateProjectInput {
  title: String
  description: String
  status: ProjectStatus
  priority: Int
  metadata: JSON
}

input CreateTaskInput {
  title: String!
  priority: TaskPriority
  dueDate: DateTime
  estimatedHours: Float
  assigneeId: ID
}

input UpdateTaskInput {
  title: String
  completed: Boolean
  priority: TaskPriority
  dueDate: DateTime
  estimatedHours: Float
  assigneeId: ID
}

input TransferEmployeeInput {
  employeeId: ID!
  departmentId: ID!
  teamId: ID
  newRole: EmployeeRole
}

# Pagination and sorting
input PaginationInput {
  limit: Int
  offset: Int
  cursor: ID
}

input SortInput {
  field: String!
  order: SortOrder
}

# ============================================================================
# Query Type
# ============================================================================

type Query {
  # Single entity lookups (Node interface pattern)
  node(id: ID!): Node
  company(id: ID!): Company
  department(id: ID!): Department
  team(id: ID!): Team
  project(id: ID!): Project
  task(id: ID!): Task
  employee(id: ID!): Employee
  comment(id: ID!): Comment

  # List queries with filters
  companies(limit: Int, offset: Int): [Company!]!
  departments(companyId: ID, limit: Int): [Department!]!
  teams(departmentId: ID, limit: Int): [Team!]!
  projects(filter: ProjectFilterInput, sort: SortInput, pagination: PaginationInput): [Project!]!
  tasks(filter: TaskFilterInput, projectId: ID, assigneeId: ID, limit: Int): [Task!]!
  employees(filter: EmployeeFilterInput, departmentId: ID, teamId: ID, limit: Int): [Employee!]!

  # Union type queries
  search(query: String!, types: [String!], limit: Int): [SearchResult!]!
  activityFeed(userId: ID!, since: DateTime, limit: Int): [ActivityItem!]!
}

# ============================================================================
# Mutation Type
# ============================================================================

type Mutation {
  # Project CRUD with nested inputs
  createProject(input: CreateProjectInput!): Project!
  updateProject(id: ID!, input: UpdateProjectInput!): Project!
  deleteProject(id: ID!): Boolean!

  # Task mutations
  createTask(projectId: ID!, input: CreateTaskInput!): Task!
  updateTask(id: ID!, input: UpdateTaskInput!): Task!
  deleteTask(id: ID!): Boolean!

  # Employee mutations
  assignTask(taskId: ID!, employeeId: ID!): Task!
  unassignTask(taskId: ID!): Task!
  transferEmployee(input: TransferEmployeeInput!): Employee!

  # Comment mutations
  addComment(taskId: ID!, body: String!): Comment!
  replyToComment(parentId: ID!, body: String!): Comment!
  deleteComment(id: ID!): Boolean!
}

# ============================================================================
# Subscription Type
# ============================================================================

type Subscription {
  projectUpdated(projectId: ID!): Project!
  taskCreated(projectId: ID): Task!
  taskUpdated(taskId: ID!): Task!
  commentAdded(taskId: ID!): Comment!
  employeeActivity(employeeId: ID!): ActivityItem!
}

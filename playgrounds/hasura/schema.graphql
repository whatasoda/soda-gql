schema {
  query: query_root
  mutation: mutation_root
  subscription: subscription_root
}

"""whether this query should be cached (Hasura Cloud only)"""
directive @cached(
  """measured in seconds"""
  ttl: Int! = 60

  """refresh the cache entry"""
  refresh: Boolean! = false
) on QUERY

"""
Boolean expression to compare columns of type "Boolean". All fields are combined with logical 'AND'.
"""
input Boolean_comparison_exp {
  _eq: Boolean
  _gt: Boolean
  _gte: Boolean
  _in: [Boolean!]
  _is_null: Boolean
  _lt: Boolean
  _lte: Boolean
  _neq: Boolean
  _nin: [Boolean!]
}

"""
Boolean expression to compare columns of type "Int". All fields are combined with logical 'AND'.
"""
input Int_comparison_exp {
  _eq: Int
  _gt: Int
  _gte: Int
  _in: [Int!]
  _is_null: Boolean
  _lt: Int
  _lte: Int
  _neq: Int
  _nin: [Int!]
}

"""
Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'.
"""
input String_comparison_exp {
  _eq: String
  _gt: String
  _gte: String

  """does the column match the given case-insensitive pattern"""
  _ilike: String
  _in: [String!]

  """
  does the column match the given POSIX regular expression, case insensitive
  """
  _iregex: String
  _is_null: Boolean

  """does the column match the given pattern"""
  _like: String
  _lt: String
  _lte: String
  _neq: String

  """does the column NOT match the given case-insensitive pattern"""
  _nilike: String
  _nin: [String!]

  """
  does the column NOT match the given POSIX regular expression, case insensitive
  """
  _niregex: String

  """does the column NOT match the given pattern"""
  _nlike: String

  """
  does the column NOT match the given POSIX regular expression, case sensitive
  """
  _nregex: String

  """does the column NOT match the given SQL regular expression"""
  _nsimilar: String

  """
  does the column match the given POSIX regular expression, case sensitive
  """
  _regex: String

  """does the column match the given SQL regular expression"""
  _similar: String
}

"""
columns and relationships of "analytics_events"
"""
type analytics_events {
  created_at: timestamptz!
  deleted_at: timestamptz
  event_type: String!
  id: uuid!
  ip_address: String
  metadata(
    """JSON select path"""
    path: String
  ): jsonb
  page_path: String!
  referrer: String
  site_id: uuid
  updated_at: timestamptz!
  user_agent: String
}

"""
aggregated selection of "analytics_events"
"""
type analytics_events_aggregate {
  aggregate: analytics_events_aggregate_fields
  nodes: [analytics_events!]!
}

"""
aggregate fields of "analytics_events"
"""
type analytics_events_aggregate_fields {
  count(columns: [analytics_events_select_column!], distinct: Boolean): Int!
  max: analytics_events_max_fields
  min: analytics_events_min_fields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input analytics_events_append_input {
  metadata: jsonb
}

"""
Boolean expression to filter rows from the table "analytics_events". All fields are combined with a logical 'AND'.
"""
input analytics_events_bool_exp {
  _and: [analytics_events_bool_exp!]
  _not: analytics_events_bool_exp
  _or: [analytics_events_bool_exp!]
  created_at: timestamptz_comparison_exp
  deleted_at: timestamptz_comparison_exp
  event_type: String_comparison_exp
  id: uuid_comparison_exp
  ip_address: String_comparison_exp
  metadata: jsonb_comparison_exp
  page_path: String_comparison_exp
  referrer: String_comparison_exp
  site_id: uuid_comparison_exp
  updated_at: timestamptz_comparison_exp
  user_agent: String_comparison_exp
}

"""
unique or primary key constraints on table "analytics_events"
"""
enum analytics_events_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  analytics_events_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input analytics_events_delete_at_path_input {
  metadata: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input analytics_events_delete_elem_input {
  metadata: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input analytics_events_delete_key_input {
  metadata: String
}

"""
input type for inserting data into table "analytics_events"
"""
input analytics_events_insert_input {
  created_at: timestamptz
  deleted_at: timestamptz
  event_type: String
  id: uuid
  ip_address: String
  metadata: jsonb
  page_path: String
  referrer: String
  site_id: uuid
  updated_at: timestamptz
  user_agent: String
}

"""aggregate max on columns"""
type analytics_events_max_fields {
  created_at: timestamptz
  deleted_at: timestamptz
  event_type: String
  id: uuid
  ip_address: String
  page_path: String
  referrer: String
  site_id: uuid
  updated_at: timestamptz
  user_agent: String
}

"""aggregate min on columns"""
type analytics_events_min_fields {
  created_at: timestamptz
  deleted_at: timestamptz
  event_type: String
  id: uuid
  ip_address: String
  page_path: String
  referrer: String
  site_id: uuid
  updated_at: timestamptz
  user_agent: String
}

"""
response of any mutation on the table "analytics_events"
"""
type analytics_events_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [analytics_events!]!
}

"""
on_conflict condition type for table "analytics_events"
"""
input analytics_events_on_conflict {
  constraint: analytics_events_constraint!
  update_columns: [analytics_events_update_column!]! = []
  where: analytics_events_bool_exp
}

"""Ordering options when selecting data from "analytics_events"."""
input analytics_events_order_by {
  created_at: order_by
  deleted_at: order_by
  event_type: order_by
  id: order_by
  ip_address: order_by
  metadata: order_by
  page_path: order_by
  referrer: order_by
  site_id: order_by
  updated_at: order_by
  user_agent: order_by
}

"""primary key columns input for table: analytics_events"""
input analytics_events_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input analytics_events_prepend_input {
  metadata: jsonb
}

"""
select columns of table "analytics_events"
"""
enum analytics_events_select_column {
  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  event_type

  """column name"""
  id

  """column name"""
  ip_address

  """column name"""
  metadata

  """column name"""
  page_path

  """column name"""
  referrer

  """column name"""
  site_id

  """column name"""
  updated_at

  """column name"""
  user_agent
}

"""
input type for updating data in table "analytics_events"
"""
input analytics_events_set_input {
  created_at: timestamptz
  deleted_at: timestamptz
  event_type: String
  id: uuid
  ip_address: String
  metadata: jsonb
  page_path: String
  referrer: String
  site_id: uuid
  updated_at: timestamptz
  user_agent: String
}

"""
Streaming cursor of the table "analytics_events"
"""
input analytics_events_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: analytics_events_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input analytics_events_stream_cursor_value_input {
  created_at: timestamptz
  deleted_at: timestamptz
  event_type: String
  id: uuid
  ip_address: String
  metadata: jsonb
  page_path: String
  referrer: String
  site_id: uuid
  updated_at: timestamptz
  user_agent: String
}

"""
update columns of table "analytics_events"
"""
enum analytics_events_update_column {
  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  event_type

  """column name"""
  id

  """column name"""
  ip_address

  """column name"""
  metadata

  """column name"""
  page_path

  """column name"""
  referrer

  """column name"""
  site_id

  """column name"""
  updated_at

  """column name"""
  user_agent
}

input analytics_events_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: analytics_events_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: analytics_events_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: analytics_events_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: analytics_events_delete_key_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: analytics_events_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: analytics_events_set_input

  """filter the rows which have to be updated"""
  where: analytics_events_bool_exp!
}

"""
columns and relationships of "article_categories"
"""
type article_categories {
  created_at: timestamptz!
  deleted_at: timestamptz
  description: String
  id: uuid!
  name: String!
  parent_id: uuid
  site_id: uuid
  slug: String!
  sort_order: Int!
  updated_at: timestamptz!
}

"""
aggregated selection of "article_categories"
"""
type article_categories_aggregate {
  aggregate: article_categories_aggregate_fields
  nodes: [article_categories!]!
}

"""
aggregate fields of "article_categories"
"""
type article_categories_aggregate_fields {
  avg: article_categories_avg_fields
  count(columns: [article_categories_select_column!], distinct: Boolean): Int!
  max: article_categories_max_fields
  min: article_categories_min_fields
  stddev: article_categories_stddev_fields
  stddev_pop: article_categories_stddev_pop_fields
  stddev_samp: article_categories_stddev_samp_fields
  sum: article_categories_sum_fields
  var_pop: article_categories_var_pop_fields
  var_samp: article_categories_var_samp_fields
  variance: article_categories_variance_fields
}

"""aggregate avg on columns"""
type article_categories_avg_fields {
  sort_order: Float
}

"""
Boolean expression to filter rows from the table "article_categories". All fields are combined with a logical 'AND'.
"""
input article_categories_bool_exp {
  _and: [article_categories_bool_exp!]
  _not: article_categories_bool_exp
  _or: [article_categories_bool_exp!]
  created_at: timestamptz_comparison_exp
  deleted_at: timestamptz_comparison_exp
  description: String_comparison_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
  parent_id: uuid_comparison_exp
  site_id: uuid_comparison_exp
  slug: String_comparison_exp
  sort_order: Int_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "article_categories"
"""
enum article_categories_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  article_categories_pkey
}

"""
input type for incrementing numeric columns in table "article_categories"
"""
input article_categories_inc_input {
  sort_order: Int
}

"""
input type for inserting data into table "article_categories"
"""
input article_categories_insert_input {
  created_at: timestamptz
  deleted_at: timestamptz
  description: String
  id: uuid
  name: String
  parent_id: uuid
  site_id: uuid
  slug: String
  sort_order: Int
  updated_at: timestamptz
}

"""aggregate max on columns"""
type article_categories_max_fields {
  created_at: timestamptz
  deleted_at: timestamptz
  description: String
  id: uuid
  name: String
  parent_id: uuid
  site_id: uuid
  slug: String
  sort_order: Int
  updated_at: timestamptz
}

"""aggregate min on columns"""
type article_categories_min_fields {
  created_at: timestamptz
  deleted_at: timestamptz
  description: String
  id: uuid
  name: String
  parent_id: uuid
  site_id: uuid
  slug: String
  sort_order: Int
  updated_at: timestamptz
}

"""
response of any mutation on the table "article_categories"
"""
type article_categories_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [article_categories!]!
}

"""
on_conflict condition type for table "article_categories"
"""
input article_categories_on_conflict {
  constraint: article_categories_constraint!
  update_columns: [article_categories_update_column!]! = []
  where: article_categories_bool_exp
}

"""Ordering options when selecting data from "article_categories"."""
input article_categories_order_by {
  created_at: order_by
  deleted_at: order_by
  description: order_by
  id: order_by
  name: order_by
  parent_id: order_by
  site_id: order_by
  slug: order_by
  sort_order: order_by
  updated_at: order_by
}

"""primary key columns input for table: article_categories"""
input article_categories_pk_columns_input {
  id: uuid!
}

"""
select columns of table "article_categories"
"""
enum article_categories_select_column {
  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  description

  """column name"""
  id

  """column name"""
  name

  """column name"""
  parent_id

  """column name"""
  site_id

  """column name"""
  slug

  """column name"""
  sort_order

  """column name"""
  updated_at
}

"""
input type for updating data in table "article_categories"
"""
input article_categories_set_input {
  created_at: timestamptz
  deleted_at: timestamptz
  description: String
  id: uuid
  name: String
  parent_id: uuid
  site_id: uuid
  slug: String
  sort_order: Int
  updated_at: timestamptz
}

"""aggregate stddev on columns"""
type article_categories_stddev_fields {
  sort_order: Float
}

"""aggregate stddev_pop on columns"""
type article_categories_stddev_pop_fields {
  sort_order: Float
}

"""aggregate stddev_samp on columns"""
type article_categories_stddev_samp_fields {
  sort_order: Float
}

"""
Streaming cursor of the table "article_categories"
"""
input article_categories_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: article_categories_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input article_categories_stream_cursor_value_input {
  created_at: timestamptz
  deleted_at: timestamptz
  description: String
  id: uuid
  name: String
  parent_id: uuid
  site_id: uuid
  slug: String
  sort_order: Int
  updated_at: timestamptz
}

"""aggregate sum on columns"""
type article_categories_sum_fields {
  sort_order: Int
}

"""
update columns of table "article_categories"
"""
enum article_categories_update_column {
  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  description

  """column name"""
  id

  """column name"""
  name

  """column name"""
  parent_id

  """column name"""
  site_id

  """column name"""
  slug

  """column name"""
  sort_order

  """column name"""
  updated_at
}

input article_categories_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: article_categories_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: article_categories_set_input

  """filter the rows which have to be updated"""
  where: article_categories_bool_exp!
}

"""aggregate var_pop on columns"""
type article_categories_var_pop_fields {
  sort_order: Float
}

"""aggregate var_samp on columns"""
type article_categories_var_samp_fields {
  sort_order: Float
}

"""aggregate variance on columns"""
type article_categories_variance_fields {
  sort_order: Float
}

"""
columns and relationships of "article_category_assignments"
"""
type article_category_assignments {
  article_id: uuid
  category_id: uuid
  created_at: timestamptz!
  deleted_at: timestamptz
  id: uuid!
  updated_at: timestamptz!
}

"""
aggregated selection of "article_category_assignments"
"""
type article_category_assignments_aggregate {
  aggregate: article_category_assignments_aggregate_fields
  nodes: [article_category_assignments!]!
}

"""
aggregate fields of "article_category_assignments"
"""
type article_category_assignments_aggregate_fields {
  count(columns: [article_category_assignments_select_column!], distinct: Boolean): Int!
  max: article_category_assignments_max_fields
  min: article_category_assignments_min_fields
}

"""
Boolean expression to filter rows from the table "article_category_assignments". All fields are combined with a logical 'AND'.
"""
input article_category_assignments_bool_exp {
  _and: [article_category_assignments_bool_exp!]
  _not: article_category_assignments_bool_exp
  _or: [article_category_assignments_bool_exp!]
  article_id: uuid_comparison_exp
  category_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  deleted_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "article_category_assignments"
"""
enum article_category_assignments_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  article_category_assignments_pkey
}

"""
input type for inserting data into table "article_category_assignments"
"""
input article_category_assignments_insert_input {
  article_id: uuid
  category_id: uuid
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  updated_at: timestamptz
}

"""aggregate max on columns"""
type article_category_assignments_max_fields {
  article_id: uuid
  category_id: uuid
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  updated_at: timestamptz
}

"""aggregate min on columns"""
type article_category_assignments_min_fields {
  article_id: uuid
  category_id: uuid
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  updated_at: timestamptz
}

"""
response of any mutation on the table "article_category_assignments"
"""
type article_category_assignments_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [article_category_assignments!]!
}

"""
on_conflict condition type for table "article_category_assignments"
"""
input article_category_assignments_on_conflict {
  constraint: article_category_assignments_constraint!
  update_columns: [article_category_assignments_update_column!]! = []
  where: article_category_assignments_bool_exp
}

"""
Ordering options when selecting data from "article_category_assignments".
"""
input article_category_assignments_order_by {
  article_id: order_by
  category_id: order_by
  created_at: order_by
  deleted_at: order_by
  id: order_by
  updated_at: order_by
}

"""primary key columns input for table: article_category_assignments"""
input article_category_assignments_pk_columns_input {
  id: uuid!
}

"""
select columns of table "article_category_assignments"
"""
enum article_category_assignments_select_column {
  """column name"""
  article_id

  """column name"""
  category_id

  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  updated_at
}

"""
input type for updating data in table "article_category_assignments"
"""
input article_category_assignments_set_input {
  article_id: uuid
  category_id: uuid
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  updated_at: timestamptz
}

"""
Streaming cursor of the table "article_category_assignments"
"""
input article_category_assignments_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: article_category_assignments_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input article_category_assignments_stream_cursor_value_input {
  article_id: uuid
  category_id: uuid
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  updated_at: timestamptz
}

"""
update columns of table "article_category_assignments"
"""
enum article_category_assignments_update_column {
  """column name"""
  article_id

  """column name"""
  category_id

  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  updated_at
}

input article_category_assignments_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: article_category_assignments_set_input

  """filter the rows which have to be updated"""
  where: article_category_assignments_bool_exp!
}

"""
columns and relationships of "article_tags"
"""
type article_tags {
  article_id: uuid
  created_at: timestamptz!
  deleted_at: timestamptz
  id: uuid!
  tag_id: uuid
  updated_at: timestamptz!
}

"""
aggregated selection of "article_tags"
"""
type article_tags_aggregate {
  aggregate: article_tags_aggregate_fields
  nodes: [article_tags!]!
}

"""
aggregate fields of "article_tags"
"""
type article_tags_aggregate_fields {
  count(columns: [article_tags_select_column!], distinct: Boolean): Int!
  max: article_tags_max_fields
  min: article_tags_min_fields
}

"""
Boolean expression to filter rows from the table "article_tags". All fields are combined with a logical 'AND'.
"""
input article_tags_bool_exp {
  _and: [article_tags_bool_exp!]
  _not: article_tags_bool_exp
  _or: [article_tags_bool_exp!]
  article_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  deleted_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  tag_id: uuid_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "article_tags"
"""
enum article_tags_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  article_tags_pkey
}

"""
input type for inserting data into table "article_tags"
"""
input article_tags_insert_input {
  article_id: uuid
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  tag_id: uuid
  updated_at: timestamptz
}

"""aggregate max on columns"""
type article_tags_max_fields {
  article_id: uuid
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  tag_id: uuid
  updated_at: timestamptz
}

"""aggregate min on columns"""
type article_tags_min_fields {
  article_id: uuid
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  tag_id: uuid
  updated_at: timestamptz
}

"""
response of any mutation on the table "article_tags"
"""
type article_tags_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [article_tags!]!
}

"""
on_conflict condition type for table "article_tags"
"""
input article_tags_on_conflict {
  constraint: article_tags_constraint!
  update_columns: [article_tags_update_column!]! = []
  where: article_tags_bool_exp
}

"""Ordering options when selecting data from "article_tags"."""
input article_tags_order_by {
  article_id: order_by
  created_at: order_by
  deleted_at: order_by
  id: order_by
  tag_id: order_by
  updated_at: order_by
}

"""primary key columns input for table: article_tags"""
input article_tags_pk_columns_input {
  id: uuid!
}

"""
select columns of table "article_tags"
"""
enum article_tags_select_column {
  """column name"""
  article_id

  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  tag_id

  """column name"""
  updated_at
}

"""
input type for updating data in table "article_tags"
"""
input article_tags_set_input {
  article_id: uuid
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  tag_id: uuid
  updated_at: timestamptz
}

"""
Streaming cursor of the table "article_tags"
"""
input article_tags_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: article_tags_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input article_tags_stream_cursor_value_input {
  article_id: uuid
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  tag_id: uuid
  updated_at: timestamptz
}

"""
update columns of table "article_tags"
"""
enum article_tags_update_column {
  """column name"""
  article_id

  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  tag_id

  """column name"""
  updated_at
}

input article_tags_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: article_tags_set_input

  """filter the rows which have to be updated"""
  where: article_tags_bool_exp!
}

"""
columns and relationships of "articles"
"""
type articles {
  author_id: uuid
  content: String!
  created_at: timestamptz!
  deleted_at: timestamptz
  excerpt: String
  featured_image_url: String
  id: uuid!
  is_featured: Boolean!
  is_published: Boolean!
  published_at: timestamptz
  site_id: uuid
  slug: String!
  title: String!
  updated_at: timestamptz!
  view_count: bigint!
}

"""
aggregated selection of "articles"
"""
type articles_aggregate {
  aggregate: articles_aggregate_fields
  nodes: [articles!]!
}

"""
aggregate fields of "articles"
"""
type articles_aggregate_fields {
  avg: articles_avg_fields
  count(columns: [articles_select_column!], distinct: Boolean): Int!
  max: articles_max_fields
  min: articles_min_fields
  stddev: articles_stddev_fields
  stddev_pop: articles_stddev_pop_fields
  stddev_samp: articles_stddev_samp_fields
  sum: articles_sum_fields
  var_pop: articles_var_pop_fields
  var_samp: articles_var_samp_fields
  variance: articles_variance_fields
}

"""aggregate avg on columns"""
type articles_avg_fields {
  view_count: Float
}

"""
Boolean expression to filter rows from the table "articles". All fields are combined with a logical 'AND'.
"""
input articles_bool_exp {
  _and: [articles_bool_exp!]
  _not: articles_bool_exp
  _or: [articles_bool_exp!]
  author_id: uuid_comparison_exp
  content: String_comparison_exp
  created_at: timestamptz_comparison_exp
  deleted_at: timestamptz_comparison_exp
  excerpt: String_comparison_exp
  featured_image_url: String_comparison_exp
  id: uuid_comparison_exp
  is_featured: Boolean_comparison_exp
  is_published: Boolean_comparison_exp
  published_at: timestamptz_comparison_exp
  site_id: uuid_comparison_exp
  slug: String_comparison_exp
  title: String_comparison_exp
  updated_at: timestamptz_comparison_exp
  view_count: bigint_comparison_exp
}

"""
unique or primary key constraints on table "articles"
"""
enum articles_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  articles_pkey
}

"""
input type for incrementing numeric columns in table "articles"
"""
input articles_inc_input {
  view_count: bigint
}

"""
input type for inserting data into table "articles"
"""
input articles_insert_input {
  author_id: uuid
  content: String
  created_at: timestamptz
  deleted_at: timestamptz
  excerpt: String
  featured_image_url: String
  id: uuid
  is_featured: Boolean
  is_published: Boolean
  published_at: timestamptz
  site_id: uuid
  slug: String
  title: String
  updated_at: timestamptz
  view_count: bigint
}

"""aggregate max on columns"""
type articles_max_fields {
  author_id: uuid
  content: String
  created_at: timestamptz
  deleted_at: timestamptz
  excerpt: String
  featured_image_url: String
  id: uuid
  published_at: timestamptz
  site_id: uuid
  slug: String
  title: String
  updated_at: timestamptz
  view_count: bigint
}

"""aggregate min on columns"""
type articles_min_fields {
  author_id: uuid
  content: String
  created_at: timestamptz
  deleted_at: timestamptz
  excerpt: String
  featured_image_url: String
  id: uuid
  published_at: timestamptz
  site_id: uuid
  slug: String
  title: String
  updated_at: timestamptz
  view_count: bigint
}

"""
response of any mutation on the table "articles"
"""
type articles_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [articles!]!
}

"""
on_conflict condition type for table "articles"
"""
input articles_on_conflict {
  constraint: articles_constraint!
  update_columns: [articles_update_column!]! = []
  where: articles_bool_exp
}

"""Ordering options when selecting data from "articles"."""
input articles_order_by {
  author_id: order_by
  content: order_by
  created_at: order_by
  deleted_at: order_by
  excerpt: order_by
  featured_image_url: order_by
  id: order_by
  is_featured: order_by
  is_published: order_by
  published_at: order_by
  site_id: order_by
  slug: order_by
  title: order_by
  updated_at: order_by
  view_count: order_by
}

"""primary key columns input for table: articles"""
input articles_pk_columns_input {
  id: uuid!
}

"""
select columns of table "articles"
"""
enum articles_select_column {
  """column name"""
  author_id

  """column name"""
  content

  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  excerpt

  """column name"""
  featured_image_url

  """column name"""
  id

  """column name"""
  is_featured

  """column name"""
  is_published

  """column name"""
  published_at

  """column name"""
  site_id

  """column name"""
  slug

  """column name"""
  title

  """column name"""
  updated_at

  """column name"""
  view_count
}

"""
input type for updating data in table "articles"
"""
input articles_set_input {
  author_id: uuid
  content: String
  created_at: timestamptz
  deleted_at: timestamptz
  excerpt: String
  featured_image_url: String
  id: uuid
  is_featured: Boolean
  is_published: Boolean
  published_at: timestamptz
  site_id: uuid
  slug: String
  title: String
  updated_at: timestamptz
  view_count: bigint
}

"""aggregate stddev on columns"""
type articles_stddev_fields {
  view_count: Float
}

"""aggregate stddev_pop on columns"""
type articles_stddev_pop_fields {
  view_count: Float
}

"""aggregate stddev_samp on columns"""
type articles_stddev_samp_fields {
  view_count: Float
}

"""
Streaming cursor of the table "articles"
"""
input articles_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: articles_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input articles_stream_cursor_value_input {
  author_id: uuid
  content: String
  created_at: timestamptz
  deleted_at: timestamptz
  excerpt: String
  featured_image_url: String
  id: uuid
  is_featured: Boolean
  is_published: Boolean
  published_at: timestamptz
  site_id: uuid
  slug: String
  title: String
  updated_at: timestamptz
  view_count: bigint
}

"""aggregate sum on columns"""
type articles_sum_fields {
  view_count: bigint
}

"""
update columns of table "articles"
"""
enum articles_update_column {
  """column name"""
  author_id

  """column name"""
  content

  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  excerpt

  """column name"""
  featured_image_url

  """column name"""
  id

  """column name"""
  is_featured

  """column name"""
  is_published

  """column name"""
  published_at

  """column name"""
  site_id

  """column name"""
  slug

  """column name"""
  title

  """column name"""
  updated_at

  """column name"""
  view_count
}

input articles_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: articles_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: articles_set_input

  """filter the rows which have to be updated"""
  where: articles_bool_exp!
}

"""aggregate var_pop on columns"""
type articles_var_pop_fields {
  view_count: Float
}

"""aggregate var_samp on columns"""
type articles_var_samp_fields {
  view_count: Float
}

"""aggregate variance on columns"""
type articles_variance_fields {
  view_count: Float
}

"""
columns and relationships of "author_articles"
"""
type author_articles {
  article_id: uuid
  author_id: uuid
  created_at: timestamptz!
  deleted_at: timestamptz
  id: uuid!
  is_primary: Boolean!
  updated_at: timestamptz!
}

"""
aggregated selection of "author_articles"
"""
type author_articles_aggregate {
  aggregate: author_articles_aggregate_fields
  nodes: [author_articles!]!
}

"""
aggregate fields of "author_articles"
"""
type author_articles_aggregate_fields {
  count(columns: [author_articles_select_column!], distinct: Boolean): Int!
  max: author_articles_max_fields
  min: author_articles_min_fields
}

"""
Boolean expression to filter rows from the table "author_articles". All fields are combined with a logical 'AND'.
"""
input author_articles_bool_exp {
  _and: [author_articles_bool_exp!]
  _not: author_articles_bool_exp
  _or: [author_articles_bool_exp!]
  article_id: uuid_comparison_exp
  author_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  deleted_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  is_primary: Boolean_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "author_articles"
"""
enum author_articles_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  author_articles_pkey
}

"""
input type for inserting data into table "author_articles"
"""
input author_articles_insert_input {
  article_id: uuid
  author_id: uuid
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  is_primary: Boolean
  updated_at: timestamptz
}

"""aggregate max on columns"""
type author_articles_max_fields {
  article_id: uuid
  author_id: uuid
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  updated_at: timestamptz
}

"""aggregate min on columns"""
type author_articles_min_fields {
  article_id: uuid
  author_id: uuid
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  updated_at: timestamptz
}

"""
response of any mutation on the table "author_articles"
"""
type author_articles_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [author_articles!]!
}

"""
on_conflict condition type for table "author_articles"
"""
input author_articles_on_conflict {
  constraint: author_articles_constraint!
  update_columns: [author_articles_update_column!]! = []
  where: author_articles_bool_exp
}

"""Ordering options when selecting data from "author_articles"."""
input author_articles_order_by {
  article_id: order_by
  author_id: order_by
  created_at: order_by
  deleted_at: order_by
  id: order_by
  is_primary: order_by
  updated_at: order_by
}

"""primary key columns input for table: author_articles"""
input author_articles_pk_columns_input {
  id: uuid!
}

"""
select columns of table "author_articles"
"""
enum author_articles_select_column {
  """column name"""
  article_id

  """column name"""
  author_id

  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  is_primary

  """column name"""
  updated_at
}

"""
input type for updating data in table "author_articles"
"""
input author_articles_set_input {
  article_id: uuid
  author_id: uuid
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  is_primary: Boolean
  updated_at: timestamptz
}

"""
Streaming cursor of the table "author_articles"
"""
input author_articles_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: author_articles_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input author_articles_stream_cursor_value_input {
  article_id: uuid
  author_id: uuid
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  is_primary: Boolean
  updated_at: timestamptz
}

"""
update columns of table "author_articles"
"""
enum author_articles_update_column {
  """column name"""
  article_id

  """column name"""
  author_id

  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  is_primary

  """column name"""
  updated_at
}

input author_articles_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: author_articles_set_input

  """filter the rows which have to be updated"""
  where: author_articles_bool_exp!
}

"""
columns and relationships of "authors"
"""
type authors {
  avatar_url: String
  bio: String
  created_at: timestamptz!
  deleted_at: timestamptz
  email: String!
  id: uuid!
  name: String!
  site_id: uuid
  updated_at: timestamptz!
}

"""
aggregated selection of "authors"
"""
type authors_aggregate {
  aggregate: authors_aggregate_fields
  nodes: [authors!]!
}

"""
aggregate fields of "authors"
"""
type authors_aggregate_fields {
  count(columns: [authors_select_column!], distinct: Boolean): Int!
  max: authors_max_fields
  min: authors_min_fields
}

"""
Boolean expression to filter rows from the table "authors". All fields are combined with a logical 'AND'.
"""
input authors_bool_exp {
  _and: [authors_bool_exp!]
  _not: authors_bool_exp
  _or: [authors_bool_exp!]
  avatar_url: String_comparison_exp
  bio: String_comparison_exp
  created_at: timestamptz_comparison_exp
  deleted_at: timestamptz_comparison_exp
  email: String_comparison_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
  site_id: uuid_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "authors"
"""
enum authors_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  authors_pkey
}

"""
input type for inserting data into table "authors"
"""
input authors_insert_input {
  avatar_url: String
  bio: String
  created_at: timestamptz
  deleted_at: timestamptz
  email: String
  id: uuid
  name: String
  site_id: uuid
  updated_at: timestamptz
}

"""aggregate max on columns"""
type authors_max_fields {
  avatar_url: String
  bio: String
  created_at: timestamptz
  deleted_at: timestamptz
  email: String
  id: uuid
  name: String
  site_id: uuid
  updated_at: timestamptz
}

"""aggregate min on columns"""
type authors_min_fields {
  avatar_url: String
  bio: String
  created_at: timestamptz
  deleted_at: timestamptz
  email: String
  id: uuid
  name: String
  site_id: uuid
  updated_at: timestamptz
}

"""
response of any mutation on the table "authors"
"""
type authors_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [authors!]!
}

"""
on_conflict condition type for table "authors"
"""
input authors_on_conflict {
  constraint: authors_constraint!
  update_columns: [authors_update_column!]! = []
  where: authors_bool_exp
}

"""Ordering options when selecting data from "authors"."""
input authors_order_by {
  avatar_url: order_by
  bio: order_by
  created_at: order_by
  deleted_at: order_by
  email: order_by
  id: order_by
  name: order_by
  site_id: order_by
  updated_at: order_by
}

"""primary key columns input for table: authors"""
input authors_pk_columns_input {
  id: uuid!
}

"""
select columns of table "authors"
"""
enum authors_select_column {
  """column name"""
  avatar_url

  """column name"""
  bio

  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  email

  """column name"""
  id

  """column name"""
  name

  """column name"""
  site_id

  """column name"""
  updated_at
}

"""
input type for updating data in table "authors"
"""
input authors_set_input {
  avatar_url: String
  bio: String
  created_at: timestamptz
  deleted_at: timestamptz
  email: String
  id: uuid
  name: String
  site_id: uuid
  updated_at: timestamptz
}

"""
Streaming cursor of the table "authors"
"""
input authors_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: authors_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input authors_stream_cursor_value_input {
  avatar_url: String
  bio: String
  created_at: timestamptz
  deleted_at: timestamptz
  email: String
  id: uuid
  name: String
  site_id: uuid
  updated_at: timestamptz
}

"""
update columns of table "authors"
"""
enum authors_update_column {
  """column name"""
  avatar_url

  """column name"""
  bio

  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  email

  """column name"""
  id

  """column name"""
  name

  """column name"""
  site_id

  """column name"""
  updated_at
}

input authors_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: authors_set_input

  """filter the rows which have to be updated"""
  where: authors_bool_exp!
}

scalar bigint

"""
Boolean expression to compare columns of type "bigint". All fields are combined with logical 'AND'.
"""
input bigint_comparison_exp {
  _eq: bigint
  _gt: bigint
  _gte: bigint
  _in: [bigint!]
  _is_null: Boolean
  _lt: bigint
  _lte: bigint
  _neq: bigint
  _nin: [bigint!]
}

"""
columns and relationships of "blocks"
"""
type blocks {
  blocked_id: uuid
  blocker_id: uuid
  created_at: timestamptz!
  deleted_at: timestamptz
  id: uuid!
  updated_at: timestamptz!
}

"""
aggregated selection of "blocks"
"""
type blocks_aggregate {
  aggregate: blocks_aggregate_fields
  nodes: [blocks!]!
}

"""
aggregate fields of "blocks"
"""
type blocks_aggregate_fields {
  count(columns: [blocks_select_column!], distinct: Boolean): Int!
  max: blocks_max_fields
  min: blocks_min_fields
}

"""
Boolean expression to filter rows from the table "blocks". All fields are combined with a logical 'AND'.
"""
input blocks_bool_exp {
  _and: [blocks_bool_exp!]
  _not: blocks_bool_exp
  _or: [blocks_bool_exp!]
  blocked_id: uuid_comparison_exp
  blocker_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  deleted_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "blocks"
"""
enum blocks_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  blocks_pkey
}

"""
input type for inserting data into table "blocks"
"""
input blocks_insert_input {
  blocked_id: uuid
  blocker_id: uuid
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  updated_at: timestamptz
}

"""aggregate max on columns"""
type blocks_max_fields {
  blocked_id: uuid
  blocker_id: uuid
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  updated_at: timestamptz
}

"""aggregate min on columns"""
type blocks_min_fields {
  blocked_id: uuid
  blocker_id: uuid
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  updated_at: timestamptz
}

"""
response of any mutation on the table "blocks"
"""
type blocks_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [blocks!]!
}

"""
on_conflict condition type for table "blocks"
"""
input blocks_on_conflict {
  constraint: blocks_constraint!
  update_columns: [blocks_update_column!]! = []
  where: blocks_bool_exp
}

"""Ordering options when selecting data from "blocks"."""
input blocks_order_by {
  blocked_id: order_by
  blocker_id: order_by
  created_at: order_by
  deleted_at: order_by
  id: order_by
  updated_at: order_by
}

"""primary key columns input for table: blocks"""
input blocks_pk_columns_input {
  id: uuid!
}

"""
select columns of table "blocks"
"""
enum blocks_select_column {
  """column name"""
  blocked_id

  """column name"""
  blocker_id

  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  updated_at
}

"""
input type for updating data in table "blocks"
"""
input blocks_set_input {
  blocked_id: uuid
  blocker_id: uuid
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  updated_at: timestamptz
}

"""
Streaming cursor of the table "blocks"
"""
input blocks_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: blocks_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input blocks_stream_cursor_value_input {
  blocked_id: uuid
  blocker_id: uuid
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  updated_at: timestamptz
}

"""
update columns of table "blocks"
"""
enum blocks_update_column {
  """column name"""
  blocked_id

  """column name"""
  blocker_id

  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  updated_at
}

input blocks_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: blocks_set_input

  """filter the rows which have to be updated"""
  where: blocks_bool_exp!
}

"""
columns and relationships of "bookmarks"
"""
type bookmarks {
  created_at: timestamptz!
  deleted_at: timestamptz
  id: uuid!
  post_id: uuid
  updated_at: timestamptz!
  user_id: uuid
}

"""
aggregated selection of "bookmarks"
"""
type bookmarks_aggregate {
  aggregate: bookmarks_aggregate_fields
  nodes: [bookmarks!]!
}

"""
aggregate fields of "bookmarks"
"""
type bookmarks_aggregate_fields {
  count(columns: [bookmarks_select_column!], distinct: Boolean): Int!
  max: bookmarks_max_fields
  min: bookmarks_min_fields
}

"""
Boolean expression to filter rows from the table "bookmarks". All fields are combined with a logical 'AND'.
"""
input bookmarks_bool_exp {
  _and: [bookmarks_bool_exp!]
  _not: bookmarks_bool_exp
  _or: [bookmarks_bool_exp!]
  created_at: timestamptz_comparison_exp
  deleted_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  post_id: uuid_comparison_exp
  updated_at: timestamptz_comparison_exp
  user_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "bookmarks"
"""
enum bookmarks_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  bookmarks_pkey
}

"""
input type for inserting data into table "bookmarks"
"""
input bookmarks_insert_input {
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  post_id: uuid
  updated_at: timestamptz
  user_id: uuid
}

"""aggregate max on columns"""
type bookmarks_max_fields {
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  post_id: uuid
  updated_at: timestamptz
  user_id: uuid
}

"""aggregate min on columns"""
type bookmarks_min_fields {
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  post_id: uuid
  updated_at: timestamptz
  user_id: uuid
}

"""
response of any mutation on the table "bookmarks"
"""
type bookmarks_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [bookmarks!]!
}

"""
on_conflict condition type for table "bookmarks"
"""
input bookmarks_on_conflict {
  constraint: bookmarks_constraint!
  update_columns: [bookmarks_update_column!]! = []
  where: bookmarks_bool_exp
}

"""Ordering options when selecting data from "bookmarks"."""
input bookmarks_order_by {
  created_at: order_by
  deleted_at: order_by
  id: order_by
  post_id: order_by
  updated_at: order_by
  user_id: order_by
}

"""primary key columns input for table: bookmarks"""
input bookmarks_pk_columns_input {
  id: uuid!
}

"""
select columns of table "bookmarks"
"""
enum bookmarks_select_column {
  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  post_id

  """column name"""
  updated_at

  """column name"""
  user_id
}

"""
input type for updating data in table "bookmarks"
"""
input bookmarks_set_input {
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  post_id: uuid
  updated_at: timestamptz
  user_id: uuid
}

"""
Streaming cursor of the table "bookmarks"
"""
input bookmarks_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: bookmarks_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input bookmarks_stream_cursor_value_input {
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  post_id: uuid
  updated_at: timestamptz
  user_id: uuid
}

"""
update columns of table "bookmarks"
"""
enum bookmarks_update_column {
  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  post_id

  """column name"""
  updated_at

  """column name"""
  user_id
}

input bookmarks_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: bookmarks_set_input

  """filter the rows which have to be updated"""
  where: bookmarks_bool_exp!
}

"""
columns and relationships of "brands"
"""
type brands {
  created_at: timestamptz!
  deleted_at: timestamptz
  id: uuid!
  logo_url: String
  name: String!
  slug: String!
  updated_at: timestamptz!
}

"""
aggregated selection of "brands"
"""
type brands_aggregate {
  aggregate: brands_aggregate_fields
  nodes: [brands!]!
}

"""
aggregate fields of "brands"
"""
type brands_aggregate_fields {
  count(columns: [brands_select_column!], distinct: Boolean): Int!
  max: brands_max_fields
  min: brands_min_fields
}

"""
Boolean expression to filter rows from the table "brands". All fields are combined with a logical 'AND'.
"""
input brands_bool_exp {
  _and: [brands_bool_exp!]
  _not: brands_bool_exp
  _or: [brands_bool_exp!]
  created_at: timestamptz_comparison_exp
  deleted_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  logo_url: String_comparison_exp
  name: String_comparison_exp
  slug: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "brands"
"""
enum brands_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  brands_pkey
}

"""
input type for inserting data into table "brands"
"""
input brands_insert_input {
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  logo_url: String
  name: String
  slug: String
  updated_at: timestamptz
}

"""aggregate max on columns"""
type brands_max_fields {
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  logo_url: String
  name: String
  slug: String
  updated_at: timestamptz
}

"""aggregate min on columns"""
type brands_min_fields {
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  logo_url: String
  name: String
  slug: String
  updated_at: timestamptz
}

"""
response of any mutation on the table "brands"
"""
type brands_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [brands!]!
}

"""
on_conflict condition type for table "brands"
"""
input brands_on_conflict {
  constraint: brands_constraint!
  update_columns: [brands_update_column!]! = []
  where: brands_bool_exp
}

"""Ordering options when selecting data from "brands"."""
input brands_order_by {
  created_at: order_by
  deleted_at: order_by
  id: order_by
  logo_url: order_by
  name: order_by
  slug: order_by
  updated_at: order_by
}

"""primary key columns input for table: brands"""
input brands_pk_columns_input {
  id: uuid!
}

"""
select columns of table "brands"
"""
enum brands_select_column {
  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  logo_url

  """column name"""
  name

  """column name"""
  slug

  """column name"""
  updated_at
}

"""
input type for updating data in table "brands"
"""
input brands_set_input {
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  logo_url: String
  name: String
  slug: String
  updated_at: timestamptz
}

"""
Streaming cursor of the table "brands"
"""
input brands_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: brands_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input brands_stream_cursor_value_input {
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  logo_url: String
  name: String
  slug: String
  updated_at: timestamptz
}

"""
update columns of table "brands"
"""
enum brands_update_column {
  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  logo_url

  """column name"""
  name

  """column name"""
  slug

  """column name"""
  updated_at
}

input brands_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: brands_set_input

  """filter the rows which have to be updated"""
  where: brands_bool_exp!
}

"""
columns and relationships of "cart_items"
"""
type cart_items {
  cart_id: uuid
  created_at: timestamptz!
  deleted_at: timestamptz
  id: uuid!
  quantity: Int!
  unit_price: numeric!
  updated_at: timestamptz!
  variant_id: uuid
}

"""
aggregated selection of "cart_items"
"""
type cart_items_aggregate {
  aggregate: cart_items_aggregate_fields
  nodes: [cart_items!]!
}

"""
aggregate fields of "cart_items"
"""
type cart_items_aggregate_fields {
  avg: cart_items_avg_fields
  count(columns: [cart_items_select_column!], distinct: Boolean): Int!
  max: cart_items_max_fields
  min: cart_items_min_fields
  stddev: cart_items_stddev_fields
  stddev_pop: cart_items_stddev_pop_fields
  stddev_samp: cart_items_stddev_samp_fields
  sum: cart_items_sum_fields
  var_pop: cart_items_var_pop_fields
  var_samp: cart_items_var_samp_fields
  variance: cart_items_variance_fields
}

"""aggregate avg on columns"""
type cart_items_avg_fields {
  quantity: Float
  unit_price: Float
}

"""
Boolean expression to filter rows from the table "cart_items". All fields are combined with a logical 'AND'.
"""
input cart_items_bool_exp {
  _and: [cart_items_bool_exp!]
  _not: cart_items_bool_exp
  _or: [cart_items_bool_exp!]
  cart_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  deleted_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  quantity: Int_comparison_exp
  unit_price: numeric_comparison_exp
  updated_at: timestamptz_comparison_exp
  variant_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "cart_items"
"""
enum cart_items_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  cart_items_pkey
}

"""
input type for incrementing numeric columns in table "cart_items"
"""
input cart_items_inc_input {
  quantity: Int
  unit_price: numeric
}

"""
input type for inserting data into table "cart_items"
"""
input cart_items_insert_input {
  cart_id: uuid
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  quantity: Int
  unit_price: numeric
  updated_at: timestamptz
  variant_id: uuid
}

"""aggregate max on columns"""
type cart_items_max_fields {
  cart_id: uuid
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  quantity: Int
  unit_price: numeric
  updated_at: timestamptz
  variant_id: uuid
}

"""aggregate min on columns"""
type cart_items_min_fields {
  cart_id: uuid
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  quantity: Int
  unit_price: numeric
  updated_at: timestamptz
  variant_id: uuid
}

"""
response of any mutation on the table "cart_items"
"""
type cart_items_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [cart_items!]!
}

"""
on_conflict condition type for table "cart_items"
"""
input cart_items_on_conflict {
  constraint: cart_items_constraint!
  update_columns: [cart_items_update_column!]! = []
  where: cart_items_bool_exp
}

"""Ordering options when selecting data from "cart_items"."""
input cart_items_order_by {
  cart_id: order_by
  created_at: order_by
  deleted_at: order_by
  id: order_by
  quantity: order_by
  unit_price: order_by
  updated_at: order_by
  variant_id: order_by
}

"""primary key columns input for table: cart_items"""
input cart_items_pk_columns_input {
  id: uuid!
}

"""
select columns of table "cart_items"
"""
enum cart_items_select_column {
  """column name"""
  cart_id

  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  quantity

  """column name"""
  unit_price

  """column name"""
  updated_at

  """column name"""
  variant_id
}

"""
input type for updating data in table "cart_items"
"""
input cart_items_set_input {
  cart_id: uuid
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  quantity: Int
  unit_price: numeric
  updated_at: timestamptz
  variant_id: uuid
}

"""aggregate stddev on columns"""
type cart_items_stddev_fields {
  quantity: Float
  unit_price: Float
}

"""aggregate stddev_pop on columns"""
type cart_items_stddev_pop_fields {
  quantity: Float
  unit_price: Float
}

"""aggregate stddev_samp on columns"""
type cart_items_stddev_samp_fields {
  quantity: Float
  unit_price: Float
}

"""
Streaming cursor of the table "cart_items"
"""
input cart_items_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: cart_items_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input cart_items_stream_cursor_value_input {
  cart_id: uuid
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  quantity: Int
  unit_price: numeric
  updated_at: timestamptz
  variant_id: uuid
}

"""aggregate sum on columns"""
type cart_items_sum_fields {
  quantity: Int
  unit_price: numeric
}

"""
update columns of table "cart_items"
"""
enum cart_items_update_column {
  """column name"""
  cart_id

  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  quantity

  """column name"""
  unit_price

  """column name"""
  updated_at

  """column name"""
  variant_id
}

input cart_items_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: cart_items_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: cart_items_set_input

  """filter the rows which have to be updated"""
  where: cart_items_bool_exp!
}

"""aggregate var_pop on columns"""
type cart_items_var_pop_fields {
  quantity: Float
  unit_price: Float
}

"""aggregate var_samp on columns"""
type cart_items_var_samp_fields {
  quantity: Float
  unit_price: Float
}

"""aggregate variance on columns"""
type cart_items_variance_fields {
  quantity: Float
  unit_price: Float
}

"""
columns and relationships of "carts"
"""
type carts {
  created_at: timestamptz!
  customer_id: uuid
  deleted_at: timestamptz
  expires_at: timestamptz
  id: uuid!
  session_id: String
  updated_at: timestamptz!
}

"""
aggregated selection of "carts"
"""
type carts_aggregate {
  aggregate: carts_aggregate_fields
  nodes: [carts!]!
}

"""
aggregate fields of "carts"
"""
type carts_aggregate_fields {
  count(columns: [carts_select_column!], distinct: Boolean): Int!
  max: carts_max_fields
  min: carts_min_fields
}

"""
Boolean expression to filter rows from the table "carts". All fields are combined with a logical 'AND'.
"""
input carts_bool_exp {
  _and: [carts_bool_exp!]
  _not: carts_bool_exp
  _or: [carts_bool_exp!]
  created_at: timestamptz_comparison_exp
  customer_id: uuid_comparison_exp
  deleted_at: timestamptz_comparison_exp
  expires_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  session_id: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "carts"
"""
enum carts_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  carts_pkey
}

"""
input type for inserting data into table "carts"
"""
input carts_insert_input {
  created_at: timestamptz
  customer_id: uuid
  deleted_at: timestamptz
  expires_at: timestamptz
  id: uuid
  session_id: String
  updated_at: timestamptz
}

"""aggregate max on columns"""
type carts_max_fields {
  created_at: timestamptz
  customer_id: uuid
  deleted_at: timestamptz
  expires_at: timestamptz
  id: uuid
  session_id: String
  updated_at: timestamptz
}

"""aggregate min on columns"""
type carts_min_fields {
  created_at: timestamptz
  customer_id: uuid
  deleted_at: timestamptz
  expires_at: timestamptz
  id: uuid
  session_id: String
  updated_at: timestamptz
}

"""
response of any mutation on the table "carts"
"""
type carts_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [carts!]!
}

"""
on_conflict condition type for table "carts"
"""
input carts_on_conflict {
  constraint: carts_constraint!
  update_columns: [carts_update_column!]! = []
  where: carts_bool_exp
}

"""Ordering options when selecting data from "carts"."""
input carts_order_by {
  created_at: order_by
  customer_id: order_by
  deleted_at: order_by
  expires_at: order_by
  id: order_by
  session_id: order_by
  updated_at: order_by
}

"""primary key columns input for table: carts"""
input carts_pk_columns_input {
  id: uuid!
}

"""
select columns of table "carts"
"""
enum carts_select_column {
  """column name"""
  created_at

  """column name"""
  customer_id

  """column name"""
  deleted_at

  """column name"""
  expires_at

  """column name"""
  id

  """column name"""
  session_id

  """column name"""
  updated_at
}

"""
input type for updating data in table "carts"
"""
input carts_set_input {
  created_at: timestamptz
  customer_id: uuid
  deleted_at: timestamptz
  expires_at: timestamptz
  id: uuid
  session_id: String
  updated_at: timestamptz
}

"""
Streaming cursor of the table "carts"
"""
input carts_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: carts_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input carts_stream_cursor_value_input {
  created_at: timestamptz
  customer_id: uuid
  deleted_at: timestamptz
  expires_at: timestamptz
  id: uuid
  session_id: String
  updated_at: timestamptz
}

"""
update columns of table "carts"
"""
enum carts_update_column {
  """column name"""
  created_at

  """column name"""
  customer_id

  """column name"""
  deleted_at

  """column name"""
  expires_at

  """column name"""
  id

  """column name"""
  session_id

  """column name"""
  updated_at
}

input carts_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: carts_set_input

  """filter the rows which have to be updated"""
  where: carts_bool_exp!
}

"""
columns and relationships of "cities"
"""
type cities {
  created_at: timestamptz!
  deleted_at: timestamptz
  district_id: uuid
  id: uuid!
  name: String!
  postal_code_prefix: String
  updated_at: timestamptz!
}

"""
aggregated selection of "cities"
"""
type cities_aggregate {
  aggregate: cities_aggregate_fields
  nodes: [cities!]!
}

"""
aggregate fields of "cities"
"""
type cities_aggregate_fields {
  count(columns: [cities_select_column!], distinct: Boolean): Int!
  max: cities_max_fields
  min: cities_min_fields
}

"""
Boolean expression to filter rows from the table "cities". All fields are combined with a logical 'AND'.
"""
input cities_bool_exp {
  _and: [cities_bool_exp!]
  _not: cities_bool_exp
  _or: [cities_bool_exp!]
  created_at: timestamptz_comparison_exp
  deleted_at: timestamptz_comparison_exp
  district_id: uuid_comparison_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
  postal_code_prefix: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "cities"
"""
enum cities_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  cities_pkey
}

"""
input type for inserting data into table "cities"
"""
input cities_insert_input {
  created_at: timestamptz
  deleted_at: timestamptz
  district_id: uuid
  id: uuid
  name: String
  postal_code_prefix: String
  updated_at: timestamptz
}

"""aggregate max on columns"""
type cities_max_fields {
  created_at: timestamptz
  deleted_at: timestamptz
  district_id: uuid
  id: uuid
  name: String
  postal_code_prefix: String
  updated_at: timestamptz
}

"""aggregate min on columns"""
type cities_min_fields {
  created_at: timestamptz
  deleted_at: timestamptz
  district_id: uuid
  id: uuid
  name: String
  postal_code_prefix: String
  updated_at: timestamptz
}

"""
response of any mutation on the table "cities"
"""
type cities_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [cities!]!
}

"""
on_conflict condition type for table "cities"
"""
input cities_on_conflict {
  constraint: cities_constraint!
  update_columns: [cities_update_column!]! = []
  where: cities_bool_exp
}

"""Ordering options when selecting data from "cities"."""
input cities_order_by {
  created_at: order_by
  deleted_at: order_by
  district_id: order_by
  id: order_by
  name: order_by
  postal_code_prefix: order_by
  updated_at: order_by
}

"""primary key columns input for table: cities"""
input cities_pk_columns_input {
  id: uuid!
}

"""
select columns of table "cities"
"""
enum cities_select_column {
  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  district_id

  """column name"""
  id

  """column name"""
  name

  """column name"""
  postal_code_prefix

  """column name"""
  updated_at
}

"""
input type for updating data in table "cities"
"""
input cities_set_input {
  created_at: timestamptz
  deleted_at: timestamptz
  district_id: uuid
  id: uuid
  name: String
  postal_code_prefix: String
  updated_at: timestamptz
}

"""
Streaming cursor of the table "cities"
"""
input cities_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: cities_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input cities_stream_cursor_value_input {
  created_at: timestamptz
  deleted_at: timestamptz
  district_id: uuid
  id: uuid
  name: String
  postal_code_prefix: String
  updated_at: timestamptz
}

"""
update columns of table "cities"
"""
enum cities_update_column {
  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  district_id

  """column name"""
  id

  """column name"""
  name

  """column name"""
  postal_code_prefix

  """column name"""
  updated_at
}

input cities_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: cities_set_input

  """filter the rows which have to be updated"""
  where: cities_bool_exp!
}

"""
columns and relationships of "collections"
"""
type collections {
  created_at: timestamptz!
  deleted_at: timestamptz
  description: String
  id: uuid!
  image_url: String
  is_published: Boolean!
  name: String!
  slug: String!
  store_id: uuid
  updated_at: timestamptz!
}

"""
aggregated selection of "collections"
"""
type collections_aggregate {
  aggregate: collections_aggregate_fields
  nodes: [collections!]!
}

"""
aggregate fields of "collections"
"""
type collections_aggregate_fields {
  count(columns: [collections_select_column!], distinct: Boolean): Int!
  max: collections_max_fields
  min: collections_min_fields
}

"""
Boolean expression to filter rows from the table "collections". All fields are combined with a logical 'AND'.
"""
input collections_bool_exp {
  _and: [collections_bool_exp!]
  _not: collections_bool_exp
  _or: [collections_bool_exp!]
  created_at: timestamptz_comparison_exp
  deleted_at: timestamptz_comparison_exp
  description: String_comparison_exp
  id: uuid_comparison_exp
  image_url: String_comparison_exp
  is_published: Boolean_comparison_exp
  name: String_comparison_exp
  slug: String_comparison_exp
  store_id: uuid_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "collections"
"""
enum collections_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  collections_pkey
}

"""
input type for inserting data into table "collections"
"""
input collections_insert_input {
  created_at: timestamptz
  deleted_at: timestamptz
  description: String
  id: uuid
  image_url: String
  is_published: Boolean
  name: String
  slug: String
  store_id: uuid
  updated_at: timestamptz
}

"""aggregate max on columns"""
type collections_max_fields {
  created_at: timestamptz
  deleted_at: timestamptz
  description: String
  id: uuid
  image_url: String
  name: String
  slug: String
  store_id: uuid
  updated_at: timestamptz
}

"""aggregate min on columns"""
type collections_min_fields {
  created_at: timestamptz
  deleted_at: timestamptz
  description: String
  id: uuid
  image_url: String
  name: String
  slug: String
  store_id: uuid
  updated_at: timestamptz
}

"""
response of any mutation on the table "collections"
"""
type collections_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [collections!]!
}

"""
on_conflict condition type for table "collections"
"""
input collections_on_conflict {
  constraint: collections_constraint!
  update_columns: [collections_update_column!]! = []
  where: collections_bool_exp
}

"""Ordering options when selecting data from "collections"."""
input collections_order_by {
  created_at: order_by
  deleted_at: order_by
  description: order_by
  id: order_by
  image_url: order_by
  is_published: order_by
  name: order_by
  slug: order_by
  store_id: order_by
  updated_at: order_by
}

"""primary key columns input for table: collections"""
input collections_pk_columns_input {
  id: uuid!
}

"""
select columns of table "collections"
"""
enum collections_select_column {
  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  description

  """column name"""
  id

  """column name"""
  image_url

  """column name"""
  is_published

  """column name"""
  name

  """column name"""
  slug

  """column name"""
  store_id

  """column name"""
  updated_at
}

"""
input type for updating data in table "collections"
"""
input collections_set_input {
  created_at: timestamptz
  deleted_at: timestamptz
  description: String
  id: uuid
  image_url: String
  is_published: Boolean
  name: String
  slug: String
  store_id: uuid
  updated_at: timestamptz
}

"""
Streaming cursor of the table "collections"
"""
input collections_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: collections_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input collections_stream_cursor_value_input {
  created_at: timestamptz
  deleted_at: timestamptz
  description: String
  id: uuid
  image_url: String
  is_published: Boolean
  name: String
  slug: String
  store_id: uuid
  updated_at: timestamptz
}

"""
update columns of table "collections"
"""
enum collections_update_column {
  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  description

  """column name"""
  id

  """column name"""
  image_url

  """column name"""
  is_published

  """column name"""
  name

  """column name"""
  slug

  """column name"""
  store_id

  """column name"""
  updated_at
}

input collections_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: collections_set_input

  """filter the rows which have to be updated"""
  where: collections_bool_exp!
}

"""
columns and relationships of "colors"
"""
type colors {
  created_at: timestamptz!
  deleted_at: timestamptz
  hex_code: String!
  id: uuid!
  name: String!
  sort_order: Int!
  updated_at: timestamptz!
}

"""
aggregated selection of "colors"
"""
type colors_aggregate {
  aggregate: colors_aggregate_fields
  nodes: [colors!]!
}

"""
aggregate fields of "colors"
"""
type colors_aggregate_fields {
  avg: colors_avg_fields
  count(columns: [colors_select_column!], distinct: Boolean): Int!
  max: colors_max_fields
  min: colors_min_fields
  stddev: colors_stddev_fields
  stddev_pop: colors_stddev_pop_fields
  stddev_samp: colors_stddev_samp_fields
  sum: colors_sum_fields
  var_pop: colors_var_pop_fields
  var_samp: colors_var_samp_fields
  variance: colors_variance_fields
}

"""aggregate avg on columns"""
type colors_avg_fields {
  sort_order: Float
}

"""
Boolean expression to filter rows from the table "colors". All fields are combined with a logical 'AND'.
"""
input colors_bool_exp {
  _and: [colors_bool_exp!]
  _not: colors_bool_exp
  _or: [colors_bool_exp!]
  created_at: timestamptz_comparison_exp
  deleted_at: timestamptz_comparison_exp
  hex_code: String_comparison_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
  sort_order: Int_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "colors"
"""
enum colors_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  colors_pkey
}

"""
input type for incrementing numeric columns in table "colors"
"""
input colors_inc_input {
  sort_order: Int
}

"""
input type for inserting data into table "colors"
"""
input colors_insert_input {
  created_at: timestamptz
  deleted_at: timestamptz
  hex_code: String
  id: uuid
  name: String
  sort_order: Int
  updated_at: timestamptz
}

"""aggregate max on columns"""
type colors_max_fields {
  created_at: timestamptz
  deleted_at: timestamptz
  hex_code: String
  id: uuid
  name: String
  sort_order: Int
  updated_at: timestamptz
}

"""aggregate min on columns"""
type colors_min_fields {
  created_at: timestamptz
  deleted_at: timestamptz
  hex_code: String
  id: uuid
  name: String
  sort_order: Int
  updated_at: timestamptz
}

"""
response of any mutation on the table "colors"
"""
type colors_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [colors!]!
}

"""
on_conflict condition type for table "colors"
"""
input colors_on_conflict {
  constraint: colors_constraint!
  update_columns: [colors_update_column!]! = []
  where: colors_bool_exp
}

"""Ordering options when selecting data from "colors"."""
input colors_order_by {
  created_at: order_by
  deleted_at: order_by
  hex_code: order_by
  id: order_by
  name: order_by
  sort_order: order_by
  updated_at: order_by
}

"""primary key columns input for table: colors"""
input colors_pk_columns_input {
  id: uuid!
}

"""
select columns of table "colors"
"""
enum colors_select_column {
  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  hex_code

  """column name"""
  id

  """column name"""
  name

  """column name"""
  sort_order

  """column name"""
  updated_at
}

"""
input type for updating data in table "colors"
"""
input colors_set_input {
  created_at: timestamptz
  deleted_at: timestamptz
  hex_code: String
  id: uuid
  name: String
  sort_order: Int
  updated_at: timestamptz
}

"""aggregate stddev on columns"""
type colors_stddev_fields {
  sort_order: Float
}

"""aggregate stddev_pop on columns"""
type colors_stddev_pop_fields {
  sort_order: Float
}

"""aggregate stddev_samp on columns"""
type colors_stddev_samp_fields {
  sort_order: Float
}

"""
Streaming cursor of the table "colors"
"""
input colors_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: colors_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input colors_stream_cursor_value_input {
  created_at: timestamptz
  deleted_at: timestamptz
  hex_code: String
  id: uuid
  name: String
  sort_order: Int
  updated_at: timestamptz
}

"""aggregate sum on columns"""
type colors_sum_fields {
  sort_order: Int
}

"""
update columns of table "colors"
"""
enum colors_update_column {
  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  hex_code

  """column name"""
  id

  """column name"""
  name

  """column name"""
  sort_order

  """column name"""
  updated_at
}

input colors_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: colors_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: colors_set_input

  """filter the rows which have to be updated"""
  where: colors_bool_exp!
}

"""aggregate var_pop on columns"""
type colors_var_pop_fields {
  sort_order: Float
}

"""aggregate var_samp on columns"""
type colors_var_samp_fields {
  sort_order: Float
}

"""aggregate variance on columns"""
type colors_variance_fields {
  sort_order: Float
}

"""
columns and relationships of "comments"
"""
type comments {
  article_id: uuid
  author_email: String!
  author_name: String!
  content: String!
  created_at: timestamptz!
  deleted_at: timestamptz
  id: uuid!
  is_approved: Boolean!
  parent_id: uuid
  updated_at: timestamptz!
}

"""
aggregated selection of "comments"
"""
type comments_aggregate {
  aggregate: comments_aggregate_fields
  nodes: [comments!]!
}

"""
aggregate fields of "comments"
"""
type comments_aggregate_fields {
  count(columns: [comments_select_column!], distinct: Boolean): Int!
  max: comments_max_fields
  min: comments_min_fields
}

"""
Boolean expression to filter rows from the table "comments". All fields are combined with a logical 'AND'.
"""
input comments_bool_exp {
  _and: [comments_bool_exp!]
  _not: comments_bool_exp
  _or: [comments_bool_exp!]
  article_id: uuid_comparison_exp
  author_email: String_comparison_exp
  author_name: String_comparison_exp
  content: String_comparison_exp
  created_at: timestamptz_comparison_exp
  deleted_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  is_approved: Boolean_comparison_exp
  parent_id: uuid_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "comments"
"""
enum comments_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  comments_pkey
}

"""
input type for inserting data into table "comments"
"""
input comments_insert_input {
  article_id: uuid
  author_email: String
  author_name: String
  content: String
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  is_approved: Boolean
  parent_id: uuid
  updated_at: timestamptz
}

"""aggregate max on columns"""
type comments_max_fields {
  article_id: uuid
  author_email: String
  author_name: String
  content: String
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  parent_id: uuid
  updated_at: timestamptz
}

"""aggregate min on columns"""
type comments_min_fields {
  article_id: uuid
  author_email: String
  author_name: String
  content: String
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  parent_id: uuid
  updated_at: timestamptz
}

"""
response of any mutation on the table "comments"
"""
type comments_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [comments!]!
}

"""
on_conflict condition type for table "comments"
"""
input comments_on_conflict {
  constraint: comments_constraint!
  update_columns: [comments_update_column!]! = []
  where: comments_bool_exp
}

"""Ordering options when selecting data from "comments"."""
input comments_order_by {
  article_id: order_by
  author_email: order_by
  author_name: order_by
  content: order_by
  created_at: order_by
  deleted_at: order_by
  id: order_by
  is_approved: order_by
  parent_id: order_by
  updated_at: order_by
}

"""primary key columns input for table: comments"""
input comments_pk_columns_input {
  id: uuid!
}

"""
select columns of table "comments"
"""
enum comments_select_column {
  """column name"""
  article_id

  """column name"""
  author_email

  """column name"""
  author_name

  """column name"""
  content

  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  is_approved

  """column name"""
  parent_id

  """column name"""
  updated_at
}

"""
input type for updating data in table "comments"
"""
input comments_set_input {
  article_id: uuid
  author_email: String
  author_name: String
  content: String
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  is_approved: Boolean
  parent_id: uuid
  updated_at: timestamptz
}

"""
Streaming cursor of the table "comments"
"""
input comments_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: comments_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input comments_stream_cursor_value_input {
  article_id: uuid
  author_email: String
  author_name: String
  content: String
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  is_approved: Boolean
  parent_id: uuid
  updated_at: timestamptz
}

"""
update columns of table "comments"
"""
enum comments_update_column {
  """column name"""
  article_id

  """column name"""
  author_email

  """column name"""
  author_name

  """column name"""
  content

  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  is_approved

  """column name"""
  parent_id

  """column name"""
  updated_at
}

input comments_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: comments_set_input

  """filter the rows which have to be updated"""
  where: comments_bool_exp!
}

"""
columns and relationships of "conversation_participants"
"""
type conversation_participants {
  conversation_id: uuid
  created_at: timestamptz!
  deleted_at: timestamptz
  id: uuid!
  is_admin: Boolean!
  joined_at: timestamptz!
  left_at: timestamptz
  updated_at: timestamptz!
  user_id: uuid
}

"""
aggregated selection of "conversation_participants"
"""
type conversation_participants_aggregate {
  aggregate: conversation_participants_aggregate_fields
  nodes: [conversation_participants!]!
}

"""
aggregate fields of "conversation_participants"
"""
type conversation_participants_aggregate_fields {
  count(columns: [conversation_participants_select_column!], distinct: Boolean): Int!
  max: conversation_participants_max_fields
  min: conversation_participants_min_fields
}

"""
Boolean expression to filter rows from the table "conversation_participants". All fields are combined with a logical 'AND'.
"""
input conversation_participants_bool_exp {
  _and: [conversation_participants_bool_exp!]
  _not: conversation_participants_bool_exp
  _or: [conversation_participants_bool_exp!]
  conversation_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  deleted_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  is_admin: Boolean_comparison_exp
  joined_at: timestamptz_comparison_exp
  left_at: timestamptz_comparison_exp
  updated_at: timestamptz_comparison_exp
  user_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "conversation_participants"
"""
enum conversation_participants_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  conversation_participants_pkey
}

"""
input type for inserting data into table "conversation_participants"
"""
input conversation_participants_insert_input {
  conversation_id: uuid
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  is_admin: Boolean
  joined_at: timestamptz
  left_at: timestamptz
  updated_at: timestamptz
  user_id: uuid
}

"""aggregate max on columns"""
type conversation_participants_max_fields {
  conversation_id: uuid
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  joined_at: timestamptz
  left_at: timestamptz
  updated_at: timestamptz
  user_id: uuid
}

"""aggregate min on columns"""
type conversation_participants_min_fields {
  conversation_id: uuid
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  joined_at: timestamptz
  left_at: timestamptz
  updated_at: timestamptz
  user_id: uuid
}

"""
response of any mutation on the table "conversation_participants"
"""
type conversation_participants_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [conversation_participants!]!
}

"""
on_conflict condition type for table "conversation_participants"
"""
input conversation_participants_on_conflict {
  constraint: conversation_participants_constraint!
  update_columns: [conversation_participants_update_column!]! = []
  where: conversation_participants_bool_exp
}

"""Ordering options when selecting data from "conversation_participants"."""
input conversation_participants_order_by {
  conversation_id: order_by
  created_at: order_by
  deleted_at: order_by
  id: order_by
  is_admin: order_by
  joined_at: order_by
  left_at: order_by
  updated_at: order_by
  user_id: order_by
}

"""primary key columns input for table: conversation_participants"""
input conversation_participants_pk_columns_input {
  id: uuid!
}

"""
select columns of table "conversation_participants"
"""
enum conversation_participants_select_column {
  """column name"""
  conversation_id

  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  is_admin

  """column name"""
  joined_at

  """column name"""
  left_at

  """column name"""
  updated_at

  """column name"""
  user_id
}

"""
input type for updating data in table "conversation_participants"
"""
input conversation_participants_set_input {
  conversation_id: uuid
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  is_admin: Boolean
  joined_at: timestamptz
  left_at: timestamptz
  updated_at: timestamptz
  user_id: uuid
}

"""
Streaming cursor of the table "conversation_participants"
"""
input conversation_participants_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: conversation_participants_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input conversation_participants_stream_cursor_value_input {
  conversation_id: uuid
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  is_admin: Boolean
  joined_at: timestamptz
  left_at: timestamptz
  updated_at: timestamptz
  user_id: uuid
}

"""
update columns of table "conversation_participants"
"""
enum conversation_participants_update_column {
  """column name"""
  conversation_id

  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  is_admin

  """column name"""
  joined_at

  """column name"""
  left_at

  """column name"""
  updated_at

  """column name"""
  user_id
}

input conversation_participants_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: conversation_participants_set_input

  """filter the rows which have to be updated"""
  where: conversation_participants_bool_exp!
}

"""
columns and relationships of "conversations"
"""
type conversations {
  created_at: timestamptz!
  deleted_at: timestamptz
  id: uuid!
  is_group: Boolean!
  title: String
  updated_at: timestamptz!
}

"""
aggregated selection of "conversations"
"""
type conversations_aggregate {
  aggregate: conversations_aggregate_fields
  nodes: [conversations!]!
}

"""
aggregate fields of "conversations"
"""
type conversations_aggregate_fields {
  count(columns: [conversations_select_column!], distinct: Boolean): Int!
  max: conversations_max_fields
  min: conversations_min_fields
}

"""
Boolean expression to filter rows from the table "conversations". All fields are combined with a logical 'AND'.
"""
input conversations_bool_exp {
  _and: [conversations_bool_exp!]
  _not: conversations_bool_exp
  _or: [conversations_bool_exp!]
  created_at: timestamptz_comparison_exp
  deleted_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  is_group: Boolean_comparison_exp
  title: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "conversations"
"""
enum conversations_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  conversations_pkey
}

"""
input type for inserting data into table "conversations"
"""
input conversations_insert_input {
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  is_group: Boolean
  title: String
  updated_at: timestamptz
}

"""aggregate max on columns"""
type conversations_max_fields {
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  title: String
  updated_at: timestamptz
}

"""aggregate min on columns"""
type conversations_min_fields {
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  title: String
  updated_at: timestamptz
}

"""
response of any mutation on the table "conversations"
"""
type conversations_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [conversations!]!
}

"""
on_conflict condition type for table "conversations"
"""
input conversations_on_conflict {
  constraint: conversations_constraint!
  update_columns: [conversations_update_column!]! = []
  where: conversations_bool_exp
}

"""Ordering options when selecting data from "conversations"."""
input conversations_order_by {
  created_at: order_by
  deleted_at: order_by
  id: order_by
  is_group: order_by
  title: order_by
  updated_at: order_by
}

"""primary key columns input for table: conversations"""
input conversations_pk_columns_input {
  id: uuid!
}

"""
select columns of table "conversations"
"""
enum conversations_select_column {
  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  is_group

  """column name"""
  title

  """column name"""
  updated_at
}

"""
input type for updating data in table "conversations"
"""
input conversations_set_input {
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  is_group: Boolean
  title: String
  updated_at: timestamptz
}

"""
Streaming cursor of the table "conversations"
"""
input conversations_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: conversations_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input conversations_stream_cursor_value_input {
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  is_group: Boolean
  title: String
  updated_at: timestamptz
}

"""
update columns of table "conversations"
"""
enum conversations_update_column {
  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  is_group

  """column name"""
  title

  """column name"""
  updated_at
}

input conversations_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: conversations_set_input

  """filter the rows which have to be updated"""
  where: conversations_bool_exp!
}

"""
columns and relationships of "countries"
"""
type countries {
  code: String!
  created_at: timestamptz!
  deleted_at: timestamptz
  id: uuid!
  is_shipping_enabled: Boolean!
  name: String!
  updated_at: timestamptz!
}

"""
aggregated selection of "countries"
"""
type countries_aggregate {
  aggregate: countries_aggregate_fields
  nodes: [countries!]!
}

"""
aggregate fields of "countries"
"""
type countries_aggregate_fields {
  count(columns: [countries_select_column!], distinct: Boolean): Int!
  max: countries_max_fields
  min: countries_min_fields
}

"""
Boolean expression to filter rows from the table "countries". All fields are combined with a logical 'AND'.
"""
input countries_bool_exp {
  _and: [countries_bool_exp!]
  _not: countries_bool_exp
  _or: [countries_bool_exp!]
  code: String_comparison_exp
  created_at: timestamptz_comparison_exp
  deleted_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  is_shipping_enabled: Boolean_comparison_exp
  name: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "countries"
"""
enum countries_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  countries_pkey
}

"""
input type for inserting data into table "countries"
"""
input countries_insert_input {
  code: String
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  is_shipping_enabled: Boolean
  name: String
  updated_at: timestamptz
}

"""aggregate max on columns"""
type countries_max_fields {
  code: String
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  name: String
  updated_at: timestamptz
}

"""aggregate min on columns"""
type countries_min_fields {
  code: String
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  name: String
  updated_at: timestamptz
}

"""
response of any mutation on the table "countries"
"""
type countries_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [countries!]!
}

"""
on_conflict condition type for table "countries"
"""
input countries_on_conflict {
  constraint: countries_constraint!
  update_columns: [countries_update_column!]! = []
  where: countries_bool_exp
}

"""Ordering options when selecting data from "countries"."""
input countries_order_by {
  code: order_by
  created_at: order_by
  deleted_at: order_by
  id: order_by
  is_shipping_enabled: order_by
  name: order_by
  updated_at: order_by
}

"""primary key columns input for table: countries"""
input countries_pk_columns_input {
  id: uuid!
}

"""
select columns of table "countries"
"""
enum countries_select_column {
  """column name"""
  code

  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  is_shipping_enabled

  """column name"""
  name

  """column name"""
  updated_at
}

"""
input type for updating data in table "countries"
"""
input countries_set_input {
  code: String
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  is_shipping_enabled: Boolean
  name: String
  updated_at: timestamptz
}

"""
Streaming cursor of the table "countries"
"""
input countries_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: countries_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input countries_stream_cursor_value_input {
  code: String
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  is_shipping_enabled: Boolean
  name: String
  updated_at: timestamptz
}

"""
update columns of table "countries"
"""
enum countries_update_column {
  """column name"""
  code

  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  is_shipping_enabled

  """column name"""
  name

  """column name"""
  updated_at
}

input countries_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: countries_set_input

  """filter the rows which have to be updated"""
  where: countries_bool_exp!
}

"""
columns and relationships of "coupons"
"""
type coupons {
  code: String!
  created_at: timestamptz!
  deleted_at: timestamptz
  discount_type: String!
  discount_value: numeric!
  expires_at: timestamptz
  id: uuid!
  max_uses: Int
  min_order_amount: numeric
  starts_at: timestamptz!
  store_id: uuid
  updated_at: timestamptz!
  used_count: Int!
}

"""
aggregated selection of "coupons"
"""
type coupons_aggregate {
  aggregate: coupons_aggregate_fields
  nodes: [coupons!]!
}

"""
aggregate fields of "coupons"
"""
type coupons_aggregate_fields {
  avg: coupons_avg_fields
  count(columns: [coupons_select_column!], distinct: Boolean): Int!
  max: coupons_max_fields
  min: coupons_min_fields
  stddev: coupons_stddev_fields
  stddev_pop: coupons_stddev_pop_fields
  stddev_samp: coupons_stddev_samp_fields
  sum: coupons_sum_fields
  var_pop: coupons_var_pop_fields
  var_samp: coupons_var_samp_fields
  variance: coupons_variance_fields
}

"""aggregate avg on columns"""
type coupons_avg_fields {
  discount_value: Float
  max_uses: Float
  min_order_amount: Float
  used_count: Float
}

"""
Boolean expression to filter rows from the table "coupons". All fields are combined with a logical 'AND'.
"""
input coupons_bool_exp {
  _and: [coupons_bool_exp!]
  _not: coupons_bool_exp
  _or: [coupons_bool_exp!]
  code: String_comparison_exp
  created_at: timestamptz_comparison_exp
  deleted_at: timestamptz_comparison_exp
  discount_type: String_comparison_exp
  discount_value: numeric_comparison_exp
  expires_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  max_uses: Int_comparison_exp
  min_order_amount: numeric_comparison_exp
  starts_at: timestamptz_comparison_exp
  store_id: uuid_comparison_exp
  updated_at: timestamptz_comparison_exp
  used_count: Int_comparison_exp
}

"""
unique or primary key constraints on table "coupons"
"""
enum coupons_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  coupons_pkey
}

"""
input type for incrementing numeric columns in table "coupons"
"""
input coupons_inc_input {
  discount_value: numeric
  max_uses: Int
  min_order_amount: numeric
  used_count: Int
}

"""
input type for inserting data into table "coupons"
"""
input coupons_insert_input {
  code: String
  created_at: timestamptz
  deleted_at: timestamptz
  discount_type: String
  discount_value: numeric
  expires_at: timestamptz
  id: uuid
  max_uses: Int
  min_order_amount: numeric
  starts_at: timestamptz
  store_id: uuid
  updated_at: timestamptz
  used_count: Int
}

"""aggregate max on columns"""
type coupons_max_fields {
  code: String
  created_at: timestamptz
  deleted_at: timestamptz
  discount_type: String
  discount_value: numeric
  expires_at: timestamptz
  id: uuid
  max_uses: Int
  min_order_amount: numeric
  starts_at: timestamptz
  store_id: uuid
  updated_at: timestamptz
  used_count: Int
}

"""aggregate min on columns"""
type coupons_min_fields {
  code: String
  created_at: timestamptz
  deleted_at: timestamptz
  discount_type: String
  discount_value: numeric
  expires_at: timestamptz
  id: uuid
  max_uses: Int
  min_order_amount: numeric
  starts_at: timestamptz
  store_id: uuid
  updated_at: timestamptz
  used_count: Int
}

"""
response of any mutation on the table "coupons"
"""
type coupons_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [coupons!]!
}

"""
on_conflict condition type for table "coupons"
"""
input coupons_on_conflict {
  constraint: coupons_constraint!
  update_columns: [coupons_update_column!]! = []
  where: coupons_bool_exp
}

"""Ordering options when selecting data from "coupons"."""
input coupons_order_by {
  code: order_by
  created_at: order_by
  deleted_at: order_by
  discount_type: order_by
  discount_value: order_by
  expires_at: order_by
  id: order_by
  max_uses: order_by
  min_order_amount: order_by
  starts_at: order_by
  store_id: order_by
  updated_at: order_by
  used_count: order_by
}

"""primary key columns input for table: coupons"""
input coupons_pk_columns_input {
  id: uuid!
}

"""
select columns of table "coupons"
"""
enum coupons_select_column {
  """column name"""
  code

  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  discount_type

  """column name"""
  discount_value

  """column name"""
  expires_at

  """column name"""
  id

  """column name"""
  max_uses

  """column name"""
  min_order_amount

  """column name"""
  starts_at

  """column name"""
  store_id

  """column name"""
  updated_at

  """column name"""
  used_count
}

"""
input type for updating data in table "coupons"
"""
input coupons_set_input {
  code: String
  created_at: timestamptz
  deleted_at: timestamptz
  discount_type: String
  discount_value: numeric
  expires_at: timestamptz
  id: uuid
  max_uses: Int
  min_order_amount: numeric
  starts_at: timestamptz
  store_id: uuid
  updated_at: timestamptz
  used_count: Int
}

"""aggregate stddev on columns"""
type coupons_stddev_fields {
  discount_value: Float
  max_uses: Float
  min_order_amount: Float
  used_count: Float
}

"""aggregate stddev_pop on columns"""
type coupons_stddev_pop_fields {
  discount_value: Float
  max_uses: Float
  min_order_amount: Float
  used_count: Float
}

"""aggregate stddev_samp on columns"""
type coupons_stddev_samp_fields {
  discount_value: Float
  max_uses: Float
  min_order_amount: Float
  used_count: Float
}

"""
Streaming cursor of the table "coupons"
"""
input coupons_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: coupons_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input coupons_stream_cursor_value_input {
  code: String
  created_at: timestamptz
  deleted_at: timestamptz
  discount_type: String
  discount_value: numeric
  expires_at: timestamptz
  id: uuid
  max_uses: Int
  min_order_amount: numeric
  starts_at: timestamptz
  store_id: uuid
  updated_at: timestamptz
  used_count: Int
}

"""aggregate sum on columns"""
type coupons_sum_fields {
  discount_value: numeric
  max_uses: Int
  min_order_amount: numeric
  used_count: Int
}

"""
update columns of table "coupons"
"""
enum coupons_update_column {
  """column name"""
  code

  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  discount_type

  """column name"""
  discount_value

  """column name"""
  expires_at

  """column name"""
  id

  """column name"""
  max_uses

  """column name"""
  min_order_amount

  """column name"""
  starts_at

  """column name"""
  store_id

  """column name"""
  updated_at

  """column name"""
  used_count
}

input coupons_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: coupons_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: coupons_set_input

  """filter the rows which have to be updated"""
  where: coupons_bool_exp!
}

"""aggregate var_pop on columns"""
type coupons_var_pop_fields {
  discount_value: Float
  max_uses: Float
  min_order_amount: Float
  used_count: Float
}

"""aggregate var_samp on columns"""
type coupons_var_samp_fields {
  discount_value: Float
  max_uses: Float
  min_order_amount: Float
  used_count: Float
}

"""aggregate variance on columns"""
type coupons_variance_fields {
  discount_value: Float
  max_uses: Float
  min_order_amount: Float
  used_count: Float
}

"""
columns and relationships of "currencies"
"""
type currencies {
  code: String!
  created_at: timestamptz!
  decimal_places: Int!
  deleted_at: timestamptz
  id: uuid!
  name: String!
  symbol: String!
  updated_at: timestamptz!
}

"""
aggregated selection of "currencies"
"""
type currencies_aggregate {
  aggregate: currencies_aggregate_fields
  nodes: [currencies!]!
}

"""
aggregate fields of "currencies"
"""
type currencies_aggregate_fields {
  avg: currencies_avg_fields
  count(columns: [currencies_select_column!], distinct: Boolean): Int!
  max: currencies_max_fields
  min: currencies_min_fields
  stddev: currencies_stddev_fields
  stddev_pop: currencies_stddev_pop_fields
  stddev_samp: currencies_stddev_samp_fields
  sum: currencies_sum_fields
  var_pop: currencies_var_pop_fields
  var_samp: currencies_var_samp_fields
  variance: currencies_variance_fields
}

"""aggregate avg on columns"""
type currencies_avg_fields {
  decimal_places: Float
}

"""
Boolean expression to filter rows from the table "currencies". All fields are combined with a logical 'AND'.
"""
input currencies_bool_exp {
  _and: [currencies_bool_exp!]
  _not: currencies_bool_exp
  _or: [currencies_bool_exp!]
  code: String_comparison_exp
  created_at: timestamptz_comparison_exp
  decimal_places: Int_comparison_exp
  deleted_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
  symbol: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "currencies"
"""
enum currencies_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  currencies_pkey
}

"""
input type for incrementing numeric columns in table "currencies"
"""
input currencies_inc_input {
  decimal_places: Int
}

"""
input type for inserting data into table "currencies"
"""
input currencies_insert_input {
  code: String
  created_at: timestamptz
  decimal_places: Int
  deleted_at: timestamptz
  id: uuid
  name: String
  symbol: String
  updated_at: timestamptz
}

"""aggregate max on columns"""
type currencies_max_fields {
  code: String
  created_at: timestamptz
  decimal_places: Int
  deleted_at: timestamptz
  id: uuid
  name: String
  symbol: String
  updated_at: timestamptz
}

"""aggregate min on columns"""
type currencies_min_fields {
  code: String
  created_at: timestamptz
  decimal_places: Int
  deleted_at: timestamptz
  id: uuid
  name: String
  symbol: String
  updated_at: timestamptz
}

"""
response of any mutation on the table "currencies"
"""
type currencies_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [currencies!]!
}

"""
on_conflict condition type for table "currencies"
"""
input currencies_on_conflict {
  constraint: currencies_constraint!
  update_columns: [currencies_update_column!]! = []
  where: currencies_bool_exp
}

"""Ordering options when selecting data from "currencies"."""
input currencies_order_by {
  code: order_by
  created_at: order_by
  decimal_places: order_by
  deleted_at: order_by
  id: order_by
  name: order_by
  symbol: order_by
  updated_at: order_by
}

"""primary key columns input for table: currencies"""
input currencies_pk_columns_input {
  id: uuid!
}

"""
select columns of table "currencies"
"""
enum currencies_select_column {
  """column name"""
  code

  """column name"""
  created_at

  """column name"""
  decimal_places

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  name

  """column name"""
  symbol

  """column name"""
  updated_at
}

"""
input type for updating data in table "currencies"
"""
input currencies_set_input {
  code: String
  created_at: timestamptz
  decimal_places: Int
  deleted_at: timestamptz
  id: uuid
  name: String
  symbol: String
  updated_at: timestamptz
}

"""aggregate stddev on columns"""
type currencies_stddev_fields {
  decimal_places: Float
}

"""aggregate stddev_pop on columns"""
type currencies_stddev_pop_fields {
  decimal_places: Float
}

"""aggregate stddev_samp on columns"""
type currencies_stddev_samp_fields {
  decimal_places: Float
}

"""
Streaming cursor of the table "currencies"
"""
input currencies_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: currencies_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input currencies_stream_cursor_value_input {
  code: String
  created_at: timestamptz
  decimal_places: Int
  deleted_at: timestamptz
  id: uuid
  name: String
  symbol: String
  updated_at: timestamptz
}

"""aggregate sum on columns"""
type currencies_sum_fields {
  decimal_places: Int
}

"""
update columns of table "currencies"
"""
enum currencies_update_column {
  """column name"""
  code

  """column name"""
  created_at

  """column name"""
  decimal_places

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  name

  """column name"""
  symbol

  """column name"""
  updated_at
}

input currencies_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: currencies_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: currencies_set_input

  """filter the rows which have to be updated"""
  where: currencies_bool_exp!
}

"""aggregate var_pop on columns"""
type currencies_var_pop_fields {
  decimal_places: Float
}

"""aggregate var_samp on columns"""
type currencies_var_samp_fields {
  decimal_places: Float
}

"""aggregate variance on columns"""
type currencies_variance_fields {
  decimal_places: Float
}

"""ordering argument of a cursor"""
enum cursor_ordering {
  """ascending ordering of the cursor"""
  ASC

  """descending ordering of the cursor"""
  DESC
}

"""
columns and relationships of "customer_addresses"
"""
type customer_addresses {
  city: String!
  country_id: uuid
  created_at: timestamptz!
  customer_id: uuid
  deleted_at: timestamptz
  id: uuid!
  is_default: Boolean!
  label: String!
  postal_code: String!
  state: String
  street: String!
  updated_at: timestamptz!
}

"""
aggregated selection of "customer_addresses"
"""
type customer_addresses_aggregate {
  aggregate: customer_addresses_aggregate_fields
  nodes: [customer_addresses!]!
}

"""
aggregate fields of "customer_addresses"
"""
type customer_addresses_aggregate_fields {
  count(columns: [customer_addresses_select_column!], distinct: Boolean): Int!
  max: customer_addresses_max_fields
  min: customer_addresses_min_fields
}

"""
Boolean expression to filter rows from the table "customer_addresses". All fields are combined with a logical 'AND'.
"""
input customer_addresses_bool_exp {
  _and: [customer_addresses_bool_exp!]
  _not: customer_addresses_bool_exp
  _or: [customer_addresses_bool_exp!]
  city: String_comparison_exp
  country_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  customer_id: uuid_comparison_exp
  deleted_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  is_default: Boolean_comparison_exp
  label: String_comparison_exp
  postal_code: String_comparison_exp
  state: String_comparison_exp
  street: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "customer_addresses"
"""
enum customer_addresses_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  customer_addresses_pkey
}

"""
input type for inserting data into table "customer_addresses"
"""
input customer_addresses_insert_input {
  city: String
  country_id: uuid
  created_at: timestamptz
  customer_id: uuid
  deleted_at: timestamptz
  id: uuid
  is_default: Boolean
  label: String
  postal_code: String
  state: String
  street: String
  updated_at: timestamptz
}

"""aggregate max on columns"""
type customer_addresses_max_fields {
  city: String
  country_id: uuid
  created_at: timestamptz
  customer_id: uuid
  deleted_at: timestamptz
  id: uuid
  label: String
  postal_code: String
  state: String
  street: String
  updated_at: timestamptz
}

"""aggregate min on columns"""
type customer_addresses_min_fields {
  city: String
  country_id: uuid
  created_at: timestamptz
  customer_id: uuid
  deleted_at: timestamptz
  id: uuid
  label: String
  postal_code: String
  state: String
  street: String
  updated_at: timestamptz
}

"""
response of any mutation on the table "customer_addresses"
"""
type customer_addresses_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [customer_addresses!]!
}

"""
on_conflict condition type for table "customer_addresses"
"""
input customer_addresses_on_conflict {
  constraint: customer_addresses_constraint!
  update_columns: [customer_addresses_update_column!]! = []
  where: customer_addresses_bool_exp
}

"""Ordering options when selecting data from "customer_addresses"."""
input customer_addresses_order_by {
  city: order_by
  country_id: order_by
  created_at: order_by
  customer_id: order_by
  deleted_at: order_by
  id: order_by
  is_default: order_by
  label: order_by
  postal_code: order_by
  state: order_by
  street: order_by
  updated_at: order_by
}

"""primary key columns input for table: customer_addresses"""
input customer_addresses_pk_columns_input {
  id: uuid!
}

"""
select columns of table "customer_addresses"
"""
enum customer_addresses_select_column {
  """column name"""
  city

  """column name"""
  country_id

  """column name"""
  created_at

  """column name"""
  customer_id

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  is_default

  """column name"""
  label

  """column name"""
  postal_code

  """column name"""
  state

  """column name"""
  street

  """column name"""
  updated_at
}

"""
input type for updating data in table "customer_addresses"
"""
input customer_addresses_set_input {
  city: String
  country_id: uuid
  created_at: timestamptz
  customer_id: uuid
  deleted_at: timestamptz
  id: uuid
  is_default: Boolean
  label: String
  postal_code: String
  state: String
  street: String
  updated_at: timestamptz
}

"""
Streaming cursor of the table "customer_addresses"
"""
input customer_addresses_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: customer_addresses_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input customer_addresses_stream_cursor_value_input {
  city: String
  country_id: uuid
  created_at: timestamptz
  customer_id: uuid
  deleted_at: timestamptz
  id: uuid
  is_default: Boolean
  label: String
  postal_code: String
  state: String
  street: String
  updated_at: timestamptz
}

"""
update columns of table "customer_addresses"
"""
enum customer_addresses_update_column {
  """column name"""
  city

  """column name"""
  country_id

  """column name"""
  created_at

  """column name"""
  customer_id

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  is_default

  """column name"""
  label

  """column name"""
  postal_code

  """column name"""
  state

  """column name"""
  street

  """column name"""
  updated_at
}

input customer_addresses_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: customer_addresses_set_input

  """filter the rows which have to be updated"""
  where: customer_addresses_bool_exp!
}

"""
columns and relationships of "customer_stores"
"""
type customer_stores {
  created_at: timestamptz!
  customer_id: uuid
  deleted_at: timestamptz
  id: uuid!
  is_favorite: Boolean!
  store_id: uuid
  updated_at: timestamptz!
}

"""
aggregated selection of "customer_stores"
"""
type customer_stores_aggregate {
  aggregate: customer_stores_aggregate_fields
  nodes: [customer_stores!]!
}

"""
aggregate fields of "customer_stores"
"""
type customer_stores_aggregate_fields {
  count(columns: [customer_stores_select_column!], distinct: Boolean): Int!
  max: customer_stores_max_fields
  min: customer_stores_min_fields
}

"""
Boolean expression to filter rows from the table "customer_stores". All fields are combined with a logical 'AND'.
"""
input customer_stores_bool_exp {
  _and: [customer_stores_bool_exp!]
  _not: customer_stores_bool_exp
  _or: [customer_stores_bool_exp!]
  created_at: timestamptz_comparison_exp
  customer_id: uuid_comparison_exp
  deleted_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  is_favorite: Boolean_comparison_exp
  store_id: uuid_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "customer_stores"
"""
enum customer_stores_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  customer_stores_pkey
}

"""
input type for inserting data into table "customer_stores"
"""
input customer_stores_insert_input {
  created_at: timestamptz
  customer_id: uuid
  deleted_at: timestamptz
  id: uuid
  is_favorite: Boolean
  store_id: uuid
  updated_at: timestamptz
}

"""aggregate max on columns"""
type customer_stores_max_fields {
  created_at: timestamptz
  customer_id: uuid
  deleted_at: timestamptz
  id: uuid
  store_id: uuid
  updated_at: timestamptz
}

"""aggregate min on columns"""
type customer_stores_min_fields {
  created_at: timestamptz
  customer_id: uuid
  deleted_at: timestamptz
  id: uuid
  store_id: uuid
  updated_at: timestamptz
}

"""
response of any mutation on the table "customer_stores"
"""
type customer_stores_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [customer_stores!]!
}

"""
on_conflict condition type for table "customer_stores"
"""
input customer_stores_on_conflict {
  constraint: customer_stores_constraint!
  update_columns: [customer_stores_update_column!]! = []
  where: customer_stores_bool_exp
}

"""Ordering options when selecting data from "customer_stores"."""
input customer_stores_order_by {
  created_at: order_by
  customer_id: order_by
  deleted_at: order_by
  id: order_by
  is_favorite: order_by
  store_id: order_by
  updated_at: order_by
}

"""primary key columns input for table: customer_stores"""
input customer_stores_pk_columns_input {
  id: uuid!
}

"""
select columns of table "customer_stores"
"""
enum customer_stores_select_column {
  """column name"""
  created_at

  """column name"""
  customer_id

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  is_favorite

  """column name"""
  store_id

  """column name"""
  updated_at
}

"""
input type for updating data in table "customer_stores"
"""
input customer_stores_set_input {
  created_at: timestamptz
  customer_id: uuid
  deleted_at: timestamptz
  id: uuid
  is_favorite: Boolean
  store_id: uuid
  updated_at: timestamptz
}

"""
Streaming cursor of the table "customer_stores"
"""
input customer_stores_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: customer_stores_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input customer_stores_stream_cursor_value_input {
  created_at: timestamptz
  customer_id: uuid
  deleted_at: timestamptz
  id: uuid
  is_favorite: Boolean
  store_id: uuid
  updated_at: timestamptz
}

"""
update columns of table "customer_stores"
"""
enum customer_stores_update_column {
  """column name"""
  created_at

  """column name"""
  customer_id

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  is_favorite

  """column name"""
  store_id

  """column name"""
  updated_at
}

input customer_stores_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: customer_stores_set_input

  """filter the rows which have to be updated"""
  where: customer_stores_bool_exp!
}

"""
columns and relationships of "customers"
"""
type customers {
  created_at: timestamptz!
  deleted_at: timestamptz
  email: String!
  first_name: String!
  id: uuid!
  last_name: String!
  phone: String
  store_id: uuid
  updated_at: timestamptz!
}

"""
aggregated selection of "customers"
"""
type customers_aggregate {
  aggregate: customers_aggregate_fields
  nodes: [customers!]!
}

"""
aggregate fields of "customers"
"""
type customers_aggregate_fields {
  count(columns: [customers_select_column!], distinct: Boolean): Int!
  max: customers_max_fields
  min: customers_min_fields
}

"""
Boolean expression to filter rows from the table "customers". All fields are combined with a logical 'AND'.
"""
input customers_bool_exp {
  _and: [customers_bool_exp!]
  _not: customers_bool_exp
  _or: [customers_bool_exp!]
  created_at: timestamptz_comparison_exp
  deleted_at: timestamptz_comparison_exp
  email: String_comparison_exp
  first_name: String_comparison_exp
  id: uuid_comparison_exp
  last_name: String_comparison_exp
  phone: String_comparison_exp
  store_id: uuid_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "customers"
"""
enum customers_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  customers_pkey
}

"""
input type for inserting data into table "customers"
"""
input customers_insert_input {
  created_at: timestamptz
  deleted_at: timestamptz
  email: String
  first_name: String
  id: uuid
  last_name: String
  phone: String
  store_id: uuid
  updated_at: timestamptz
}

"""aggregate max on columns"""
type customers_max_fields {
  created_at: timestamptz
  deleted_at: timestamptz
  email: String
  first_name: String
  id: uuid
  last_name: String
  phone: String
  store_id: uuid
  updated_at: timestamptz
}

"""aggregate min on columns"""
type customers_min_fields {
  created_at: timestamptz
  deleted_at: timestamptz
  email: String
  first_name: String
  id: uuid
  last_name: String
  phone: String
  store_id: uuid
  updated_at: timestamptz
}

"""
response of any mutation on the table "customers"
"""
type customers_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [customers!]!
}

"""
on_conflict condition type for table "customers"
"""
input customers_on_conflict {
  constraint: customers_constraint!
  update_columns: [customers_update_column!]! = []
  where: customers_bool_exp
}

"""Ordering options when selecting data from "customers"."""
input customers_order_by {
  created_at: order_by
  deleted_at: order_by
  email: order_by
  first_name: order_by
  id: order_by
  last_name: order_by
  phone: order_by
  store_id: order_by
  updated_at: order_by
}

"""primary key columns input for table: customers"""
input customers_pk_columns_input {
  id: uuid!
}

"""
select columns of table "customers"
"""
enum customers_select_column {
  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  email

  """column name"""
  first_name

  """column name"""
  id

  """column name"""
  last_name

  """column name"""
  phone

  """column name"""
  store_id

  """column name"""
  updated_at
}

"""
input type for updating data in table "customers"
"""
input customers_set_input {
  created_at: timestamptz
  deleted_at: timestamptz
  email: String
  first_name: String
  id: uuid
  last_name: String
  phone: String
  store_id: uuid
  updated_at: timestamptz
}

"""
Streaming cursor of the table "customers"
"""
input customers_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: customers_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input customers_stream_cursor_value_input {
  created_at: timestamptz
  deleted_at: timestamptz
  email: String
  first_name: String
  id: uuid
  last_name: String
  phone: String
  store_id: uuid
  updated_at: timestamptz
}

"""
update columns of table "customers"
"""
enum customers_update_column {
  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  email

  """column name"""
  first_name

  """column name"""
  id

  """column name"""
  last_name

  """column name"""
  phone

  """column name"""
  store_id

  """column name"""
  updated_at
}

input customers_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: customers_set_input

  """filter the rows which have to be updated"""
  where: customers_bool_exp!
}

scalar date

"""
Boolean expression to compare columns of type "date". All fields are combined with logical 'AND'.
"""
input date_comparison_exp {
  _eq: date
  _gt: date
  _gte: date
  _in: [date!]
  _is_null: Boolean
  _lt: date
  _lte: date
  _neq: date
  _nin: [date!]
}

"""
columns and relationships of "districts"
"""
type districts {
  code: String!
  created_at: timestamptz!
  deleted_at: timestamptz
  id: uuid!
  name: String!
  region_id: uuid
  updated_at: timestamptz!
}

"""
aggregated selection of "districts"
"""
type districts_aggregate {
  aggregate: districts_aggregate_fields
  nodes: [districts!]!
}

"""
aggregate fields of "districts"
"""
type districts_aggregate_fields {
  count(columns: [districts_select_column!], distinct: Boolean): Int!
  max: districts_max_fields
  min: districts_min_fields
}

"""
Boolean expression to filter rows from the table "districts". All fields are combined with a logical 'AND'.
"""
input districts_bool_exp {
  _and: [districts_bool_exp!]
  _not: districts_bool_exp
  _or: [districts_bool_exp!]
  code: String_comparison_exp
  created_at: timestamptz_comparison_exp
  deleted_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
  region_id: uuid_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "districts"
"""
enum districts_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  districts_pkey
}

"""
input type for inserting data into table "districts"
"""
input districts_insert_input {
  code: String
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  name: String
  region_id: uuid
  updated_at: timestamptz
}

"""aggregate max on columns"""
type districts_max_fields {
  code: String
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  name: String
  region_id: uuid
  updated_at: timestamptz
}

"""aggregate min on columns"""
type districts_min_fields {
  code: String
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  name: String
  region_id: uuid
  updated_at: timestamptz
}

"""
response of any mutation on the table "districts"
"""
type districts_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [districts!]!
}

"""
on_conflict condition type for table "districts"
"""
input districts_on_conflict {
  constraint: districts_constraint!
  update_columns: [districts_update_column!]! = []
  where: districts_bool_exp
}

"""Ordering options when selecting data from "districts"."""
input districts_order_by {
  code: order_by
  created_at: order_by
  deleted_at: order_by
  id: order_by
  name: order_by
  region_id: order_by
  updated_at: order_by
}

"""primary key columns input for table: districts"""
input districts_pk_columns_input {
  id: uuid!
}

"""
select columns of table "districts"
"""
enum districts_select_column {
  """column name"""
  code

  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  name

  """column name"""
  region_id

  """column name"""
  updated_at
}

"""
input type for updating data in table "districts"
"""
input districts_set_input {
  code: String
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  name: String
  region_id: uuid
  updated_at: timestamptz
}

"""
Streaming cursor of the table "districts"
"""
input districts_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: districts_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input districts_stream_cursor_value_input {
  code: String
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  name: String
  region_id: uuid
  updated_at: timestamptz
}

"""
update columns of table "districts"
"""
enum districts_update_column {
  """column name"""
  code

  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  name

  """column name"""
  region_id

  """column name"""
  updated_at
}

input districts_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: districts_set_input

  """filter the rows which have to be updated"""
  where: districts_bool_exp!
}

"""
columns and relationships of "ec_categories"
"""
type ec_categories {
  created_at: timestamptz!
  deleted_at: timestamptz
  description: String
  id: uuid!
  image_url: String
  name: String!
  parent_id: uuid
  slug: String!
  sort_order: Int!
  store_id: uuid
  updated_at: timestamptz!
}

"""
aggregated selection of "ec_categories"
"""
type ec_categories_aggregate {
  aggregate: ec_categories_aggregate_fields
  nodes: [ec_categories!]!
}

"""
aggregate fields of "ec_categories"
"""
type ec_categories_aggregate_fields {
  avg: ec_categories_avg_fields
  count(columns: [ec_categories_select_column!], distinct: Boolean): Int!
  max: ec_categories_max_fields
  min: ec_categories_min_fields
  stddev: ec_categories_stddev_fields
  stddev_pop: ec_categories_stddev_pop_fields
  stddev_samp: ec_categories_stddev_samp_fields
  sum: ec_categories_sum_fields
  var_pop: ec_categories_var_pop_fields
  var_samp: ec_categories_var_samp_fields
  variance: ec_categories_variance_fields
}

"""aggregate avg on columns"""
type ec_categories_avg_fields {
  sort_order: Float
}

"""
Boolean expression to filter rows from the table "ec_categories". All fields are combined with a logical 'AND'.
"""
input ec_categories_bool_exp {
  _and: [ec_categories_bool_exp!]
  _not: ec_categories_bool_exp
  _or: [ec_categories_bool_exp!]
  created_at: timestamptz_comparison_exp
  deleted_at: timestamptz_comparison_exp
  description: String_comparison_exp
  id: uuid_comparison_exp
  image_url: String_comparison_exp
  name: String_comparison_exp
  parent_id: uuid_comparison_exp
  slug: String_comparison_exp
  sort_order: Int_comparison_exp
  store_id: uuid_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "ec_categories"
"""
enum ec_categories_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  ec_categories_pkey
}

"""
input type for incrementing numeric columns in table "ec_categories"
"""
input ec_categories_inc_input {
  sort_order: Int
}

"""
input type for inserting data into table "ec_categories"
"""
input ec_categories_insert_input {
  created_at: timestamptz
  deleted_at: timestamptz
  description: String
  id: uuid
  image_url: String
  name: String
  parent_id: uuid
  slug: String
  sort_order: Int
  store_id: uuid
  updated_at: timestamptz
}

"""aggregate max on columns"""
type ec_categories_max_fields {
  created_at: timestamptz
  deleted_at: timestamptz
  description: String
  id: uuid
  image_url: String
  name: String
  parent_id: uuid
  slug: String
  sort_order: Int
  store_id: uuid
  updated_at: timestamptz
}

"""aggregate min on columns"""
type ec_categories_min_fields {
  created_at: timestamptz
  deleted_at: timestamptz
  description: String
  id: uuid
  image_url: String
  name: String
  parent_id: uuid
  slug: String
  sort_order: Int
  store_id: uuid
  updated_at: timestamptz
}

"""
response of any mutation on the table "ec_categories"
"""
type ec_categories_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [ec_categories!]!
}

"""
on_conflict condition type for table "ec_categories"
"""
input ec_categories_on_conflict {
  constraint: ec_categories_constraint!
  update_columns: [ec_categories_update_column!]! = []
  where: ec_categories_bool_exp
}

"""Ordering options when selecting data from "ec_categories"."""
input ec_categories_order_by {
  created_at: order_by
  deleted_at: order_by
  description: order_by
  id: order_by
  image_url: order_by
  name: order_by
  parent_id: order_by
  slug: order_by
  sort_order: order_by
  store_id: order_by
  updated_at: order_by
}

"""primary key columns input for table: ec_categories"""
input ec_categories_pk_columns_input {
  id: uuid!
}

"""
select columns of table "ec_categories"
"""
enum ec_categories_select_column {
  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  description

  """column name"""
  id

  """column name"""
  image_url

  """column name"""
  name

  """column name"""
  parent_id

  """column name"""
  slug

  """column name"""
  sort_order

  """column name"""
  store_id

  """column name"""
  updated_at
}

"""
input type for updating data in table "ec_categories"
"""
input ec_categories_set_input {
  created_at: timestamptz
  deleted_at: timestamptz
  description: String
  id: uuid
  image_url: String
  name: String
  parent_id: uuid
  slug: String
  sort_order: Int
  store_id: uuid
  updated_at: timestamptz
}

"""aggregate stddev on columns"""
type ec_categories_stddev_fields {
  sort_order: Float
}

"""aggregate stddev_pop on columns"""
type ec_categories_stddev_pop_fields {
  sort_order: Float
}

"""aggregate stddev_samp on columns"""
type ec_categories_stddev_samp_fields {
  sort_order: Float
}

"""
Streaming cursor of the table "ec_categories"
"""
input ec_categories_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: ec_categories_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input ec_categories_stream_cursor_value_input {
  created_at: timestamptz
  deleted_at: timestamptz
  description: String
  id: uuid
  image_url: String
  name: String
  parent_id: uuid
  slug: String
  sort_order: Int
  store_id: uuid
  updated_at: timestamptz
}

"""aggregate sum on columns"""
type ec_categories_sum_fields {
  sort_order: Int
}

"""
update columns of table "ec_categories"
"""
enum ec_categories_update_column {
  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  description

  """column name"""
  id

  """column name"""
  image_url

  """column name"""
  name

  """column name"""
  parent_id

  """column name"""
  slug

  """column name"""
  sort_order

  """column name"""
  store_id

  """column name"""
  updated_at
}

input ec_categories_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: ec_categories_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: ec_categories_set_input

  """filter the rows which have to be updated"""
  where: ec_categories_bool_exp!
}

"""aggregate var_pop on columns"""
type ec_categories_var_pop_fields {
  sort_order: Float
}

"""aggregate var_samp on columns"""
type ec_categories_var_samp_fields {
  sort_order: Float
}

"""aggregate variance on columns"""
type ec_categories_variance_fields {
  sort_order: Float
}

"""
columns and relationships of "follows"
"""
type follows {
  created_at: timestamptz!
  deleted_at: timestamptz
  follower_id: uuid
  following_id: uuid
  id: uuid!
  is_approved: Boolean!
  updated_at: timestamptz!
}

"""
aggregated selection of "follows"
"""
type follows_aggregate {
  aggregate: follows_aggregate_fields
  nodes: [follows!]!
}

"""
aggregate fields of "follows"
"""
type follows_aggregate_fields {
  count(columns: [follows_select_column!], distinct: Boolean): Int!
  max: follows_max_fields
  min: follows_min_fields
}

"""
Boolean expression to filter rows from the table "follows". All fields are combined with a logical 'AND'.
"""
input follows_bool_exp {
  _and: [follows_bool_exp!]
  _not: follows_bool_exp
  _or: [follows_bool_exp!]
  created_at: timestamptz_comparison_exp
  deleted_at: timestamptz_comparison_exp
  follower_id: uuid_comparison_exp
  following_id: uuid_comparison_exp
  id: uuid_comparison_exp
  is_approved: Boolean_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "follows"
"""
enum follows_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  follows_pkey
}

"""
input type for inserting data into table "follows"
"""
input follows_insert_input {
  created_at: timestamptz
  deleted_at: timestamptz
  follower_id: uuid
  following_id: uuid
  id: uuid
  is_approved: Boolean
  updated_at: timestamptz
}

"""aggregate max on columns"""
type follows_max_fields {
  created_at: timestamptz
  deleted_at: timestamptz
  follower_id: uuid
  following_id: uuid
  id: uuid
  updated_at: timestamptz
}

"""aggregate min on columns"""
type follows_min_fields {
  created_at: timestamptz
  deleted_at: timestamptz
  follower_id: uuid
  following_id: uuid
  id: uuid
  updated_at: timestamptz
}

"""
response of any mutation on the table "follows"
"""
type follows_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [follows!]!
}

"""
on_conflict condition type for table "follows"
"""
input follows_on_conflict {
  constraint: follows_constraint!
  update_columns: [follows_update_column!]! = []
  where: follows_bool_exp
}

"""Ordering options when selecting data from "follows"."""
input follows_order_by {
  created_at: order_by
  deleted_at: order_by
  follower_id: order_by
  following_id: order_by
  id: order_by
  is_approved: order_by
  updated_at: order_by
}

"""primary key columns input for table: follows"""
input follows_pk_columns_input {
  id: uuid!
}

"""
select columns of table "follows"
"""
enum follows_select_column {
  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  follower_id

  """column name"""
  following_id

  """column name"""
  id

  """column name"""
  is_approved

  """column name"""
  updated_at
}

"""
input type for updating data in table "follows"
"""
input follows_set_input {
  created_at: timestamptz
  deleted_at: timestamptz
  follower_id: uuid
  following_id: uuid
  id: uuid
  is_approved: Boolean
  updated_at: timestamptz
}

"""
Streaming cursor of the table "follows"
"""
input follows_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: follows_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input follows_stream_cursor_value_input {
  created_at: timestamptz
  deleted_at: timestamptz
  follower_id: uuid
  following_id: uuid
  id: uuid
  is_approved: Boolean
  updated_at: timestamptz
}

"""
update columns of table "follows"
"""
enum follows_update_column {
  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  follower_id

  """column name"""
  following_id

  """column name"""
  id

  """column name"""
  is_approved

  """column name"""
  updated_at
}

input follows_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: follows_set_input

  """filter the rows which have to be updated"""
  where: follows_bool_exp!
}

"""
columns and relationships of "form_submissions"
"""
type form_submissions {
  created_at: timestamptz!
  data(
    """JSON select path"""
    path: String
  ): jsonb!
  deleted_at: timestamptz
  form_id: uuid
  id: uuid!
  ip_address: String
  updated_at: timestamptz!
  user_agent: String
}

"""
aggregated selection of "form_submissions"
"""
type form_submissions_aggregate {
  aggregate: form_submissions_aggregate_fields
  nodes: [form_submissions!]!
}

"""
aggregate fields of "form_submissions"
"""
type form_submissions_aggregate_fields {
  count(columns: [form_submissions_select_column!], distinct: Boolean): Int!
  max: form_submissions_max_fields
  min: form_submissions_min_fields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input form_submissions_append_input {
  data: jsonb
}

"""
Boolean expression to filter rows from the table "form_submissions". All fields are combined with a logical 'AND'.
"""
input form_submissions_bool_exp {
  _and: [form_submissions_bool_exp!]
  _not: form_submissions_bool_exp
  _or: [form_submissions_bool_exp!]
  created_at: timestamptz_comparison_exp
  data: jsonb_comparison_exp
  deleted_at: timestamptz_comparison_exp
  form_id: uuid_comparison_exp
  id: uuid_comparison_exp
  ip_address: String_comparison_exp
  updated_at: timestamptz_comparison_exp
  user_agent: String_comparison_exp
}

"""
unique or primary key constraints on table "form_submissions"
"""
enum form_submissions_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  form_submissions_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input form_submissions_delete_at_path_input {
  data: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input form_submissions_delete_elem_input {
  data: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input form_submissions_delete_key_input {
  data: String
}

"""
input type for inserting data into table "form_submissions"
"""
input form_submissions_insert_input {
  created_at: timestamptz
  data: jsonb
  deleted_at: timestamptz
  form_id: uuid
  id: uuid
  ip_address: String
  updated_at: timestamptz
  user_agent: String
}

"""aggregate max on columns"""
type form_submissions_max_fields {
  created_at: timestamptz
  deleted_at: timestamptz
  form_id: uuid
  id: uuid
  ip_address: String
  updated_at: timestamptz
  user_agent: String
}

"""aggregate min on columns"""
type form_submissions_min_fields {
  created_at: timestamptz
  deleted_at: timestamptz
  form_id: uuid
  id: uuid
  ip_address: String
  updated_at: timestamptz
  user_agent: String
}

"""
response of any mutation on the table "form_submissions"
"""
type form_submissions_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [form_submissions!]!
}

"""
on_conflict condition type for table "form_submissions"
"""
input form_submissions_on_conflict {
  constraint: form_submissions_constraint!
  update_columns: [form_submissions_update_column!]! = []
  where: form_submissions_bool_exp
}

"""Ordering options when selecting data from "form_submissions"."""
input form_submissions_order_by {
  created_at: order_by
  data: order_by
  deleted_at: order_by
  form_id: order_by
  id: order_by
  ip_address: order_by
  updated_at: order_by
  user_agent: order_by
}

"""primary key columns input for table: form_submissions"""
input form_submissions_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input form_submissions_prepend_input {
  data: jsonb
}

"""
select columns of table "form_submissions"
"""
enum form_submissions_select_column {
  """column name"""
  created_at

  """column name"""
  data

  """column name"""
  deleted_at

  """column name"""
  form_id

  """column name"""
  id

  """column name"""
  ip_address

  """column name"""
  updated_at

  """column name"""
  user_agent
}

"""
input type for updating data in table "form_submissions"
"""
input form_submissions_set_input {
  created_at: timestamptz
  data: jsonb
  deleted_at: timestamptz
  form_id: uuid
  id: uuid
  ip_address: String
  updated_at: timestamptz
  user_agent: String
}

"""
Streaming cursor of the table "form_submissions"
"""
input form_submissions_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: form_submissions_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input form_submissions_stream_cursor_value_input {
  created_at: timestamptz
  data: jsonb
  deleted_at: timestamptz
  form_id: uuid
  id: uuid
  ip_address: String
  updated_at: timestamptz
  user_agent: String
}

"""
update columns of table "form_submissions"
"""
enum form_submissions_update_column {
  """column name"""
  created_at

  """column name"""
  data

  """column name"""
  deleted_at

  """column name"""
  form_id

  """column name"""
  id

  """column name"""
  ip_address

  """column name"""
  updated_at

  """column name"""
  user_agent
}

input form_submissions_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: form_submissions_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: form_submissions_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: form_submissions_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: form_submissions_delete_key_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: form_submissions_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: form_submissions_set_input

  """filter the rows which have to be updated"""
  where: form_submissions_bool_exp!
}

"""
columns and relationships of "forms"
"""
type forms {
  created_at: timestamptz!
  deleted_at: timestamptz
  id: uuid!
  name: String!
  schema(
    """JSON select path"""
    path: String
  ): jsonb!
  site_id: uuid
  slug: String!
  success_message: String
  updated_at: timestamptz!
}

"""
aggregated selection of "forms"
"""
type forms_aggregate {
  aggregate: forms_aggregate_fields
  nodes: [forms!]!
}

"""
aggregate fields of "forms"
"""
type forms_aggregate_fields {
  count(columns: [forms_select_column!], distinct: Boolean): Int!
  max: forms_max_fields
  min: forms_min_fields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input forms_append_input {
  schema: jsonb
}

"""
Boolean expression to filter rows from the table "forms". All fields are combined with a logical 'AND'.
"""
input forms_bool_exp {
  _and: [forms_bool_exp!]
  _not: forms_bool_exp
  _or: [forms_bool_exp!]
  created_at: timestamptz_comparison_exp
  deleted_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
  schema: jsonb_comparison_exp
  site_id: uuid_comparison_exp
  slug: String_comparison_exp
  success_message: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "forms"
"""
enum forms_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  forms_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input forms_delete_at_path_input {
  schema: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input forms_delete_elem_input {
  schema: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input forms_delete_key_input {
  schema: String
}

"""
input type for inserting data into table "forms"
"""
input forms_insert_input {
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  name: String
  schema: jsonb
  site_id: uuid
  slug: String
  success_message: String
  updated_at: timestamptz
}

"""aggregate max on columns"""
type forms_max_fields {
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  name: String
  site_id: uuid
  slug: String
  success_message: String
  updated_at: timestamptz
}

"""aggregate min on columns"""
type forms_min_fields {
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  name: String
  site_id: uuid
  slug: String
  success_message: String
  updated_at: timestamptz
}

"""
response of any mutation on the table "forms"
"""
type forms_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [forms!]!
}

"""
on_conflict condition type for table "forms"
"""
input forms_on_conflict {
  constraint: forms_constraint!
  update_columns: [forms_update_column!]! = []
  where: forms_bool_exp
}

"""Ordering options when selecting data from "forms"."""
input forms_order_by {
  created_at: order_by
  deleted_at: order_by
  id: order_by
  name: order_by
  schema: order_by
  site_id: order_by
  slug: order_by
  success_message: order_by
  updated_at: order_by
}

"""primary key columns input for table: forms"""
input forms_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input forms_prepend_input {
  schema: jsonb
}

"""
select columns of table "forms"
"""
enum forms_select_column {
  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  name

  """column name"""
  schema

  """column name"""
  site_id

  """column name"""
  slug

  """column name"""
  success_message

  """column name"""
  updated_at
}

"""
input type for updating data in table "forms"
"""
input forms_set_input {
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  name: String
  schema: jsonb
  site_id: uuid
  slug: String
  success_message: String
  updated_at: timestamptz
}

"""
Streaming cursor of the table "forms"
"""
input forms_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: forms_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input forms_stream_cursor_value_input {
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  name: String
  schema: jsonb
  site_id: uuid
  slug: String
  success_message: String
  updated_at: timestamptz
}

"""
update columns of table "forms"
"""
enum forms_update_column {
  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  name

  """column name"""
  schema

  """column name"""
  site_id

  """column name"""
  slug

  """column name"""
  success_message

  """column name"""
  updated_at
}

input forms_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: forms_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: forms_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: forms_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: forms_delete_key_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: forms_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: forms_set_input

  """filter the rows which have to be updated"""
  where: forms_bool_exp!
}

"""
columns and relationships of "hashtags"
"""
type hashtags {
  created_at: timestamptz!
  deleted_at: timestamptz
  id: uuid!
  name: String!
  post_count: bigint!
  updated_at: timestamptz!
}

"""
aggregated selection of "hashtags"
"""
type hashtags_aggregate {
  aggregate: hashtags_aggregate_fields
  nodes: [hashtags!]!
}

"""
aggregate fields of "hashtags"
"""
type hashtags_aggregate_fields {
  avg: hashtags_avg_fields
  count(columns: [hashtags_select_column!], distinct: Boolean): Int!
  max: hashtags_max_fields
  min: hashtags_min_fields
  stddev: hashtags_stddev_fields
  stddev_pop: hashtags_stddev_pop_fields
  stddev_samp: hashtags_stddev_samp_fields
  sum: hashtags_sum_fields
  var_pop: hashtags_var_pop_fields
  var_samp: hashtags_var_samp_fields
  variance: hashtags_variance_fields
}

"""aggregate avg on columns"""
type hashtags_avg_fields {
  post_count: Float
}

"""
Boolean expression to filter rows from the table "hashtags". All fields are combined with a logical 'AND'.
"""
input hashtags_bool_exp {
  _and: [hashtags_bool_exp!]
  _not: hashtags_bool_exp
  _or: [hashtags_bool_exp!]
  created_at: timestamptz_comparison_exp
  deleted_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
  post_count: bigint_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "hashtags"
"""
enum hashtags_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  hashtags_pkey
}

"""
input type for incrementing numeric columns in table "hashtags"
"""
input hashtags_inc_input {
  post_count: bigint
}

"""
input type for inserting data into table "hashtags"
"""
input hashtags_insert_input {
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  name: String
  post_count: bigint
  updated_at: timestamptz
}

"""aggregate max on columns"""
type hashtags_max_fields {
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  name: String
  post_count: bigint
  updated_at: timestamptz
}

"""aggregate min on columns"""
type hashtags_min_fields {
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  name: String
  post_count: bigint
  updated_at: timestamptz
}

"""
response of any mutation on the table "hashtags"
"""
type hashtags_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [hashtags!]!
}

"""
on_conflict condition type for table "hashtags"
"""
input hashtags_on_conflict {
  constraint: hashtags_constraint!
  update_columns: [hashtags_update_column!]! = []
  where: hashtags_bool_exp
}

"""Ordering options when selecting data from "hashtags"."""
input hashtags_order_by {
  created_at: order_by
  deleted_at: order_by
  id: order_by
  name: order_by
  post_count: order_by
  updated_at: order_by
}

"""primary key columns input for table: hashtags"""
input hashtags_pk_columns_input {
  id: uuid!
}

"""
select columns of table "hashtags"
"""
enum hashtags_select_column {
  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  name

  """column name"""
  post_count

  """column name"""
  updated_at
}

"""
input type for updating data in table "hashtags"
"""
input hashtags_set_input {
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  name: String
  post_count: bigint
  updated_at: timestamptz
}

"""aggregate stddev on columns"""
type hashtags_stddev_fields {
  post_count: Float
}

"""aggregate stddev_pop on columns"""
type hashtags_stddev_pop_fields {
  post_count: Float
}

"""aggregate stddev_samp on columns"""
type hashtags_stddev_samp_fields {
  post_count: Float
}

"""
Streaming cursor of the table "hashtags"
"""
input hashtags_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: hashtags_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input hashtags_stream_cursor_value_input {
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  name: String
  post_count: bigint
  updated_at: timestamptz
}

"""aggregate sum on columns"""
type hashtags_sum_fields {
  post_count: bigint
}

"""
update columns of table "hashtags"
"""
enum hashtags_update_column {
  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  name

  """column name"""
  post_count

  """column name"""
  updated_at
}

input hashtags_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: hashtags_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: hashtags_set_input

  """filter the rows which have to be updated"""
  where: hashtags_bool_exp!
}

"""aggregate var_pop on columns"""
type hashtags_var_pop_fields {
  post_count: Float
}

"""aggregate var_samp on columns"""
type hashtags_var_samp_fields {
  post_count: Float
}

"""aggregate variance on columns"""
type hashtags_variance_fields {
  post_count: Float
}

"""
columns and relationships of "inventory_levels"
"""
type inventory_levels {
  created_at: timestamptz!
  deleted_at: timestamptz
  id: uuid!
  location_id: uuid
  quantity: Int!
  reserved: Int!
  updated_at: timestamptz!
  variant_id: uuid
}

"""
aggregated selection of "inventory_levels"
"""
type inventory_levels_aggregate {
  aggregate: inventory_levels_aggregate_fields
  nodes: [inventory_levels!]!
}

"""
aggregate fields of "inventory_levels"
"""
type inventory_levels_aggregate_fields {
  avg: inventory_levels_avg_fields
  count(columns: [inventory_levels_select_column!], distinct: Boolean): Int!
  max: inventory_levels_max_fields
  min: inventory_levels_min_fields
  stddev: inventory_levels_stddev_fields
  stddev_pop: inventory_levels_stddev_pop_fields
  stddev_samp: inventory_levels_stddev_samp_fields
  sum: inventory_levels_sum_fields
  var_pop: inventory_levels_var_pop_fields
  var_samp: inventory_levels_var_samp_fields
  variance: inventory_levels_variance_fields
}

"""aggregate avg on columns"""
type inventory_levels_avg_fields {
  quantity: Float
  reserved: Float
}

"""
Boolean expression to filter rows from the table "inventory_levels". All fields are combined with a logical 'AND'.
"""
input inventory_levels_bool_exp {
  _and: [inventory_levels_bool_exp!]
  _not: inventory_levels_bool_exp
  _or: [inventory_levels_bool_exp!]
  created_at: timestamptz_comparison_exp
  deleted_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  location_id: uuid_comparison_exp
  quantity: Int_comparison_exp
  reserved: Int_comparison_exp
  updated_at: timestamptz_comparison_exp
  variant_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "inventory_levels"
"""
enum inventory_levels_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  inventory_levels_pkey
}

"""
input type for incrementing numeric columns in table "inventory_levels"
"""
input inventory_levels_inc_input {
  quantity: Int
  reserved: Int
}

"""
input type for inserting data into table "inventory_levels"
"""
input inventory_levels_insert_input {
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  location_id: uuid
  quantity: Int
  reserved: Int
  updated_at: timestamptz
  variant_id: uuid
}

"""aggregate max on columns"""
type inventory_levels_max_fields {
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  location_id: uuid
  quantity: Int
  reserved: Int
  updated_at: timestamptz
  variant_id: uuid
}

"""aggregate min on columns"""
type inventory_levels_min_fields {
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  location_id: uuid
  quantity: Int
  reserved: Int
  updated_at: timestamptz
  variant_id: uuid
}

"""
response of any mutation on the table "inventory_levels"
"""
type inventory_levels_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [inventory_levels!]!
}

"""
on_conflict condition type for table "inventory_levels"
"""
input inventory_levels_on_conflict {
  constraint: inventory_levels_constraint!
  update_columns: [inventory_levels_update_column!]! = []
  where: inventory_levels_bool_exp
}

"""Ordering options when selecting data from "inventory_levels"."""
input inventory_levels_order_by {
  created_at: order_by
  deleted_at: order_by
  id: order_by
  location_id: order_by
  quantity: order_by
  reserved: order_by
  updated_at: order_by
  variant_id: order_by
}

"""primary key columns input for table: inventory_levels"""
input inventory_levels_pk_columns_input {
  id: uuid!
}

"""
select columns of table "inventory_levels"
"""
enum inventory_levels_select_column {
  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  location_id

  """column name"""
  quantity

  """column name"""
  reserved

  """column name"""
  updated_at

  """column name"""
  variant_id
}

"""
input type for updating data in table "inventory_levels"
"""
input inventory_levels_set_input {
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  location_id: uuid
  quantity: Int
  reserved: Int
  updated_at: timestamptz
  variant_id: uuid
}

"""aggregate stddev on columns"""
type inventory_levels_stddev_fields {
  quantity: Float
  reserved: Float
}

"""aggregate stddev_pop on columns"""
type inventory_levels_stddev_pop_fields {
  quantity: Float
  reserved: Float
}

"""aggregate stddev_samp on columns"""
type inventory_levels_stddev_samp_fields {
  quantity: Float
  reserved: Float
}

"""
Streaming cursor of the table "inventory_levels"
"""
input inventory_levels_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: inventory_levels_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input inventory_levels_stream_cursor_value_input {
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  location_id: uuid
  quantity: Int
  reserved: Int
  updated_at: timestamptz
  variant_id: uuid
}

"""aggregate sum on columns"""
type inventory_levels_sum_fields {
  quantity: Int
  reserved: Int
}

"""
update columns of table "inventory_levels"
"""
enum inventory_levels_update_column {
  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  location_id

  """column name"""
  quantity

  """column name"""
  reserved

  """column name"""
  updated_at

  """column name"""
  variant_id
}

input inventory_levels_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: inventory_levels_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: inventory_levels_set_input

  """filter the rows which have to be updated"""
  where: inventory_levels_bool_exp!
}

"""aggregate var_pop on columns"""
type inventory_levels_var_pop_fields {
  quantity: Float
  reserved: Float
}

"""aggregate var_samp on columns"""
type inventory_levels_var_samp_fields {
  quantity: Float
  reserved: Float
}

"""aggregate variance on columns"""
type inventory_levels_variance_fields {
  quantity: Float
  reserved: Float
}

"""
columns and relationships of "inventory_locations"
"""
type inventory_locations {
  address: String
  created_at: timestamptz!
  deleted_at: timestamptz
  id: uuid!
  is_active: Boolean!
  name: String!
  store_id: uuid
  updated_at: timestamptz!
}

"""
aggregated selection of "inventory_locations"
"""
type inventory_locations_aggregate {
  aggregate: inventory_locations_aggregate_fields
  nodes: [inventory_locations!]!
}

"""
aggregate fields of "inventory_locations"
"""
type inventory_locations_aggregate_fields {
  count(columns: [inventory_locations_select_column!], distinct: Boolean): Int!
  max: inventory_locations_max_fields
  min: inventory_locations_min_fields
}

"""
Boolean expression to filter rows from the table "inventory_locations". All fields are combined with a logical 'AND'.
"""
input inventory_locations_bool_exp {
  _and: [inventory_locations_bool_exp!]
  _not: inventory_locations_bool_exp
  _or: [inventory_locations_bool_exp!]
  address: String_comparison_exp
  created_at: timestamptz_comparison_exp
  deleted_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  is_active: Boolean_comparison_exp
  name: String_comparison_exp
  store_id: uuid_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "inventory_locations"
"""
enum inventory_locations_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  inventory_locations_pkey
}

"""
input type for inserting data into table "inventory_locations"
"""
input inventory_locations_insert_input {
  address: String
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  is_active: Boolean
  name: String
  store_id: uuid
  updated_at: timestamptz
}

"""aggregate max on columns"""
type inventory_locations_max_fields {
  address: String
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  name: String
  store_id: uuid
  updated_at: timestamptz
}

"""aggregate min on columns"""
type inventory_locations_min_fields {
  address: String
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  name: String
  store_id: uuid
  updated_at: timestamptz
}

"""
response of any mutation on the table "inventory_locations"
"""
type inventory_locations_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [inventory_locations!]!
}

"""
on_conflict condition type for table "inventory_locations"
"""
input inventory_locations_on_conflict {
  constraint: inventory_locations_constraint!
  update_columns: [inventory_locations_update_column!]! = []
  where: inventory_locations_bool_exp
}

"""Ordering options when selecting data from "inventory_locations"."""
input inventory_locations_order_by {
  address: order_by
  created_at: order_by
  deleted_at: order_by
  id: order_by
  is_active: order_by
  name: order_by
  store_id: order_by
  updated_at: order_by
}

"""primary key columns input for table: inventory_locations"""
input inventory_locations_pk_columns_input {
  id: uuid!
}

"""
select columns of table "inventory_locations"
"""
enum inventory_locations_select_column {
  """column name"""
  address

  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  is_active

  """column name"""
  name

  """column name"""
  store_id

  """column name"""
  updated_at
}

"""
input type for updating data in table "inventory_locations"
"""
input inventory_locations_set_input {
  address: String
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  is_active: Boolean
  name: String
  store_id: uuid
  updated_at: timestamptz
}

"""
Streaming cursor of the table "inventory_locations"
"""
input inventory_locations_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: inventory_locations_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input inventory_locations_stream_cursor_value_input {
  address: String
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  is_active: Boolean
  name: String
  store_id: uuid
  updated_at: timestamptz
}

"""
update columns of table "inventory_locations"
"""
enum inventory_locations_update_column {
  """column name"""
  address

  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  is_active

  """column name"""
  name

  """column name"""
  store_id

  """column name"""
  updated_at
}

input inventory_locations_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: inventory_locations_set_input

  """filter the rows which have to be updated"""
  where: inventory_locations_bool_exp!
}

scalar jsonb

input jsonb_cast_exp {
  String: String_comparison_exp
}

"""
Boolean expression to compare columns of type "jsonb". All fields are combined with logical 'AND'.
"""
input jsonb_comparison_exp {
  _cast: jsonb_cast_exp

  """is the column contained in the given json value"""
  _contained_in: jsonb

  """does the column contain the given json value at the top level"""
  _contains: jsonb
  _eq: jsonb
  _gt: jsonb
  _gte: jsonb

  """does the string exist as a top-level key in the column"""
  _has_key: String

  """do all of these strings exist as top-level keys in the column"""
  _has_keys_all: [String!]

  """do any of these strings exist as top-level keys in the column"""
  _has_keys_any: [String!]
  _in: [jsonb!]
  _is_null: Boolean
  _lt: jsonb
  _lte: jsonb
  _neq: jsonb
  _nin: [jsonb!]
}

"""
columns and relationships of "likes"
"""
type likes {
  created_at: timestamptz!
  deleted_at: timestamptz
  id: uuid!
  post_id: uuid
  updated_at: timestamptz!
  user_id: uuid
}

"""
aggregated selection of "likes"
"""
type likes_aggregate {
  aggregate: likes_aggregate_fields
  nodes: [likes!]!
}

"""
aggregate fields of "likes"
"""
type likes_aggregate_fields {
  count(columns: [likes_select_column!], distinct: Boolean): Int!
  max: likes_max_fields
  min: likes_min_fields
}

"""
Boolean expression to filter rows from the table "likes". All fields are combined with a logical 'AND'.
"""
input likes_bool_exp {
  _and: [likes_bool_exp!]
  _not: likes_bool_exp
  _or: [likes_bool_exp!]
  created_at: timestamptz_comparison_exp
  deleted_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  post_id: uuid_comparison_exp
  updated_at: timestamptz_comparison_exp
  user_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "likes"
"""
enum likes_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  likes_pkey
}

"""
input type for inserting data into table "likes"
"""
input likes_insert_input {
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  post_id: uuid
  updated_at: timestamptz
  user_id: uuid
}

"""aggregate max on columns"""
type likes_max_fields {
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  post_id: uuid
  updated_at: timestamptz
  user_id: uuid
}

"""aggregate min on columns"""
type likes_min_fields {
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  post_id: uuid
  updated_at: timestamptz
  user_id: uuid
}

"""
response of any mutation on the table "likes"
"""
type likes_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [likes!]!
}

"""
on_conflict condition type for table "likes"
"""
input likes_on_conflict {
  constraint: likes_constraint!
  update_columns: [likes_update_column!]! = []
  where: likes_bool_exp
}

"""Ordering options when selecting data from "likes"."""
input likes_order_by {
  created_at: order_by
  deleted_at: order_by
  id: order_by
  post_id: order_by
  updated_at: order_by
  user_id: order_by
}

"""primary key columns input for table: likes"""
input likes_pk_columns_input {
  id: uuid!
}

"""
select columns of table "likes"
"""
enum likes_select_column {
  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  post_id

  """column name"""
  updated_at

  """column name"""
  user_id
}

"""
input type for updating data in table "likes"
"""
input likes_set_input {
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  post_id: uuid
  updated_at: timestamptz
  user_id: uuid
}

"""
Streaming cursor of the table "likes"
"""
input likes_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: likes_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input likes_stream_cursor_value_input {
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  post_id: uuid
  updated_at: timestamptz
  user_id: uuid
}

"""
update columns of table "likes"
"""
enum likes_update_column {
  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  post_id

  """column name"""
  updated_at

  """column name"""
  user_id
}

input likes_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: likes_set_input

  """filter the rows which have to be updated"""
  where: likes_bool_exp!
}

"""
columns and relationships of "media_files"
"""
type media_files {
  alt_text: String
  created_at: timestamptz!
  deleted_at: timestamptz
  file_name: String!
  folder_id: uuid
  id: uuid!
  mime_type: String!
  name: String!
  site_id: uuid
  size_bytes: bigint!
  updated_at: timestamptz!
  url: String!
}

"""
aggregated selection of "media_files"
"""
type media_files_aggregate {
  aggregate: media_files_aggregate_fields
  nodes: [media_files!]!
}

"""
aggregate fields of "media_files"
"""
type media_files_aggregate_fields {
  avg: media_files_avg_fields
  count(columns: [media_files_select_column!], distinct: Boolean): Int!
  max: media_files_max_fields
  min: media_files_min_fields
  stddev: media_files_stddev_fields
  stddev_pop: media_files_stddev_pop_fields
  stddev_samp: media_files_stddev_samp_fields
  sum: media_files_sum_fields
  var_pop: media_files_var_pop_fields
  var_samp: media_files_var_samp_fields
  variance: media_files_variance_fields
}

"""aggregate avg on columns"""
type media_files_avg_fields {
  size_bytes: Float
}

"""
Boolean expression to filter rows from the table "media_files". All fields are combined with a logical 'AND'.
"""
input media_files_bool_exp {
  _and: [media_files_bool_exp!]
  _not: media_files_bool_exp
  _or: [media_files_bool_exp!]
  alt_text: String_comparison_exp
  created_at: timestamptz_comparison_exp
  deleted_at: timestamptz_comparison_exp
  file_name: String_comparison_exp
  folder_id: uuid_comparison_exp
  id: uuid_comparison_exp
  mime_type: String_comparison_exp
  name: String_comparison_exp
  site_id: uuid_comparison_exp
  size_bytes: bigint_comparison_exp
  updated_at: timestamptz_comparison_exp
  url: String_comparison_exp
}

"""
unique or primary key constraints on table "media_files"
"""
enum media_files_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  media_files_pkey
}

"""
input type for incrementing numeric columns in table "media_files"
"""
input media_files_inc_input {
  size_bytes: bigint
}

"""
input type for inserting data into table "media_files"
"""
input media_files_insert_input {
  alt_text: String
  created_at: timestamptz
  deleted_at: timestamptz
  file_name: String
  folder_id: uuid
  id: uuid
  mime_type: String
  name: String
  site_id: uuid
  size_bytes: bigint
  updated_at: timestamptz
  url: String
}

"""aggregate max on columns"""
type media_files_max_fields {
  alt_text: String
  created_at: timestamptz
  deleted_at: timestamptz
  file_name: String
  folder_id: uuid
  id: uuid
  mime_type: String
  name: String
  site_id: uuid
  size_bytes: bigint
  updated_at: timestamptz
  url: String
}

"""aggregate min on columns"""
type media_files_min_fields {
  alt_text: String
  created_at: timestamptz
  deleted_at: timestamptz
  file_name: String
  folder_id: uuid
  id: uuid
  mime_type: String
  name: String
  site_id: uuid
  size_bytes: bigint
  updated_at: timestamptz
  url: String
}

"""
response of any mutation on the table "media_files"
"""
type media_files_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [media_files!]!
}

"""
on_conflict condition type for table "media_files"
"""
input media_files_on_conflict {
  constraint: media_files_constraint!
  update_columns: [media_files_update_column!]! = []
  where: media_files_bool_exp
}

"""Ordering options when selecting data from "media_files"."""
input media_files_order_by {
  alt_text: order_by
  created_at: order_by
  deleted_at: order_by
  file_name: order_by
  folder_id: order_by
  id: order_by
  mime_type: order_by
  name: order_by
  site_id: order_by
  size_bytes: order_by
  updated_at: order_by
  url: order_by
}

"""primary key columns input for table: media_files"""
input media_files_pk_columns_input {
  id: uuid!
}

"""
select columns of table "media_files"
"""
enum media_files_select_column {
  """column name"""
  alt_text

  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  file_name

  """column name"""
  folder_id

  """column name"""
  id

  """column name"""
  mime_type

  """column name"""
  name

  """column name"""
  site_id

  """column name"""
  size_bytes

  """column name"""
  updated_at

  """column name"""
  url
}

"""
input type for updating data in table "media_files"
"""
input media_files_set_input {
  alt_text: String
  created_at: timestamptz
  deleted_at: timestamptz
  file_name: String
  folder_id: uuid
  id: uuid
  mime_type: String
  name: String
  site_id: uuid
  size_bytes: bigint
  updated_at: timestamptz
  url: String
}

"""aggregate stddev on columns"""
type media_files_stddev_fields {
  size_bytes: Float
}

"""aggregate stddev_pop on columns"""
type media_files_stddev_pop_fields {
  size_bytes: Float
}

"""aggregate stddev_samp on columns"""
type media_files_stddev_samp_fields {
  size_bytes: Float
}

"""
Streaming cursor of the table "media_files"
"""
input media_files_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: media_files_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input media_files_stream_cursor_value_input {
  alt_text: String
  created_at: timestamptz
  deleted_at: timestamptz
  file_name: String
  folder_id: uuid
  id: uuid
  mime_type: String
  name: String
  site_id: uuid
  size_bytes: bigint
  updated_at: timestamptz
  url: String
}

"""aggregate sum on columns"""
type media_files_sum_fields {
  size_bytes: bigint
}

"""
update columns of table "media_files"
"""
enum media_files_update_column {
  """column name"""
  alt_text

  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  file_name

  """column name"""
  folder_id

  """column name"""
  id

  """column name"""
  mime_type

  """column name"""
  name

  """column name"""
  site_id

  """column name"""
  size_bytes

  """column name"""
  updated_at

  """column name"""
  url
}

input media_files_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: media_files_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: media_files_set_input

  """filter the rows which have to be updated"""
  where: media_files_bool_exp!
}

"""aggregate var_pop on columns"""
type media_files_var_pop_fields {
  size_bytes: Float
}

"""aggregate var_samp on columns"""
type media_files_var_samp_fields {
  size_bytes: Float
}

"""aggregate variance on columns"""
type media_files_variance_fields {
  size_bytes: Float
}

"""
columns and relationships of "media_folders"
"""
type media_folders {
  created_at: timestamptz!
  deleted_at: timestamptz
  id: uuid!
  name: String!
  parent_id: uuid
  path: String!
  site_id: uuid
  updated_at: timestamptz!
}

"""
aggregated selection of "media_folders"
"""
type media_folders_aggregate {
  aggregate: media_folders_aggregate_fields
  nodes: [media_folders!]!
}

"""
aggregate fields of "media_folders"
"""
type media_folders_aggregate_fields {
  count(columns: [media_folders_select_column!], distinct: Boolean): Int!
  max: media_folders_max_fields
  min: media_folders_min_fields
}

"""
Boolean expression to filter rows from the table "media_folders". All fields are combined with a logical 'AND'.
"""
input media_folders_bool_exp {
  _and: [media_folders_bool_exp!]
  _not: media_folders_bool_exp
  _or: [media_folders_bool_exp!]
  created_at: timestamptz_comparison_exp
  deleted_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
  parent_id: uuid_comparison_exp
  path: String_comparison_exp
  site_id: uuid_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "media_folders"
"""
enum media_folders_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  media_folders_pkey
}

"""
input type for inserting data into table "media_folders"
"""
input media_folders_insert_input {
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  name: String
  parent_id: uuid
  path: String
  site_id: uuid
  updated_at: timestamptz
}

"""aggregate max on columns"""
type media_folders_max_fields {
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  name: String
  parent_id: uuid
  path: String
  site_id: uuid
  updated_at: timestamptz
}

"""aggregate min on columns"""
type media_folders_min_fields {
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  name: String
  parent_id: uuid
  path: String
  site_id: uuid
  updated_at: timestamptz
}

"""
response of any mutation on the table "media_folders"
"""
type media_folders_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [media_folders!]!
}

"""
on_conflict condition type for table "media_folders"
"""
input media_folders_on_conflict {
  constraint: media_folders_constraint!
  update_columns: [media_folders_update_column!]! = []
  where: media_folders_bool_exp
}

"""Ordering options when selecting data from "media_folders"."""
input media_folders_order_by {
  created_at: order_by
  deleted_at: order_by
  id: order_by
  name: order_by
  parent_id: order_by
  path: order_by
  site_id: order_by
  updated_at: order_by
}

"""primary key columns input for table: media_folders"""
input media_folders_pk_columns_input {
  id: uuid!
}

"""
select columns of table "media_folders"
"""
enum media_folders_select_column {
  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  name

  """column name"""
  parent_id

  """column name"""
  path

  """column name"""
  site_id

  """column name"""
  updated_at
}

"""
input type for updating data in table "media_folders"
"""
input media_folders_set_input {
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  name: String
  parent_id: uuid
  path: String
  site_id: uuid
  updated_at: timestamptz
}

"""
Streaming cursor of the table "media_folders"
"""
input media_folders_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: media_folders_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input media_folders_stream_cursor_value_input {
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  name: String
  parent_id: uuid
  path: String
  site_id: uuid
  updated_at: timestamptz
}

"""
update columns of table "media_folders"
"""
enum media_folders_update_column {
  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  name

  """column name"""
  parent_id

  """column name"""
  path

  """column name"""
  site_id

  """column name"""
  updated_at
}

input media_folders_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: media_folders_set_input

  """filter the rows which have to be updated"""
  where: media_folders_bool_exp!
}

"""
columns and relationships of "mentions"
"""
type mentions {
  created_at: timestamptz!
  deleted_at: timestamptz
  id: uuid!
  post_id: uuid
  updated_at: timestamptz!
  user_id: uuid
}

"""
aggregated selection of "mentions"
"""
type mentions_aggregate {
  aggregate: mentions_aggregate_fields
  nodes: [mentions!]!
}

"""
aggregate fields of "mentions"
"""
type mentions_aggregate_fields {
  count(columns: [mentions_select_column!], distinct: Boolean): Int!
  max: mentions_max_fields
  min: mentions_min_fields
}

"""
Boolean expression to filter rows from the table "mentions". All fields are combined with a logical 'AND'.
"""
input mentions_bool_exp {
  _and: [mentions_bool_exp!]
  _not: mentions_bool_exp
  _or: [mentions_bool_exp!]
  created_at: timestamptz_comparison_exp
  deleted_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  post_id: uuid_comparison_exp
  updated_at: timestamptz_comparison_exp
  user_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "mentions"
"""
enum mentions_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  mentions_pkey
}

"""
input type for inserting data into table "mentions"
"""
input mentions_insert_input {
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  post_id: uuid
  updated_at: timestamptz
  user_id: uuid
}

"""aggregate max on columns"""
type mentions_max_fields {
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  post_id: uuid
  updated_at: timestamptz
  user_id: uuid
}

"""aggregate min on columns"""
type mentions_min_fields {
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  post_id: uuid
  updated_at: timestamptz
  user_id: uuid
}

"""
response of any mutation on the table "mentions"
"""
type mentions_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [mentions!]!
}

"""
on_conflict condition type for table "mentions"
"""
input mentions_on_conflict {
  constraint: mentions_constraint!
  update_columns: [mentions_update_column!]! = []
  where: mentions_bool_exp
}

"""Ordering options when selecting data from "mentions"."""
input mentions_order_by {
  created_at: order_by
  deleted_at: order_by
  id: order_by
  post_id: order_by
  updated_at: order_by
  user_id: order_by
}

"""primary key columns input for table: mentions"""
input mentions_pk_columns_input {
  id: uuid!
}

"""
select columns of table "mentions"
"""
enum mentions_select_column {
  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  post_id

  """column name"""
  updated_at

  """column name"""
  user_id
}

"""
input type for updating data in table "mentions"
"""
input mentions_set_input {
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  post_id: uuid
  updated_at: timestamptz
  user_id: uuid
}

"""
Streaming cursor of the table "mentions"
"""
input mentions_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: mentions_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input mentions_stream_cursor_value_input {
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  post_id: uuid
  updated_at: timestamptz
  user_id: uuid
}

"""
update columns of table "mentions"
"""
enum mentions_update_column {
  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  post_id

  """column name"""
  updated_at

  """column name"""
  user_id
}

input mentions_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: mentions_set_input

  """filter the rows which have to be updated"""
  where: mentions_bool_exp!
}

"""
columns and relationships of "menu_items"
"""
type menu_items {
  created_at: timestamptz!
  deleted_at: timestamptz
  id: uuid!
  label: String!
  menu_id: uuid
  page_id: uuid
  parent_id: uuid
  sort_order: Int!
  target: String!
  updated_at: timestamptz!
  url: String
}

"""
aggregated selection of "menu_items"
"""
type menu_items_aggregate {
  aggregate: menu_items_aggregate_fields
  nodes: [menu_items!]!
}

"""
aggregate fields of "menu_items"
"""
type menu_items_aggregate_fields {
  avg: menu_items_avg_fields
  count(columns: [menu_items_select_column!], distinct: Boolean): Int!
  max: menu_items_max_fields
  min: menu_items_min_fields
  stddev: menu_items_stddev_fields
  stddev_pop: menu_items_stddev_pop_fields
  stddev_samp: menu_items_stddev_samp_fields
  sum: menu_items_sum_fields
  var_pop: menu_items_var_pop_fields
  var_samp: menu_items_var_samp_fields
  variance: menu_items_variance_fields
}

"""aggregate avg on columns"""
type menu_items_avg_fields {
  sort_order: Float
}

"""
Boolean expression to filter rows from the table "menu_items". All fields are combined with a logical 'AND'.
"""
input menu_items_bool_exp {
  _and: [menu_items_bool_exp!]
  _not: menu_items_bool_exp
  _or: [menu_items_bool_exp!]
  created_at: timestamptz_comparison_exp
  deleted_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  label: String_comparison_exp
  menu_id: uuid_comparison_exp
  page_id: uuid_comparison_exp
  parent_id: uuid_comparison_exp
  sort_order: Int_comparison_exp
  target: String_comparison_exp
  updated_at: timestamptz_comparison_exp
  url: String_comparison_exp
}

"""
unique or primary key constraints on table "menu_items"
"""
enum menu_items_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  menu_items_pkey
}

"""
input type for incrementing numeric columns in table "menu_items"
"""
input menu_items_inc_input {
  sort_order: Int
}

"""
input type for inserting data into table "menu_items"
"""
input menu_items_insert_input {
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  label: String
  menu_id: uuid
  page_id: uuid
  parent_id: uuid
  sort_order: Int
  target: String
  updated_at: timestamptz
  url: String
}

"""aggregate max on columns"""
type menu_items_max_fields {
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  label: String
  menu_id: uuid
  page_id: uuid
  parent_id: uuid
  sort_order: Int
  target: String
  updated_at: timestamptz
  url: String
}

"""aggregate min on columns"""
type menu_items_min_fields {
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  label: String
  menu_id: uuid
  page_id: uuid
  parent_id: uuid
  sort_order: Int
  target: String
  updated_at: timestamptz
  url: String
}

"""
response of any mutation on the table "menu_items"
"""
type menu_items_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [menu_items!]!
}

"""
on_conflict condition type for table "menu_items"
"""
input menu_items_on_conflict {
  constraint: menu_items_constraint!
  update_columns: [menu_items_update_column!]! = []
  where: menu_items_bool_exp
}

"""Ordering options when selecting data from "menu_items"."""
input menu_items_order_by {
  created_at: order_by
  deleted_at: order_by
  id: order_by
  label: order_by
  menu_id: order_by
  page_id: order_by
  parent_id: order_by
  sort_order: order_by
  target: order_by
  updated_at: order_by
  url: order_by
}

"""primary key columns input for table: menu_items"""
input menu_items_pk_columns_input {
  id: uuid!
}

"""
select columns of table "menu_items"
"""
enum menu_items_select_column {
  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  label

  """column name"""
  menu_id

  """column name"""
  page_id

  """column name"""
  parent_id

  """column name"""
  sort_order

  """column name"""
  target

  """column name"""
  updated_at

  """column name"""
  url
}

"""
input type for updating data in table "menu_items"
"""
input menu_items_set_input {
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  label: String
  menu_id: uuid
  page_id: uuid
  parent_id: uuid
  sort_order: Int
  target: String
  updated_at: timestamptz
  url: String
}

"""aggregate stddev on columns"""
type menu_items_stddev_fields {
  sort_order: Float
}

"""aggregate stddev_pop on columns"""
type menu_items_stddev_pop_fields {
  sort_order: Float
}

"""aggregate stddev_samp on columns"""
type menu_items_stddev_samp_fields {
  sort_order: Float
}

"""
Streaming cursor of the table "menu_items"
"""
input menu_items_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: menu_items_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input menu_items_stream_cursor_value_input {
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  label: String
  menu_id: uuid
  page_id: uuid
  parent_id: uuid
  sort_order: Int
  target: String
  updated_at: timestamptz
  url: String
}

"""aggregate sum on columns"""
type menu_items_sum_fields {
  sort_order: Int
}

"""
update columns of table "menu_items"
"""
enum menu_items_update_column {
  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  label

  """column name"""
  menu_id

  """column name"""
  page_id

  """column name"""
  parent_id

  """column name"""
  sort_order

  """column name"""
  target

  """column name"""
  updated_at

  """column name"""
  url
}

input menu_items_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: menu_items_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: menu_items_set_input

  """filter the rows which have to be updated"""
  where: menu_items_bool_exp!
}

"""aggregate var_pop on columns"""
type menu_items_var_pop_fields {
  sort_order: Float
}

"""aggregate var_samp on columns"""
type menu_items_var_samp_fields {
  sort_order: Float
}

"""aggregate variance on columns"""
type menu_items_variance_fields {
  sort_order: Float
}

"""
columns and relationships of "menus"
"""
type menus {
  created_at: timestamptz!
  deleted_at: timestamptz
  id: uuid!
  location: String
  name: String!
  site_id: uuid
  slug: String!
  updated_at: timestamptz!
}

"""
aggregated selection of "menus"
"""
type menus_aggregate {
  aggregate: menus_aggregate_fields
  nodes: [menus!]!
}

"""
aggregate fields of "menus"
"""
type menus_aggregate_fields {
  count(columns: [menus_select_column!], distinct: Boolean): Int!
  max: menus_max_fields
  min: menus_min_fields
}

"""
Boolean expression to filter rows from the table "menus". All fields are combined with a logical 'AND'.
"""
input menus_bool_exp {
  _and: [menus_bool_exp!]
  _not: menus_bool_exp
  _or: [menus_bool_exp!]
  created_at: timestamptz_comparison_exp
  deleted_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  location: String_comparison_exp
  name: String_comparison_exp
  site_id: uuid_comparison_exp
  slug: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "menus"
"""
enum menus_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  menus_pkey
}

"""
input type for inserting data into table "menus"
"""
input menus_insert_input {
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  location: String
  name: String
  site_id: uuid
  slug: String
  updated_at: timestamptz
}

"""aggregate max on columns"""
type menus_max_fields {
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  location: String
  name: String
  site_id: uuid
  slug: String
  updated_at: timestamptz
}

"""aggregate min on columns"""
type menus_min_fields {
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  location: String
  name: String
  site_id: uuid
  slug: String
  updated_at: timestamptz
}

"""
response of any mutation on the table "menus"
"""
type menus_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [menus!]!
}

"""
on_conflict condition type for table "menus"
"""
input menus_on_conflict {
  constraint: menus_constraint!
  update_columns: [menus_update_column!]! = []
  where: menus_bool_exp
}

"""Ordering options when selecting data from "menus"."""
input menus_order_by {
  created_at: order_by
  deleted_at: order_by
  id: order_by
  location: order_by
  name: order_by
  site_id: order_by
  slug: order_by
  updated_at: order_by
}

"""primary key columns input for table: menus"""
input menus_pk_columns_input {
  id: uuid!
}

"""
select columns of table "menus"
"""
enum menus_select_column {
  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  location

  """column name"""
  name

  """column name"""
  site_id

  """column name"""
  slug

  """column name"""
  updated_at
}

"""
input type for updating data in table "menus"
"""
input menus_set_input {
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  location: String
  name: String
  site_id: uuid
  slug: String
  updated_at: timestamptz
}

"""
Streaming cursor of the table "menus"
"""
input menus_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: menus_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input menus_stream_cursor_value_input {
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  location: String
  name: String
  site_id: uuid
  slug: String
  updated_at: timestamptz
}

"""
update columns of table "menus"
"""
enum menus_update_column {
  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  location

  """column name"""
  name

  """column name"""
  site_id

  """column name"""
  slug

  """column name"""
  updated_at
}

input menus_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: menus_set_input

  """filter the rows which have to be updated"""
  where: menus_bool_exp!
}

"""
columns and relationships of "message_reactions"
"""
type message_reactions {
  created_at: timestamptz!
  deleted_at: timestamptz
  emoji: String!
  id: uuid!
  message_id: uuid
  updated_at: timestamptz!
  user_id: uuid
}

"""
aggregated selection of "message_reactions"
"""
type message_reactions_aggregate {
  aggregate: message_reactions_aggregate_fields
  nodes: [message_reactions!]!
}

"""
aggregate fields of "message_reactions"
"""
type message_reactions_aggregate_fields {
  count(columns: [message_reactions_select_column!], distinct: Boolean): Int!
  max: message_reactions_max_fields
  min: message_reactions_min_fields
}

"""
Boolean expression to filter rows from the table "message_reactions". All fields are combined with a logical 'AND'.
"""
input message_reactions_bool_exp {
  _and: [message_reactions_bool_exp!]
  _not: message_reactions_bool_exp
  _or: [message_reactions_bool_exp!]
  created_at: timestamptz_comparison_exp
  deleted_at: timestamptz_comparison_exp
  emoji: String_comparison_exp
  id: uuid_comparison_exp
  message_id: uuid_comparison_exp
  updated_at: timestamptz_comparison_exp
  user_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "message_reactions"
"""
enum message_reactions_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  message_reactions_pkey
}

"""
input type for inserting data into table "message_reactions"
"""
input message_reactions_insert_input {
  created_at: timestamptz
  deleted_at: timestamptz
  emoji: String
  id: uuid
  message_id: uuid
  updated_at: timestamptz
  user_id: uuid
}

"""aggregate max on columns"""
type message_reactions_max_fields {
  created_at: timestamptz
  deleted_at: timestamptz
  emoji: String
  id: uuid
  message_id: uuid
  updated_at: timestamptz
  user_id: uuid
}

"""aggregate min on columns"""
type message_reactions_min_fields {
  created_at: timestamptz
  deleted_at: timestamptz
  emoji: String
  id: uuid
  message_id: uuid
  updated_at: timestamptz
  user_id: uuid
}

"""
response of any mutation on the table "message_reactions"
"""
type message_reactions_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [message_reactions!]!
}

"""
on_conflict condition type for table "message_reactions"
"""
input message_reactions_on_conflict {
  constraint: message_reactions_constraint!
  update_columns: [message_reactions_update_column!]! = []
  where: message_reactions_bool_exp
}

"""Ordering options when selecting data from "message_reactions"."""
input message_reactions_order_by {
  created_at: order_by
  deleted_at: order_by
  emoji: order_by
  id: order_by
  message_id: order_by
  updated_at: order_by
  user_id: order_by
}

"""primary key columns input for table: message_reactions"""
input message_reactions_pk_columns_input {
  id: uuid!
}

"""
select columns of table "message_reactions"
"""
enum message_reactions_select_column {
  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  emoji

  """column name"""
  id

  """column name"""
  message_id

  """column name"""
  updated_at

  """column name"""
  user_id
}

"""
input type for updating data in table "message_reactions"
"""
input message_reactions_set_input {
  created_at: timestamptz
  deleted_at: timestamptz
  emoji: String
  id: uuid
  message_id: uuid
  updated_at: timestamptz
  user_id: uuid
}

"""
Streaming cursor of the table "message_reactions"
"""
input message_reactions_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: message_reactions_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input message_reactions_stream_cursor_value_input {
  created_at: timestamptz
  deleted_at: timestamptz
  emoji: String
  id: uuid
  message_id: uuid
  updated_at: timestamptz
  user_id: uuid
}

"""
update columns of table "message_reactions"
"""
enum message_reactions_update_column {
  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  emoji

  """column name"""
  id

  """column name"""
  message_id

  """column name"""
  updated_at

  """column name"""
  user_id
}

input message_reactions_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: message_reactions_set_input

  """filter the rows which have to be updated"""
  where: message_reactions_bool_exp!
}

"""
columns and relationships of "messages"
"""
type messages {
  content: String!
  conversation_id: uuid
  created_at: timestamptz!
  deleted_at: timestamptz
  id: uuid!
  read_at: timestamptz
  reply_to_id: uuid
  sender_id: uuid
  updated_at: timestamptz!
}

"""
aggregated selection of "messages"
"""
type messages_aggregate {
  aggregate: messages_aggregate_fields
  nodes: [messages!]!
}

"""
aggregate fields of "messages"
"""
type messages_aggregate_fields {
  count(columns: [messages_select_column!], distinct: Boolean): Int!
  max: messages_max_fields
  min: messages_min_fields
}

"""
Boolean expression to filter rows from the table "messages". All fields are combined with a logical 'AND'.
"""
input messages_bool_exp {
  _and: [messages_bool_exp!]
  _not: messages_bool_exp
  _or: [messages_bool_exp!]
  content: String_comparison_exp
  conversation_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  deleted_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  read_at: timestamptz_comparison_exp
  reply_to_id: uuid_comparison_exp
  sender_id: uuid_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "messages"
"""
enum messages_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  messages_pkey
}

"""
input type for inserting data into table "messages"
"""
input messages_insert_input {
  content: String
  conversation_id: uuid
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  read_at: timestamptz
  reply_to_id: uuid
  sender_id: uuid
  updated_at: timestamptz
}

"""aggregate max on columns"""
type messages_max_fields {
  content: String
  conversation_id: uuid
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  read_at: timestamptz
  reply_to_id: uuid
  sender_id: uuid
  updated_at: timestamptz
}

"""aggregate min on columns"""
type messages_min_fields {
  content: String
  conversation_id: uuid
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  read_at: timestamptz
  reply_to_id: uuid
  sender_id: uuid
  updated_at: timestamptz
}

"""
response of any mutation on the table "messages"
"""
type messages_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [messages!]!
}

"""
on_conflict condition type for table "messages"
"""
input messages_on_conflict {
  constraint: messages_constraint!
  update_columns: [messages_update_column!]! = []
  where: messages_bool_exp
}

"""Ordering options when selecting data from "messages"."""
input messages_order_by {
  content: order_by
  conversation_id: order_by
  created_at: order_by
  deleted_at: order_by
  id: order_by
  read_at: order_by
  reply_to_id: order_by
  sender_id: order_by
  updated_at: order_by
}

"""primary key columns input for table: messages"""
input messages_pk_columns_input {
  id: uuid!
}

"""
select columns of table "messages"
"""
enum messages_select_column {
  """column name"""
  content

  """column name"""
  conversation_id

  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  read_at

  """column name"""
  reply_to_id

  """column name"""
  sender_id

  """column name"""
  updated_at
}

"""
input type for updating data in table "messages"
"""
input messages_set_input {
  content: String
  conversation_id: uuid
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  read_at: timestamptz
  reply_to_id: uuid
  sender_id: uuid
  updated_at: timestamptz
}

"""
Streaming cursor of the table "messages"
"""
input messages_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: messages_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input messages_stream_cursor_value_input {
  content: String
  conversation_id: uuid
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  read_at: timestamptz
  reply_to_id: uuid
  sender_id: uuid
  updated_at: timestamptz
}

"""
update columns of table "messages"
"""
enum messages_update_column {
  """column name"""
  content

  """column name"""
  conversation_id

  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  read_at

  """column name"""
  reply_to_id

  """column name"""
  sender_id

  """column name"""
  updated_at
}

input messages_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: messages_set_input

  """filter the rows which have to be updated"""
  where: messages_bool_exp!
}

"""mutation root"""
type mutation_root {
  """
  delete data from the table: "analytics_events"
  """
  delete_analytics_events(
    """filter the rows which have to be deleted"""
    where: analytics_events_bool_exp!
  ): analytics_events_mutation_response

  """
  delete single row from the table: "analytics_events"
  """
  delete_analytics_events_by_pk(id: uuid!): analytics_events

  """
  delete data from the table: "article_categories"
  """
  delete_article_categories(
    """filter the rows which have to be deleted"""
    where: article_categories_bool_exp!
  ): article_categories_mutation_response

  """
  delete single row from the table: "article_categories"
  """
  delete_article_categories_by_pk(id: uuid!): article_categories

  """
  delete data from the table: "article_category_assignments"
  """
  delete_article_category_assignments(
    """filter the rows which have to be deleted"""
    where: article_category_assignments_bool_exp!
  ): article_category_assignments_mutation_response

  """
  delete single row from the table: "article_category_assignments"
  """
  delete_article_category_assignments_by_pk(id: uuid!): article_category_assignments

  """
  delete data from the table: "article_tags"
  """
  delete_article_tags(
    """filter the rows which have to be deleted"""
    where: article_tags_bool_exp!
  ): article_tags_mutation_response

  """
  delete single row from the table: "article_tags"
  """
  delete_article_tags_by_pk(id: uuid!): article_tags

  """
  delete data from the table: "articles"
  """
  delete_articles(
    """filter the rows which have to be deleted"""
    where: articles_bool_exp!
  ): articles_mutation_response

  """
  delete single row from the table: "articles"
  """
  delete_articles_by_pk(id: uuid!): articles

  """
  delete data from the table: "author_articles"
  """
  delete_author_articles(
    """filter the rows which have to be deleted"""
    where: author_articles_bool_exp!
  ): author_articles_mutation_response

  """
  delete single row from the table: "author_articles"
  """
  delete_author_articles_by_pk(id: uuid!): author_articles

  """
  delete data from the table: "authors"
  """
  delete_authors(
    """filter the rows which have to be deleted"""
    where: authors_bool_exp!
  ): authors_mutation_response

  """
  delete single row from the table: "authors"
  """
  delete_authors_by_pk(id: uuid!): authors

  """
  delete data from the table: "blocks"
  """
  delete_blocks(
    """filter the rows which have to be deleted"""
    where: blocks_bool_exp!
  ): blocks_mutation_response

  """
  delete single row from the table: "blocks"
  """
  delete_blocks_by_pk(id: uuid!): blocks

  """
  delete data from the table: "bookmarks"
  """
  delete_bookmarks(
    """filter the rows which have to be deleted"""
    where: bookmarks_bool_exp!
  ): bookmarks_mutation_response

  """
  delete single row from the table: "bookmarks"
  """
  delete_bookmarks_by_pk(id: uuid!): bookmarks

  """
  delete data from the table: "brands"
  """
  delete_brands(
    """filter the rows which have to be deleted"""
    where: brands_bool_exp!
  ): brands_mutation_response

  """
  delete single row from the table: "brands"
  """
  delete_brands_by_pk(id: uuid!): brands

  """
  delete data from the table: "cart_items"
  """
  delete_cart_items(
    """filter the rows which have to be deleted"""
    where: cart_items_bool_exp!
  ): cart_items_mutation_response

  """
  delete single row from the table: "cart_items"
  """
  delete_cart_items_by_pk(id: uuid!): cart_items

  """
  delete data from the table: "carts"
  """
  delete_carts(
    """filter the rows which have to be deleted"""
    where: carts_bool_exp!
  ): carts_mutation_response

  """
  delete single row from the table: "carts"
  """
  delete_carts_by_pk(id: uuid!): carts

  """
  delete data from the table: "cities"
  """
  delete_cities(
    """filter the rows which have to be deleted"""
    where: cities_bool_exp!
  ): cities_mutation_response

  """
  delete single row from the table: "cities"
  """
  delete_cities_by_pk(id: uuid!): cities

  """
  delete data from the table: "collections"
  """
  delete_collections(
    """filter the rows which have to be deleted"""
    where: collections_bool_exp!
  ): collections_mutation_response

  """
  delete single row from the table: "collections"
  """
  delete_collections_by_pk(id: uuid!): collections

  """
  delete data from the table: "colors"
  """
  delete_colors(
    """filter the rows which have to be deleted"""
    where: colors_bool_exp!
  ): colors_mutation_response

  """
  delete single row from the table: "colors"
  """
  delete_colors_by_pk(id: uuid!): colors

  """
  delete data from the table: "comments"
  """
  delete_comments(
    """filter the rows which have to be deleted"""
    where: comments_bool_exp!
  ): comments_mutation_response

  """
  delete single row from the table: "comments"
  """
  delete_comments_by_pk(id: uuid!): comments

  """
  delete data from the table: "conversation_participants"
  """
  delete_conversation_participants(
    """filter the rows which have to be deleted"""
    where: conversation_participants_bool_exp!
  ): conversation_participants_mutation_response

  """
  delete single row from the table: "conversation_participants"
  """
  delete_conversation_participants_by_pk(id: uuid!): conversation_participants

  """
  delete data from the table: "conversations"
  """
  delete_conversations(
    """filter the rows which have to be deleted"""
    where: conversations_bool_exp!
  ): conversations_mutation_response

  """
  delete single row from the table: "conversations"
  """
  delete_conversations_by_pk(id: uuid!): conversations

  """
  delete data from the table: "countries"
  """
  delete_countries(
    """filter the rows which have to be deleted"""
    where: countries_bool_exp!
  ): countries_mutation_response

  """
  delete single row from the table: "countries"
  """
  delete_countries_by_pk(id: uuid!): countries

  """
  delete data from the table: "coupons"
  """
  delete_coupons(
    """filter the rows which have to be deleted"""
    where: coupons_bool_exp!
  ): coupons_mutation_response

  """
  delete single row from the table: "coupons"
  """
  delete_coupons_by_pk(id: uuid!): coupons

  """
  delete data from the table: "currencies"
  """
  delete_currencies(
    """filter the rows which have to be deleted"""
    where: currencies_bool_exp!
  ): currencies_mutation_response

  """
  delete single row from the table: "currencies"
  """
  delete_currencies_by_pk(id: uuid!): currencies

  """
  delete data from the table: "customer_addresses"
  """
  delete_customer_addresses(
    """filter the rows which have to be deleted"""
    where: customer_addresses_bool_exp!
  ): customer_addresses_mutation_response

  """
  delete single row from the table: "customer_addresses"
  """
  delete_customer_addresses_by_pk(id: uuid!): customer_addresses

  """
  delete data from the table: "customer_stores"
  """
  delete_customer_stores(
    """filter the rows which have to be deleted"""
    where: customer_stores_bool_exp!
  ): customer_stores_mutation_response

  """
  delete single row from the table: "customer_stores"
  """
  delete_customer_stores_by_pk(id: uuid!): customer_stores

  """
  delete data from the table: "customers"
  """
  delete_customers(
    """filter the rows which have to be deleted"""
    where: customers_bool_exp!
  ): customers_mutation_response

  """
  delete single row from the table: "customers"
  """
  delete_customers_by_pk(id: uuid!): customers

  """
  delete data from the table: "districts"
  """
  delete_districts(
    """filter the rows which have to be deleted"""
    where: districts_bool_exp!
  ): districts_mutation_response

  """
  delete single row from the table: "districts"
  """
  delete_districts_by_pk(id: uuid!): districts

  """
  delete data from the table: "ec_categories"
  """
  delete_ec_categories(
    """filter the rows which have to be deleted"""
    where: ec_categories_bool_exp!
  ): ec_categories_mutation_response

  """
  delete single row from the table: "ec_categories"
  """
  delete_ec_categories_by_pk(id: uuid!): ec_categories

  """
  delete data from the table: "follows"
  """
  delete_follows(
    """filter the rows which have to be deleted"""
    where: follows_bool_exp!
  ): follows_mutation_response

  """
  delete single row from the table: "follows"
  """
  delete_follows_by_pk(id: uuid!): follows

  """
  delete data from the table: "form_submissions"
  """
  delete_form_submissions(
    """filter the rows which have to be deleted"""
    where: form_submissions_bool_exp!
  ): form_submissions_mutation_response

  """
  delete single row from the table: "form_submissions"
  """
  delete_form_submissions_by_pk(id: uuid!): form_submissions

  """
  delete data from the table: "forms"
  """
  delete_forms(
    """filter the rows which have to be deleted"""
    where: forms_bool_exp!
  ): forms_mutation_response

  """
  delete single row from the table: "forms"
  """
  delete_forms_by_pk(id: uuid!): forms

  """
  delete data from the table: "hashtags"
  """
  delete_hashtags(
    """filter the rows which have to be deleted"""
    where: hashtags_bool_exp!
  ): hashtags_mutation_response

  """
  delete single row from the table: "hashtags"
  """
  delete_hashtags_by_pk(id: uuid!): hashtags

  """
  delete data from the table: "inventory_levels"
  """
  delete_inventory_levels(
    """filter the rows which have to be deleted"""
    where: inventory_levels_bool_exp!
  ): inventory_levels_mutation_response

  """
  delete single row from the table: "inventory_levels"
  """
  delete_inventory_levels_by_pk(id: uuid!): inventory_levels

  """
  delete data from the table: "inventory_locations"
  """
  delete_inventory_locations(
    """filter the rows which have to be deleted"""
    where: inventory_locations_bool_exp!
  ): inventory_locations_mutation_response

  """
  delete single row from the table: "inventory_locations"
  """
  delete_inventory_locations_by_pk(id: uuid!): inventory_locations

  """
  delete data from the table: "likes"
  """
  delete_likes(
    """filter the rows which have to be deleted"""
    where: likes_bool_exp!
  ): likes_mutation_response

  """
  delete single row from the table: "likes"
  """
  delete_likes_by_pk(id: uuid!): likes

  """
  delete data from the table: "media_files"
  """
  delete_media_files(
    """filter the rows which have to be deleted"""
    where: media_files_bool_exp!
  ): media_files_mutation_response

  """
  delete single row from the table: "media_files"
  """
  delete_media_files_by_pk(id: uuid!): media_files

  """
  delete data from the table: "media_folders"
  """
  delete_media_folders(
    """filter the rows which have to be deleted"""
    where: media_folders_bool_exp!
  ): media_folders_mutation_response

  """
  delete single row from the table: "media_folders"
  """
  delete_media_folders_by_pk(id: uuid!): media_folders

  """
  delete data from the table: "mentions"
  """
  delete_mentions(
    """filter the rows which have to be deleted"""
    where: mentions_bool_exp!
  ): mentions_mutation_response

  """
  delete single row from the table: "mentions"
  """
  delete_mentions_by_pk(id: uuid!): mentions

  """
  delete data from the table: "menu_items"
  """
  delete_menu_items(
    """filter the rows which have to be deleted"""
    where: menu_items_bool_exp!
  ): menu_items_mutation_response

  """
  delete single row from the table: "menu_items"
  """
  delete_menu_items_by_pk(id: uuid!): menu_items

  """
  delete data from the table: "menus"
  """
  delete_menus(
    """filter the rows which have to be deleted"""
    where: menus_bool_exp!
  ): menus_mutation_response

  """
  delete single row from the table: "menus"
  """
  delete_menus_by_pk(id: uuid!): menus

  """
  delete data from the table: "message_reactions"
  """
  delete_message_reactions(
    """filter the rows which have to be deleted"""
    where: message_reactions_bool_exp!
  ): message_reactions_mutation_response

  """
  delete single row from the table: "message_reactions"
  """
  delete_message_reactions_by_pk(id: uuid!): message_reactions

  """
  delete data from the table: "messages"
  """
  delete_messages(
    """filter the rows which have to be deleted"""
    where: messages_bool_exp!
  ): messages_mutation_response

  """
  delete single row from the table: "messages"
  """
  delete_messages_by_pk(id: uuid!): messages

  """
  delete data from the table: "neighborhoods"
  """
  delete_neighborhoods(
    """filter the rows which have to be deleted"""
    where: neighborhoods_bool_exp!
  ): neighborhoods_mutation_response

  """
  delete single row from the table: "neighborhoods"
  """
  delete_neighborhoods_by_pk(id: uuid!): neighborhoods

  """
  delete data from the table: "notifications"
  """
  delete_notifications(
    """filter the rows which have to be deleted"""
    where: notifications_bool_exp!
  ): notifications_mutation_response

  """
  delete single row from the table: "notifications"
  """
  delete_notifications_by_pk(id: uuid!): notifications

  """
  delete data from the table: "order_coupons"
  """
  delete_order_coupons(
    """filter the rows which have to be deleted"""
    where: order_coupons_bool_exp!
  ): order_coupons_mutation_response

  """
  delete single row from the table: "order_coupons"
  """
  delete_order_coupons_by_pk(id: uuid!): order_coupons

  """
  delete data from the table: "order_items"
  """
  delete_order_items(
    """filter the rows which have to be deleted"""
    where: order_items_bool_exp!
  ): order_items_mutation_response

  """
  delete single row from the table: "order_items"
  """
  delete_order_items_by_pk(id: uuid!): order_items

  """
  delete data from the table: "order_statuses"
  """
  delete_order_statuses(
    """filter the rows which have to be deleted"""
    where: order_statuses_bool_exp!
  ): order_statuses_mutation_response

  """
  delete single row from the table: "order_statuses"
  """
  delete_order_statuses_by_pk(id: uuid!): order_statuses

  """
  delete data from the table: "orders"
  """
  delete_orders(
    """filter the rows which have to be deleted"""
    where: orders_bool_exp!
  ): orders_mutation_response

  """
  delete single row from the table: "orders"
  """
  delete_orders_by_pk(id: uuid!): orders

  """
  delete data from the table: "page_templates"
  """
  delete_page_templates(
    """filter the rows which have to be deleted"""
    where: page_templates_bool_exp!
  ): page_templates_mutation_response

  """
  delete single row from the table: "page_templates"
  """
  delete_page_templates_by_pk(id: uuid!): page_templates

  """
  delete data from the table: "page_versions"
  """
  delete_page_versions(
    """filter the rows which have to be deleted"""
    where: page_versions_bool_exp!
  ): page_versions_mutation_response

  """
  delete single row from the table: "page_versions"
  """
  delete_page_versions_by_pk(id: uuid!): page_versions

  """
  delete data from the table: "pages"
  """
  delete_pages(
    """filter the rows which have to be deleted"""
    where: pages_bool_exp!
  ): pages_mutation_response

  """
  delete single row from the table: "pages"
  """
  delete_pages_by_pk(id: uuid!): pages

  """
  delete data from the table: "payment_methods"
  """
  delete_payment_methods(
    """filter the rows which have to be deleted"""
    where: payment_methods_bool_exp!
  ): payment_methods_mutation_response

  """
  delete single row from the table: "payment_methods"
  """
  delete_payment_methods_by_pk(id: uuid!): payment_methods

  """
  delete data from the table: "payment_statuses"
  """
  delete_payment_statuses(
    """filter the rows which have to be deleted"""
    where: payment_statuses_bool_exp!
  ): payment_statuses_mutation_response

  """
  delete single row from the table: "payment_statuses"
  """
  delete_payment_statuses_by_pk(id: uuid!): payment_statuses

  """
  delete data from the table: "payments"
  """
  delete_payments(
    """filter the rows which have to be deleted"""
    where: payments_bool_exp!
  ): payments_mutation_response

  """
  delete single row from the table: "payments"
  """
  delete_payments_by_pk(id: uuid!): payments

  """
  delete data from the table: "permissions"
  """
  delete_permissions(
    """filter the rows which have to be deleted"""
    where: permissions_bool_exp!
  ): permissions_mutation_response

  """
  delete single row from the table: "permissions"
  """
  delete_permissions_by_pk(id: uuid!): permissions

  """
  delete data from the table: "post_hashtags"
  """
  delete_post_hashtags(
    """filter the rows which have to be deleted"""
    where: post_hashtags_bool_exp!
  ): post_hashtags_mutation_response

  """
  delete single row from the table: "post_hashtags"
  """
  delete_post_hashtags_by_pk(id: uuid!): post_hashtags

  """
  delete data from the table: "post_media"
  """
  delete_post_media(
    """filter the rows which have to be deleted"""
    where: post_media_bool_exp!
  ): post_media_mutation_response

  """
  delete single row from the table: "post_media"
  """
  delete_post_media_by_pk(id: uuid!): post_media

  """
  delete data from the table: "posts"
  """
  delete_posts(
    """filter the rows which have to be deleted"""
    where: posts_bool_exp!
  ): posts_mutation_response

  """
  delete single row from the table: "posts"
  """
  delete_posts_by_pk(id: uuid!): posts

  """
  delete data from the table: "product_categories"
  """
  delete_product_categories(
    """filter the rows which have to be deleted"""
    where: product_categories_bool_exp!
  ): product_categories_mutation_response

  """
  delete single row from the table: "product_categories"
  """
  delete_product_categories_by_pk(id: uuid!): product_categories

  """
  delete data from the table: "product_collections"
  """
  delete_product_collections(
    """filter the rows which have to be deleted"""
    where: product_collections_bool_exp!
  ): product_collections_mutation_response

  """
  delete single row from the table: "product_collections"
  """
  delete_product_collections_by_pk(id: uuid!): product_collections

  """
  delete data from the table: "product_images"
  """
  delete_product_images(
    """filter the rows which have to be deleted"""
    where: product_images_bool_exp!
  ): product_images_mutation_response

  """
  delete single row from the table: "product_images"
  """
  delete_product_images_by_pk(id: uuid!): product_images

  """
  delete data from the table: "product_variants"
  """
  delete_product_variants(
    """filter the rows which have to be deleted"""
    where: product_variants_bool_exp!
  ): product_variants_mutation_response

  """
  delete single row from the table: "product_variants"
  """
  delete_product_variants_by_pk(id: uuid!): product_variants

  """
  delete data from the table: "products"
  """
  delete_products(
    """filter the rows which have to be deleted"""
    where: products_bool_exp!
  ): products_mutation_response

  """
  delete single row from the table: "products"
  """
  delete_products_by_pk(id: uuid!): products

  """
  delete data from the table: "redirects"
  """
  delete_redirects(
    """filter the rows which have to be deleted"""
    where: redirects_bool_exp!
  ): redirects_mutation_response

  """
  delete single row from the table: "redirects"
  """
  delete_redirects_by_pk(id: uuid!): redirects

  """
  delete data from the table: "regions"
  """
  delete_regions(
    """filter the rows which have to be deleted"""
    where: regions_bool_exp!
  ): regions_mutation_response

  """
  delete single row from the table: "regions"
  """
  delete_regions_by_pk(id: uuid!): regions

  """
  delete data from the table: "related_products"
  """
  delete_related_products(
    """filter the rows which have to be deleted"""
    where: related_products_bool_exp!
  ): related_products_mutation_response

  """
  delete single row from the table: "related_products"
  """
  delete_related_products_by_pk(id: uuid!): related_products

  """
  delete data from the table: "report_statuses"
  """
  delete_report_statuses(
    """filter the rows which have to be deleted"""
    where: report_statuses_bool_exp!
  ): report_statuses_mutation_response

  """
  delete single row from the table: "report_statuses"
  """
  delete_report_statuses_by_pk(id: uuid!): report_statuses

  """
  delete data from the table: "reports"
  """
  delete_reports(
    """filter the rows which have to be deleted"""
    where: reports_bool_exp!
  ): reports_mutation_response

  """
  delete single row from the table: "reports"
  """
  delete_reports_by_pk(id: uuid!): reports

  """
  delete data from the table: "return_requests"
  """
  delete_return_requests(
    """filter the rows which have to be deleted"""
    where: return_requests_bool_exp!
  ): return_requests_mutation_response

  """
  delete single row from the table: "return_requests"
  """
  delete_return_requests_by_pk(id: uuid!): return_requests

  """
  delete data from the table: "return_statuses"
  """
  delete_return_statuses(
    """filter the rows which have to be deleted"""
    where: return_statuses_bool_exp!
  ): return_statuses_mutation_response

  """
  delete single row from the table: "return_statuses"
  """
  delete_return_statuses_by_pk(id: uuid!): return_statuses

  """
  delete data from the table: "reviews"
  """
  delete_reviews(
    """filter the rows which have to be deleted"""
    where: reviews_bool_exp!
  ): reviews_mutation_response

  """
  delete single row from the table: "reviews"
  """
  delete_reviews_by_pk(id: uuid!): reviews

  """
  delete data from the table: "role_permissions"
  """
  delete_role_permissions(
    """filter the rows which have to be deleted"""
    where: role_permissions_bool_exp!
  ): role_permissions_mutation_response

  """
  delete single row from the table: "role_permissions"
  """
  delete_role_permissions_by_pk(id: uuid!): role_permissions

  """
  delete data from the table: "roles"
  """
  delete_roles(
    """filter the rows which have to be deleted"""
    where: roles_bool_exp!
  ): roles_mutation_response

  """
  delete single row from the table: "roles"
  """
  delete_roles_by_pk(id: uuid!): roles

  """
  delete data from the table: "seo_settings"
  """
  delete_seo_settings(
    """filter the rows which have to be deleted"""
    where: seo_settings_bool_exp!
  ): seo_settings_mutation_response

  """
  delete single row from the table: "seo_settings"
  """
  delete_seo_settings_by_pk(id: uuid!): seo_settings

  """
  delete data from the table: "shipment_statuses"
  """
  delete_shipment_statuses(
    """filter the rows which have to be deleted"""
    where: shipment_statuses_bool_exp!
  ): shipment_statuses_mutation_response

  """
  delete single row from the table: "shipment_statuses"
  """
  delete_shipment_statuses_by_pk(id: uuid!): shipment_statuses

  """
  delete data from the table: "shipments"
  """
  delete_shipments(
    """filter the rows which have to be deleted"""
    where: shipments_bool_exp!
  ): shipments_mutation_response

  """
  delete single row from the table: "shipments"
  """
  delete_shipments_by_pk(id: uuid!): shipments

  """
  delete data from the table: "shipping_carriers"
  """
  delete_shipping_carriers(
    """filter the rows which have to be deleted"""
    where: shipping_carriers_bool_exp!
  ): shipping_carriers_mutation_response

  """
  delete single row from the table: "shipping_carriers"
  """
  delete_shipping_carriers_by_pk(id: uuid!): shipping_carriers

  """
  delete data from the table: "site_authors"
  """
  delete_site_authors(
    """filter the rows which have to be deleted"""
    where: site_authors_bool_exp!
  ): site_authors_mutation_response

  """
  delete single row from the table: "site_authors"
  """
  delete_site_authors_by_pk(id: uuid!): site_authors

  """
  delete data from the table: "sites"
  """
  delete_sites(
    """filter the rows which have to be deleted"""
    where: sites_bool_exp!
  ): sites_mutation_response

  """
  delete single row from the table: "sites"
  """
  delete_sites_by_pk(id: uuid!): sites

  """
  delete data from the table: "sizes"
  """
  delete_sizes(
    """filter the rows which have to be deleted"""
    where: sizes_bool_exp!
  ): sizes_mutation_response

  """
  delete single row from the table: "sizes"
  """
  delete_sizes_by_pk(id: uuid!): sizes

  """
  delete data from the table: "store_currencies"
  """
  delete_store_currencies(
    """filter the rows which have to be deleted"""
    where: store_currencies_bool_exp!
  ): store_currencies_mutation_response

  """
  delete single row from the table: "store_currencies"
  """
  delete_store_currencies_by_pk(id: uuid!): store_currencies

  """
  delete data from the table: "store_payment_methods"
  """
  delete_store_payment_methods(
    """filter the rows which have to be deleted"""
    where: store_payment_methods_bool_exp!
  ): store_payment_methods_mutation_response

  """
  delete single row from the table: "store_payment_methods"
  """
  delete_store_payment_methods_by_pk(id: uuid!): store_payment_methods

  """
  delete data from the table: "store_shipping_carriers"
  """
  delete_store_shipping_carriers(
    """filter the rows which have to be deleted"""
    where: store_shipping_carriers_bool_exp!
  ): store_shipping_carriers_mutation_response

  """
  delete single row from the table: "store_shipping_carriers"
  """
  delete_store_shipping_carriers_by_pk(id: uuid!): store_shipping_carriers

  """
  delete data from the table: "stores"
  """
  delete_stores(
    """filter the rows which have to be deleted"""
    where: stores_bool_exp!
  ): stores_mutation_response

  """
  delete single row from the table: "stores"
  """
  delete_stores_by_pk(id: uuid!): stores

  """
  delete data from the table: "streets"
  """
  delete_streets(
    """filter the rows which have to be deleted"""
    where: streets_bool_exp!
  ): streets_mutation_response

  """
  delete single row from the table: "streets"
  """
  delete_streets_by_pk(id: uuid!): streets

  """
  delete data from the table: "tags"
  """
  delete_tags(
    """filter the rows which have to be deleted"""
    where: tags_bool_exp!
  ): tags_mutation_response

  """
  delete single row from the table: "tags"
  """
  delete_tags_by_pk(id: uuid!): tags

  """
  delete data from the table: "user_profiles"
  """
  delete_user_profiles(
    """filter the rows which have to be deleted"""
    where: user_profiles_bool_exp!
  ): user_profiles_mutation_response

  """
  delete single row from the table: "user_profiles"
  """
  delete_user_profiles_by_pk(id: uuid!): user_profiles

  """
  delete data from the table: "user_roles"
  """
  delete_user_roles(
    """filter the rows which have to be deleted"""
    where: user_roles_bool_exp!
  ): user_roles_mutation_response

  """
  delete single row from the table: "user_roles"
  """
  delete_user_roles_by_pk(id: uuid!): user_roles

  """
  delete data from the table: "user_sessions"
  """
  delete_user_sessions(
    """filter the rows which have to be deleted"""
    where: user_sessions_bool_exp!
  ): user_sessions_mutation_response

  """
  delete single row from the table: "user_sessions"
  """
  delete_user_sessions_by_pk(id: uuid!): user_sessions

  """
  delete data from the table: "user_settings"
  """
  delete_user_settings(
    """filter the rows which have to be deleted"""
    where: user_settings_bool_exp!
  ): user_settings_mutation_response

  """
  delete single row from the table: "user_settings"
  """
  delete_user_settings_by_pk(id: uuid!): user_settings

  """
  delete data from the table: "users"
  """
  delete_users(
    """filter the rows which have to be deleted"""
    where: users_bool_exp!
  ): users_mutation_response

  """
  delete single row from the table: "users"
  """
  delete_users_by_pk(id: uuid!): users

  """
  delete data from the table: "wishlist_items"
  """
  delete_wishlist_items(
    """filter the rows which have to be deleted"""
    where: wishlist_items_bool_exp!
  ): wishlist_items_mutation_response

  """
  delete single row from the table: "wishlist_items"
  """
  delete_wishlist_items_by_pk(id: uuid!): wishlist_items

  """
  delete data from the table: "wishlists"
  """
  delete_wishlists(
    """filter the rows which have to be deleted"""
    where: wishlists_bool_exp!
  ): wishlists_mutation_response

  """
  delete single row from the table: "wishlists"
  """
  delete_wishlists_by_pk(id: uuid!): wishlists

  """
  insert data into the table: "analytics_events"
  """
  insert_analytics_events(
    """the rows to be inserted"""
    objects: [analytics_events_insert_input!]!

    """upsert condition"""
    on_conflict: analytics_events_on_conflict
  ): analytics_events_mutation_response

  """
  insert a single row into the table: "analytics_events"
  """
  insert_analytics_events_one(
    """the row to be inserted"""
    object: analytics_events_insert_input!

    """upsert condition"""
    on_conflict: analytics_events_on_conflict
  ): analytics_events

  """
  insert data into the table: "article_categories"
  """
  insert_article_categories(
    """the rows to be inserted"""
    objects: [article_categories_insert_input!]!

    """upsert condition"""
    on_conflict: article_categories_on_conflict
  ): article_categories_mutation_response

  """
  insert a single row into the table: "article_categories"
  """
  insert_article_categories_one(
    """the row to be inserted"""
    object: article_categories_insert_input!

    """upsert condition"""
    on_conflict: article_categories_on_conflict
  ): article_categories

  """
  insert data into the table: "article_category_assignments"
  """
  insert_article_category_assignments(
    """the rows to be inserted"""
    objects: [article_category_assignments_insert_input!]!

    """upsert condition"""
    on_conflict: article_category_assignments_on_conflict
  ): article_category_assignments_mutation_response

  """
  insert a single row into the table: "article_category_assignments"
  """
  insert_article_category_assignments_one(
    """the row to be inserted"""
    object: article_category_assignments_insert_input!

    """upsert condition"""
    on_conflict: article_category_assignments_on_conflict
  ): article_category_assignments

  """
  insert data into the table: "article_tags"
  """
  insert_article_tags(
    """the rows to be inserted"""
    objects: [article_tags_insert_input!]!

    """upsert condition"""
    on_conflict: article_tags_on_conflict
  ): article_tags_mutation_response

  """
  insert a single row into the table: "article_tags"
  """
  insert_article_tags_one(
    """the row to be inserted"""
    object: article_tags_insert_input!

    """upsert condition"""
    on_conflict: article_tags_on_conflict
  ): article_tags

  """
  insert data into the table: "articles"
  """
  insert_articles(
    """the rows to be inserted"""
    objects: [articles_insert_input!]!

    """upsert condition"""
    on_conflict: articles_on_conflict
  ): articles_mutation_response

  """
  insert a single row into the table: "articles"
  """
  insert_articles_one(
    """the row to be inserted"""
    object: articles_insert_input!

    """upsert condition"""
    on_conflict: articles_on_conflict
  ): articles

  """
  insert data into the table: "author_articles"
  """
  insert_author_articles(
    """the rows to be inserted"""
    objects: [author_articles_insert_input!]!

    """upsert condition"""
    on_conflict: author_articles_on_conflict
  ): author_articles_mutation_response

  """
  insert a single row into the table: "author_articles"
  """
  insert_author_articles_one(
    """the row to be inserted"""
    object: author_articles_insert_input!

    """upsert condition"""
    on_conflict: author_articles_on_conflict
  ): author_articles

  """
  insert data into the table: "authors"
  """
  insert_authors(
    """the rows to be inserted"""
    objects: [authors_insert_input!]!

    """upsert condition"""
    on_conflict: authors_on_conflict
  ): authors_mutation_response

  """
  insert a single row into the table: "authors"
  """
  insert_authors_one(
    """the row to be inserted"""
    object: authors_insert_input!

    """upsert condition"""
    on_conflict: authors_on_conflict
  ): authors

  """
  insert data into the table: "blocks"
  """
  insert_blocks(
    """the rows to be inserted"""
    objects: [blocks_insert_input!]!

    """upsert condition"""
    on_conflict: blocks_on_conflict
  ): blocks_mutation_response

  """
  insert a single row into the table: "blocks"
  """
  insert_blocks_one(
    """the row to be inserted"""
    object: blocks_insert_input!

    """upsert condition"""
    on_conflict: blocks_on_conflict
  ): blocks

  """
  insert data into the table: "bookmarks"
  """
  insert_bookmarks(
    """the rows to be inserted"""
    objects: [bookmarks_insert_input!]!

    """upsert condition"""
    on_conflict: bookmarks_on_conflict
  ): bookmarks_mutation_response

  """
  insert a single row into the table: "bookmarks"
  """
  insert_bookmarks_one(
    """the row to be inserted"""
    object: bookmarks_insert_input!

    """upsert condition"""
    on_conflict: bookmarks_on_conflict
  ): bookmarks

  """
  insert data into the table: "brands"
  """
  insert_brands(
    """the rows to be inserted"""
    objects: [brands_insert_input!]!

    """upsert condition"""
    on_conflict: brands_on_conflict
  ): brands_mutation_response

  """
  insert a single row into the table: "brands"
  """
  insert_brands_one(
    """the row to be inserted"""
    object: brands_insert_input!

    """upsert condition"""
    on_conflict: brands_on_conflict
  ): brands

  """
  insert data into the table: "cart_items"
  """
  insert_cart_items(
    """the rows to be inserted"""
    objects: [cart_items_insert_input!]!

    """upsert condition"""
    on_conflict: cart_items_on_conflict
  ): cart_items_mutation_response

  """
  insert a single row into the table: "cart_items"
  """
  insert_cart_items_one(
    """the row to be inserted"""
    object: cart_items_insert_input!

    """upsert condition"""
    on_conflict: cart_items_on_conflict
  ): cart_items

  """
  insert data into the table: "carts"
  """
  insert_carts(
    """the rows to be inserted"""
    objects: [carts_insert_input!]!

    """upsert condition"""
    on_conflict: carts_on_conflict
  ): carts_mutation_response

  """
  insert a single row into the table: "carts"
  """
  insert_carts_one(
    """the row to be inserted"""
    object: carts_insert_input!

    """upsert condition"""
    on_conflict: carts_on_conflict
  ): carts

  """
  insert data into the table: "cities"
  """
  insert_cities(
    """the rows to be inserted"""
    objects: [cities_insert_input!]!

    """upsert condition"""
    on_conflict: cities_on_conflict
  ): cities_mutation_response

  """
  insert a single row into the table: "cities"
  """
  insert_cities_one(
    """the row to be inserted"""
    object: cities_insert_input!

    """upsert condition"""
    on_conflict: cities_on_conflict
  ): cities

  """
  insert data into the table: "collections"
  """
  insert_collections(
    """the rows to be inserted"""
    objects: [collections_insert_input!]!

    """upsert condition"""
    on_conflict: collections_on_conflict
  ): collections_mutation_response

  """
  insert a single row into the table: "collections"
  """
  insert_collections_one(
    """the row to be inserted"""
    object: collections_insert_input!

    """upsert condition"""
    on_conflict: collections_on_conflict
  ): collections

  """
  insert data into the table: "colors"
  """
  insert_colors(
    """the rows to be inserted"""
    objects: [colors_insert_input!]!

    """upsert condition"""
    on_conflict: colors_on_conflict
  ): colors_mutation_response

  """
  insert a single row into the table: "colors"
  """
  insert_colors_one(
    """the row to be inserted"""
    object: colors_insert_input!

    """upsert condition"""
    on_conflict: colors_on_conflict
  ): colors

  """
  insert data into the table: "comments"
  """
  insert_comments(
    """the rows to be inserted"""
    objects: [comments_insert_input!]!

    """upsert condition"""
    on_conflict: comments_on_conflict
  ): comments_mutation_response

  """
  insert a single row into the table: "comments"
  """
  insert_comments_one(
    """the row to be inserted"""
    object: comments_insert_input!

    """upsert condition"""
    on_conflict: comments_on_conflict
  ): comments

  """
  insert data into the table: "conversation_participants"
  """
  insert_conversation_participants(
    """the rows to be inserted"""
    objects: [conversation_participants_insert_input!]!

    """upsert condition"""
    on_conflict: conversation_participants_on_conflict
  ): conversation_participants_mutation_response

  """
  insert a single row into the table: "conversation_participants"
  """
  insert_conversation_participants_one(
    """the row to be inserted"""
    object: conversation_participants_insert_input!

    """upsert condition"""
    on_conflict: conversation_participants_on_conflict
  ): conversation_participants

  """
  insert data into the table: "conversations"
  """
  insert_conversations(
    """the rows to be inserted"""
    objects: [conversations_insert_input!]!

    """upsert condition"""
    on_conflict: conversations_on_conflict
  ): conversations_mutation_response

  """
  insert a single row into the table: "conversations"
  """
  insert_conversations_one(
    """the row to be inserted"""
    object: conversations_insert_input!

    """upsert condition"""
    on_conflict: conversations_on_conflict
  ): conversations

  """
  insert data into the table: "countries"
  """
  insert_countries(
    """the rows to be inserted"""
    objects: [countries_insert_input!]!

    """upsert condition"""
    on_conflict: countries_on_conflict
  ): countries_mutation_response

  """
  insert a single row into the table: "countries"
  """
  insert_countries_one(
    """the row to be inserted"""
    object: countries_insert_input!

    """upsert condition"""
    on_conflict: countries_on_conflict
  ): countries

  """
  insert data into the table: "coupons"
  """
  insert_coupons(
    """the rows to be inserted"""
    objects: [coupons_insert_input!]!

    """upsert condition"""
    on_conflict: coupons_on_conflict
  ): coupons_mutation_response

  """
  insert a single row into the table: "coupons"
  """
  insert_coupons_one(
    """the row to be inserted"""
    object: coupons_insert_input!

    """upsert condition"""
    on_conflict: coupons_on_conflict
  ): coupons

  """
  insert data into the table: "currencies"
  """
  insert_currencies(
    """the rows to be inserted"""
    objects: [currencies_insert_input!]!

    """upsert condition"""
    on_conflict: currencies_on_conflict
  ): currencies_mutation_response

  """
  insert a single row into the table: "currencies"
  """
  insert_currencies_one(
    """the row to be inserted"""
    object: currencies_insert_input!

    """upsert condition"""
    on_conflict: currencies_on_conflict
  ): currencies

  """
  insert data into the table: "customer_addresses"
  """
  insert_customer_addresses(
    """the rows to be inserted"""
    objects: [customer_addresses_insert_input!]!

    """upsert condition"""
    on_conflict: customer_addresses_on_conflict
  ): customer_addresses_mutation_response

  """
  insert a single row into the table: "customer_addresses"
  """
  insert_customer_addresses_one(
    """the row to be inserted"""
    object: customer_addresses_insert_input!

    """upsert condition"""
    on_conflict: customer_addresses_on_conflict
  ): customer_addresses

  """
  insert data into the table: "customer_stores"
  """
  insert_customer_stores(
    """the rows to be inserted"""
    objects: [customer_stores_insert_input!]!

    """upsert condition"""
    on_conflict: customer_stores_on_conflict
  ): customer_stores_mutation_response

  """
  insert a single row into the table: "customer_stores"
  """
  insert_customer_stores_one(
    """the row to be inserted"""
    object: customer_stores_insert_input!

    """upsert condition"""
    on_conflict: customer_stores_on_conflict
  ): customer_stores

  """
  insert data into the table: "customers"
  """
  insert_customers(
    """the rows to be inserted"""
    objects: [customers_insert_input!]!

    """upsert condition"""
    on_conflict: customers_on_conflict
  ): customers_mutation_response

  """
  insert a single row into the table: "customers"
  """
  insert_customers_one(
    """the row to be inserted"""
    object: customers_insert_input!

    """upsert condition"""
    on_conflict: customers_on_conflict
  ): customers

  """
  insert data into the table: "districts"
  """
  insert_districts(
    """the rows to be inserted"""
    objects: [districts_insert_input!]!

    """upsert condition"""
    on_conflict: districts_on_conflict
  ): districts_mutation_response

  """
  insert a single row into the table: "districts"
  """
  insert_districts_one(
    """the row to be inserted"""
    object: districts_insert_input!

    """upsert condition"""
    on_conflict: districts_on_conflict
  ): districts

  """
  insert data into the table: "ec_categories"
  """
  insert_ec_categories(
    """the rows to be inserted"""
    objects: [ec_categories_insert_input!]!

    """upsert condition"""
    on_conflict: ec_categories_on_conflict
  ): ec_categories_mutation_response

  """
  insert a single row into the table: "ec_categories"
  """
  insert_ec_categories_one(
    """the row to be inserted"""
    object: ec_categories_insert_input!

    """upsert condition"""
    on_conflict: ec_categories_on_conflict
  ): ec_categories

  """
  insert data into the table: "follows"
  """
  insert_follows(
    """the rows to be inserted"""
    objects: [follows_insert_input!]!

    """upsert condition"""
    on_conflict: follows_on_conflict
  ): follows_mutation_response

  """
  insert a single row into the table: "follows"
  """
  insert_follows_one(
    """the row to be inserted"""
    object: follows_insert_input!

    """upsert condition"""
    on_conflict: follows_on_conflict
  ): follows

  """
  insert data into the table: "form_submissions"
  """
  insert_form_submissions(
    """the rows to be inserted"""
    objects: [form_submissions_insert_input!]!

    """upsert condition"""
    on_conflict: form_submissions_on_conflict
  ): form_submissions_mutation_response

  """
  insert a single row into the table: "form_submissions"
  """
  insert_form_submissions_one(
    """the row to be inserted"""
    object: form_submissions_insert_input!

    """upsert condition"""
    on_conflict: form_submissions_on_conflict
  ): form_submissions

  """
  insert data into the table: "forms"
  """
  insert_forms(
    """the rows to be inserted"""
    objects: [forms_insert_input!]!

    """upsert condition"""
    on_conflict: forms_on_conflict
  ): forms_mutation_response

  """
  insert a single row into the table: "forms"
  """
  insert_forms_one(
    """the row to be inserted"""
    object: forms_insert_input!

    """upsert condition"""
    on_conflict: forms_on_conflict
  ): forms

  """
  insert data into the table: "hashtags"
  """
  insert_hashtags(
    """the rows to be inserted"""
    objects: [hashtags_insert_input!]!

    """upsert condition"""
    on_conflict: hashtags_on_conflict
  ): hashtags_mutation_response

  """
  insert a single row into the table: "hashtags"
  """
  insert_hashtags_one(
    """the row to be inserted"""
    object: hashtags_insert_input!

    """upsert condition"""
    on_conflict: hashtags_on_conflict
  ): hashtags

  """
  insert data into the table: "inventory_levels"
  """
  insert_inventory_levels(
    """the rows to be inserted"""
    objects: [inventory_levels_insert_input!]!

    """upsert condition"""
    on_conflict: inventory_levels_on_conflict
  ): inventory_levels_mutation_response

  """
  insert a single row into the table: "inventory_levels"
  """
  insert_inventory_levels_one(
    """the row to be inserted"""
    object: inventory_levels_insert_input!

    """upsert condition"""
    on_conflict: inventory_levels_on_conflict
  ): inventory_levels

  """
  insert data into the table: "inventory_locations"
  """
  insert_inventory_locations(
    """the rows to be inserted"""
    objects: [inventory_locations_insert_input!]!

    """upsert condition"""
    on_conflict: inventory_locations_on_conflict
  ): inventory_locations_mutation_response

  """
  insert a single row into the table: "inventory_locations"
  """
  insert_inventory_locations_one(
    """the row to be inserted"""
    object: inventory_locations_insert_input!

    """upsert condition"""
    on_conflict: inventory_locations_on_conflict
  ): inventory_locations

  """
  insert data into the table: "likes"
  """
  insert_likes(
    """the rows to be inserted"""
    objects: [likes_insert_input!]!

    """upsert condition"""
    on_conflict: likes_on_conflict
  ): likes_mutation_response

  """
  insert a single row into the table: "likes"
  """
  insert_likes_one(
    """the row to be inserted"""
    object: likes_insert_input!

    """upsert condition"""
    on_conflict: likes_on_conflict
  ): likes

  """
  insert data into the table: "media_files"
  """
  insert_media_files(
    """the rows to be inserted"""
    objects: [media_files_insert_input!]!

    """upsert condition"""
    on_conflict: media_files_on_conflict
  ): media_files_mutation_response

  """
  insert a single row into the table: "media_files"
  """
  insert_media_files_one(
    """the row to be inserted"""
    object: media_files_insert_input!

    """upsert condition"""
    on_conflict: media_files_on_conflict
  ): media_files

  """
  insert data into the table: "media_folders"
  """
  insert_media_folders(
    """the rows to be inserted"""
    objects: [media_folders_insert_input!]!

    """upsert condition"""
    on_conflict: media_folders_on_conflict
  ): media_folders_mutation_response

  """
  insert a single row into the table: "media_folders"
  """
  insert_media_folders_one(
    """the row to be inserted"""
    object: media_folders_insert_input!

    """upsert condition"""
    on_conflict: media_folders_on_conflict
  ): media_folders

  """
  insert data into the table: "mentions"
  """
  insert_mentions(
    """the rows to be inserted"""
    objects: [mentions_insert_input!]!

    """upsert condition"""
    on_conflict: mentions_on_conflict
  ): mentions_mutation_response

  """
  insert a single row into the table: "mentions"
  """
  insert_mentions_one(
    """the row to be inserted"""
    object: mentions_insert_input!

    """upsert condition"""
    on_conflict: mentions_on_conflict
  ): mentions

  """
  insert data into the table: "menu_items"
  """
  insert_menu_items(
    """the rows to be inserted"""
    objects: [menu_items_insert_input!]!

    """upsert condition"""
    on_conflict: menu_items_on_conflict
  ): menu_items_mutation_response

  """
  insert a single row into the table: "menu_items"
  """
  insert_menu_items_one(
    """the row to be inserted"""
    object: menu_items_insert_input!

    """upsert condition"""
    on_conflict: menu_items_on_conflict
  ): menu_items

  """
  insert data into the table: "menus"
  """
  insert_menus(
    """the rows to be inserted"""
    objects: [menus_insert_input!]!

    """upsert condition"""
    on_conflict: menus_on_conflict
  ): menus_mutation_response

  """
  insert a single row into the table: "menus"
  """
  insert_menus_one(
    """the row to be inserted"""
    object: menus_insert_input!

    """upsert condition"""
    on_conflict: menus_on_conflict
  ): menus

  """
  insert data into the table: "message_reactions"
  """
  insert_message_reactions(
    """the rows to be inserted"""
    objects: [message_reactions_insert_input!]!

    """upsert condition"""
    on_conflict: message_reactions_on_conflict
  ): message_reactions_mutation_response

  """
  insert a single row into the table: "message_reactions"
  """
  insert_message_reactions_one(
    """the row to be inserted"""
    object: message_reactions_insert_input!

    """upsert condition"""
    on_conflict: message_reactions_on_conflict
  ): message_reactions

  """
  insert data into the table: "messages"
  """
  insert_messages(
    """the rows to be inserted"""
    objects: [messages_insert_input!]!

    """upsert condition"""
    on_conflict: messages_on_conflict
  ): messages_mutation_response

  """
  insert a single row into the table: "messages"
  """
  insert_messages_one(
    """the row to be inserted"""
    object: messages_insert_input!

    """upsert condition"""
    on_conflict: messages_on_conflict
  ): messages

  """
  insert data into the table: "neighborhoods"
  """
  insert_neighborhoods(
    """the rows to be inserted"""
    objects: [neighborhoods_insert_input!]!

    """upsert condition"""
    on_conflict: neighborhoods_on_conflict
  ): neighborhoods_mutation_response

  """
  insert a single row into the table: "neighborhoods"
  """
  insert_neighborhoods_one(
    """the row to be inserted"""
    object: neighborhoods_insert_input!

    """upsert condition"""
    on_conflict: neighborhoods_on_conflict
  ): neighborhoods

  """
  insert data into the table: "notifications"
  """
  insert_notifications(
    """the rows to be inserted"""
    objects: [notifications_insert_input!]!

    """upsert condition"""
    on_conflict: notifications_on_conflict
  ): notifications_mutation_response

  """
  insert a single row into the table: "notifications"
  """
  insert_notifications_one(
    """the row to be inserted"""
    object: notifications_insert_input!

    """upsert condition"""
    on_conflict: notifications_on_conflict
  ): notifications

  """
  insert data into the table: "order_coupons"
  """
  insert_order_coupons(
    """the rows to be inserted"""
    objects: [order_coupons_insert_input!]!

    """upsert condition"""
    on_conflict: order_coupons_on_conflict
  ): order_coupons_mutation_response

  """
  insert a single row into the table: "order_coupons"
  """
  insert_order_coupons_one(
    """the row to be inserted"""
    object: order_coupons_insert_input!

    """upsert condition"""
    on_conflict: order_coupons_on_conflict
  ): order_coupons

  """
  insert data into the table: "order_items"
  """
  insert_order_items(
    """the rows to be inserted"""
    objects: [order_items_insert_input!]!

    """upsert condition"""
    on_conflict: order_items_on_conflict
  ): order_items_mutation_response

  """
  insert a single row into the table: "order_items"
  """
  insert_order_items_one(
    """the row to be inserted"""
    object: order_items_insert_input!

    """upsert condition"""
    on_conflict: order_items_on_conflict
  ): order_items

  """
  insert data into the table: "order_statuses"
  """
  insert_order_statuses(
    """the rows to be inserted"""
    objects: [order_statuses_insert_input!]!

    """upsert condition"""
    on_conflict: order_statuses_on_conflict
  ): order_statuses_mutation_response

  """
  insert a single row into the table: "order_statuses"
  """
  insert_order_statuses_one(
    """the row to be inserted"""
    object: order_statuses_insert_input!

    """upsert condition"""
    on_conflict: order_statuses_on_conflict
  ): order_statuses

  """
  insert data into the table: "orders"
  """
  insert_orders(
    """the rows to be inserted"""
    objects: [orders_insert_input!]!

    """upsert condition"""
    on_conflict: orders_on_conflict
  ): orders_mutation_response

  """
  insert a single row into the table: "orders"
  """
  insert_orders_one(
    """the row to be inserted"""
    object: orders_insert_input!

    """upsert condition"""
    on_conflict: orders_on_conflict
  ): orders

  """
  insert data into the table: "page_templates"
  """
  insert_page_templates(
    """the rows to be inserted"""
    objects: [page_templates_insert_input!]!

    """upsert condition"""
    on_conflict: page_templates_on_conflict
  ): page_templates_mutation_response

  """
  insert a single row into the table: "page_templates"
  """
  insert_page_templates_one(
    """the row to be inserted"""
    object: page_templates_insert_input!

    """upsert condition"""
    on_conflict: page_templates_on_conflict
  ): page_templates

  """
  insert data into the table: "page_versions"
  """
  insert_page_versions(
    """the rows to be inserted"""
    objects: [page_versions_insert_input!]!

    """upsert condition"""
    on_conflict: page_versions_on_conflict
  ): page_versions_mutation_response

  """
  insert a single row into the table: "page_versions"
  """
  insert_page_versions_one(
    """the row to be inserted"""
    object: page_versions_insert_input!

    """upsert condition"""
    on_conflict: page_versions_on_conflict
  ): page_versions

  """
  insert data into the table: "pages"
  """
  insert_pages(
    """the rows to be inserted"""
    objects: [pages_insert_input!]!

    """upsert condition"""
    on_conflict: pages_on_conflict
  ): pages_mutation_response

  """
  insert a single row into the table: "pages"
  """
  insert_pages_one(
    """the row to be inserted"""
    object: pages_insert_input!

    """upsert condition"""
    on_conflict: pages_on_conflict
  ): pages

  """
  insert data into the table: "payment_methods"
  """
  insert_payment_methods(
    """the rows to be inserted"""
    objects: [payment_methods_insert_input!]!

    """upsert condition"""
    on_conflict: payment_methods_on_conflict
  ): payment_methods_mutation_response

  """
  insert a single row into the table: "payment_methods"
  """
  insert_payment_methods_one(
    """the row to be inserted"""
    object: payment_methods_insert_input!

    """upsert condition"""
    on_conflict: payment_methods_on_conflict
  ): payment_methods

  """
  insert data into the table: "payment_statuses"
  """
  insert_payment_statuses(
    """the rows to be inserted"""
    objects: [payment_statuses_insert_input!]!

    """upsert condition"""
    on_conflict: payment_statuses_on_conflict
  ): payment_statuses_mutation_response

  """
  insert a single row into the table: "payment_statuses"
  """
  insert_payment_statuses_one(
    """the row to be inserted"""
    object: payment_statuses_insert_input!

    """upsert condition"""
    on_conflict: payment_statuses_on_conflict
  ): payment_statuses

  """
  insert data into the table: "payments"
  """
  insert_payments(
    """the rows to be inserted"""
    objects: [payments_insert_input!]!

    """upsert condition"""
    on_conflict: payments_on_conflict
  ): payments_mutation_response

  """
  insert a single row into the table: "payments"
  """
  insert_payments_one(
    """the row to be inserted"""
    object: payments_insert_input!

    """upsert condition"""
    on_conflict: payments_on_conflict
  ): payments

  """
  insert data into the table: "permissions"
  """
  insert_permissions(
    """the rows to be inserted"""
    objects: [permissions_insert_input!]!

    """upsert condition"""
    on_conflict: permissions_on_conflict
  ): permissions_mutation_response

  """
  insert a single row into the table: "permissions"
  """
  insert_permissions_one(
    """the row to be inserted"""
    object: permissions_insert_input!

    """upsert condition"""
    on_conflict: permissions_on_conflict
  ): permissions

  """
  insert data into the table: "post_hashtags"
  """
  insert_post_hashtags(
    """the rows to be inserted"""
    objects: [post_hashtags_insert_input!]!

    """upsert condition"""
    on_conflict: post_hashtags_on_conflict
  ): post_hashtags_mutation_response

  """
  insert a single row into the table: "post_hashtags"
  """
  insert_post_hashtags_one(
    """the row to be inserted"""
    object: post_hashtags_insert_input!

    """upsert condition"""
    on_conflict: post_hashtags_on_conflict
  ): post_hashtags

  """
  insert data into the table: "post_media"
  """
  insert_post_media(
    """the rows to be inserted"""
    objects: [post_media_insert_input!]!

    """upsert condition"""
    on_conflict: post_media_on_conflict
  ): post_media_mutation_response

  """
  insert a single row into the table: "post_media"
  """
  insert_post_media_one(
    """the row to be inserted"""
    object: post_media_insert_input!

    """upsert condition"""
    on_conflict: post_media_on_conflict
  ): post_media

  """
  insert data into the table: "posts"
  """
  insert_posts(
    """the rows to be inserted"""
    objects: [posts_insert_input!]!

    """upsert condition"""
    on_conflict: posts_on_conflict
  ): posts_mutation_response

  """
  insert a single row into the table: "posts"
  """
  insert_posts_one(
    """the row to be inserted"""
    object: posts_insert_input!

    """upsert condition"""
    on_conflict: posts_on_conflict
  ): posts

  """
  insert data into the table: "product_categories"
  """
  insert_product_categories(
    """the rows to be inserted"""
    objects: [product_categories_insert_input!]!

    """upsert condition"""
    on_conflict: product_categories_on_conflict
  ): product_categories_mutation_response

  """
  insert a single row into the table: "product_categories"
  """
  insert_product_categories_one(
    """the row to be inserted"""
    object: product_categories_insert_input!

    """upsert condition"""
    on_conflict: product_categories_on_conflict
  ): product_categories

  """
  insert data into the table: "product_collections"
  """
  insert_product_collections(
    """the rows to be inserted"""
    objects: [product_collections_insert_input!]!

    """upsert condition"""
    on_conflict: product_collections_on_conflict
  ): product_collections_mutation_response

  """
  insert a single row into the table: "product_collections"
  """
  insert_product_collections_one(
    """the row to be inserted"""
    object: product_collections_insert_input!

    """upsert condition"""
    on_conflict: product_collections_on_conflict
  ): product_collections

  """
  insert data into the table: "product_images"
  """
  insert_product_images(
    """the rows to be inserted"""
    objects: [product_images_insert_input!]!

    """upsert condition"""
    on_conflict: product_images_on_conflict
  ): product_images_mutation_response

  """
  insert a single row into the table: "product_images"
  """
  insert_product_images_one(
    """the row to be inserted"""
    object: product_images_insert_input!

    """upsert condition"""
    on_conflict: product_images_on_conflict
  ): product_images

  """
  insert data into the table: "product_variants"
  """
  insert_product_variants(
    """the rows to be inserted"""
    objects: [product_variants_insert_input!]!

    """upsert condition"""
    on_conflict: product_variants_on_conflict
  ): product_variants_mutation_response

  """
  insert a single row into the table: "product_variants"
  """
  insert_product_variants_one(
    """the row to be inserted"""
    object: product_variants_insert_input!

    """upsert condition"""
    on_conflict: product_variants_on_conflict
  ): product_variants

  """
  insert data into the table: "products"
  """
  insert_products(
    """the rows to be inserted"""
    objects: [products_insert_input!]!

    """upsert condition"""
    on_conflict: products_on_conflict
  ): products_mutation_response

  """
  insert a single row into the table: "products"
  """
  insert_products_one(
    """the row to be inserted"""
    object: products_insert_input!

    """upsert condition"""
    on_conflict: products_on_conflict
  ): products

  """
  insert data into the table: "redirects"
  """
  insert_redirects(
    """the rows to be inserted"""
    objects: [redirects_insert_input!]!

    """upsert condition"""
    on_conflict: redirects_on_conflict
  ): redirects_mutation_response

  """
  insert a single row into the table: "redirects"
  """
  insert_redirects_one(
    """the row to be inserted"""
    object: redirects_insert_input!

    """upsert condition"""
    on_conflict: redirects_on_conflict
  ): redirects

  """
  insert data into the table: "regions"
  """
  insert_regions(
    """the rows to be inserted"""
    objects: [regions_insert_input!]!

    """upsert condition"""
    on_conflict: regions_on_conflict
  ): regions_mutation_response

  """
  insert a single row into the table: "regions"
  """
  insert_regions_one(
    """the row to be inserted"""
    object: regions_insert_input!

    """upsert condition"""
    on_conflict: regions_on_conflict
  ): regions

  """
  insert data into the table: "related_products"
  """
  insert_related_products(
    """the rows to be inserted"""
    objects: [related_products_insert_input!]!

    """upsert condition"""
    on_conflict: related_products_on_conflict
  ): related_products_mutation_response

  """
  insert a single row into the table: "related_products"
  """
  insert_related_products_one(
    """the row to be inserted"""
    object: related_products_insert_input!

    """upsert condition"""
    on_conflict: related_products_on_conflict
  ): related_products

  """
  insert data into the table: "report_statuses"
  """
  insert_report_statuses(
    """the rows to be inserted"""
    objects: [report_statuses_insert_input!]!

    """upsert condition"""
    on_conflict: report_statuses_on_conflict
  ): report_statuses_mutation_response

  """
  insert a single row into the table: "report_statuses"
  """
  insert_report_statuses_one(
    """the row to be inserted"""
    object: report_statuses_insert_input!

    """upsert condition"""
    on_conflict: report_statuses_on_conflict
  ): report_statuses

  """
  insert data into the table: "reports"
  """
  insert_reports(
    """the rows to be inserted"""
    objects: [reports_insert_input!]!

    """upsert condition"""
    on_conflict: reports_on_conflict
  ): reports_mutation_response

  """
  insert a single row into the table: "reports"
  """
  insert_reports_one(
    """the row to be inserted"""
    object: reports_insert_input!

    """upsert condition"""
    on_conflict: reports_on_conflict
  ): reports

  """
  insert data into the table: "return_requests"
  """
  insert_return_requests(
    """the rows to be inserted"""
    objects: [return_requests_insert_input!]!

    """upsert condition"""
    on_conflict: return_requests_on_conflict
  ): return_requests_mutation_response

  """
  insert a single row into the table: "return_requests"
  """
  insert_return_requests_one(
    """the row to be inserted"""
    object: return_requests_insert_input!

    """upsert condition"""
    on_conflict: return_requests_on_conflict
  ): return_requests

  """
  insert data into the table: "return_statuses"
  """
  insert_return_statuses(
    """the rows to be inserted"""
    objects: [return_statuses_insert_input!]!

    """upsert condition"""
    on_conflict: return_statuses_on_conflict
  ): return_statuses_mutation_response

  """
  insert a single row into the table: "return_statuses"
  """
  insert_return_statuses_one(
    """the row to be inserted"""
    object: return_statuses_insert_input!

    """upsert condition"""
    on_conflict: return_statuses_on_conflict
  ): return_statuses

  """
  insert data into the table: "reviews"
  """
  insert_reviews(
    """the rows to be inserted"""
    objects: [reviews_insert_input!]!

    """upsert condition"""
    on_conflict: reviews_on_conflict
  ): reviews_mutation_response

  """
  insert a single row into the table: "reviews"
  """
  insert_reviews_one(
    """the row to be inserted"""
    object: reviews_insert_input!

    """upsert condition"""
    on_conflict: reviews_on_conflict
  ): reviews

  """
  insert data into the table: "role_permissions"
  """
  insert_role_permissions(
    """the rows to be inserted"""
    objects: [role_permissions_insert_input!]!

    """upsert condition"""
    on_conflict: role_permissions_on_conflict
  ): role_permissions_mutation_response

  """
  insert a single row into the table: "role_permissions"
  """
  insert_role_permissions_one(
    """the row to be inserted"""
    object: role_permissions_insert_input!

    """upsert condition"""
    on_conflict: role_permissions_on_conflict
  ): role_permissions

  """
  insert data into the table: "roles"
  """
  insert_roles(
    """the rows to be inserted"""
    objects: [roles_insert_input!]!

    """upsert condition"""
    on_conflict: roles_on_conflict
  ): roles_mutation_response

  """
  insert a single row into the table: "roles"
  """
  insert_roles_one(
    """the row to be inserted"""
    object: roles_insert_input!

    """upsert condition"""
    on_conflict: roles_on_conflict
  ): roles

  """
  insert data into the table: "seo_settings"
  """
  insert_seo_settings(
    """the rows to be inserted"""
    objects: [seo_settings_insert_input!]!

    """upsert condition"""
    on_conflict: seo_settings_on_conflict
  ): seo_settings_mutation_response

  """
  insert a single row into the table: "seo_settings"
  """
  insert_seo_settings_one(
    """the row to be inserted"""
    object: seo_settings_insert_input!

    """upsert condition"""
    on_conflict: seo_settings_on_conflict
  ): seo_settings

  """
  insert data into the table: "shipment_statuses"
  """
  insert_shipment_statuses(
    """the rows to be inserted"""
    objects: [shipment_statuses_insert_input!]!

    """upsert condition"""
    on_conflict: shipment_statuses_on_conflict
  ): shipment_statuses_mutation_response

  """
  insert a single row into the table: "shipment_statuses"
  """
  insert_shipment_statuses_one(
    """the row to be inserted"""
    object: shipment_statuses_insert_input!

    """upsert condition"""
    on_conflict: shipment_statuses_on_conflict
  ): shipment_statuses

  """
  insert data into the table: "shipments"
  """
  insert_shipments(
    """the rows to be inserted"""
    objects: [shipments_insert_input!]!

    """upsert condition"""
    on_conflict: shipments_on_conflict
  ): shipments_mutation_response

  """
  insert a single row into the table: "shipments"
  """
  insert_shipments_one(
    """the row to be inserted"""
    object: shipments_insert_input!

    """upsert condition"""
    on_conflict: shipments_on_conflict
  ): shipments

  """
  insert data into the table: "shipping_carriers"
  """
  insert_shipping_carriers(
    """the rows to be inserted"""
    objects: [shipping_carriers_insert_input!]!

    """upsert condition"""
    on_conflict: shipping_carriers_on_conflict
  ): shipping_carriers_mutation_response

  """
  insert a single row into the table: "shipping_carriers"
  """
  insert_shipping_carriers_one(
    """the row to be inserted"""
    object: shipping_carriers_insert_input!

    """upsert condition"""
    on_conflict: shipping_carriers_on_conflict
  ): shipping_carriers

  """
  insert data into the table: "site_authors"
  """
  insert_site_authors(
    """the rows to be inserted"""
    objects: [site_authors_insert_input!]!

    """upsert condition"""
    on_conflict: site_authors_on_conflict
  ): site_authors_mutation_response

  """
  insert a single row into the table: "site_authors"
  """
  insert_site_authors_one(
    """the row to be inserted"""
    object: site_authors_insert_input!

    """upsert condition"""
    on_conflict: site_authors_on_conflict
  ): site_authors

  """
  insert data into the table: "sites"
  """
  insert_sites(
    """the rows to be inserted"""
    objects: [sites_insert_input!]!

    """upsert condition"""
    on_conflict: sites_on_conflict
  ): sites_mutation_response

  """
  insert a single row into the table: "sites"
  """
  insert_sites_one(
    """the row to be inserted"""
    object: sites_insert_input!

    """upsert condition"""
    on_conflict: sites_on_conflict
  ): sites

  """
  insert data into the table: "sizes"
  """
  insert_sizes(
    """the rows to be inserted"""
    objects: [sizes_insert_input!]!

    """upsert condition"""
    on_conflict: sizes_on_conflict
  ): sizes_mutation_response

  """
  insert a single row into the table: "sizes"
  """
  insert_sizes_one(
    """the row to be inserted"""
    object: sizes_insert_input!

    """upsert condition"""
    on_conflict: sizes_on_conflict
  ): sizes

  """
  insert data into the table: "store_currencies"
  """
  insert_store_currencies(
    """the rows to be inserted"""
    objects: [store_currencies_insert_input!]!

    """upsert condition"""
    on_conflict: store_currencies_on_conflict
  ): store_currencies_mutation_response

  """
  insert a single row into the table: "store_currencies"
  """
  insert_store_currencies_one(
    """the row to be inserted"""
    object: store_currencies_insert_input!

    """upsert condition"""
    on_conflict: store_currencies_on_conflict
  ): store_currencies

  """
  insert data into the table: "store_payment_methods"
  """
  insert_store_payment_methods(
    """the rows to be inserted"""
    objects: [store_payment_methods_insert_input!]!

    """upsert condition"""
    on_conflict: store_payment_methods_on_conflict
  ): store_payment_methods_mutation_response

  """
  insert a single row into the table: "store_payment_methods"
  """
  insert_store_payment_methods_one(
    """the row to be inserted"""
    object: store_payment_methods_insert_input!

    """upsert condition"""
    on_conflict: store_payment_methods_on_conflict
  ): store_payment_methods

  """
  insert data into the table: "store_shipping_carriers"
  """
  insert_store_shipping_carriers(
    """the rows to be inserted"""
    objects: [store_shipping_carriers_insert_input!]!

    """upsert condition"""
    on_conflict: store_shipping_carriers_on_conflict
  ): store_shipping_carriers_mutation_response

  """
  insert a single row into the table: "store_shipping_carriers"
  """
  insert_store_shipping_carriers_one(
    """the row to be inserted"""
    object: store_shipping_carriers_insert_input!

    """upsert condition"""
    on_conflict: store_shipping_carriers_on_conflict
  ): store_shipping_carriers

  """
  insert data into the table: "stores"
  """
  insert_stores(
    """the rows to be inserted"""
    objects: [stores_insert_input!]!

    """upsert condition"""
    on_conflict: stores_on_conflict
  ): stores_mutation_response

  """
  insert a single row into the table: "stores"
  """
  insert_stores_one(
    """the row to be inserted"""
    object: stores_insert_input!

    """upsert condition"""
    on_conflict: stores_on_conflict
  ): stores

  """
  insert data into the table: "streets"
  """
  insert_streets(
    """the rows to be inserted"""
    objects: [streets_insert_input!]!

    """upsert condition"""
    on_conflict: streets_on_conflict
  ): streets_mutation_response

  """
  insert a single row into the table: "streets"
  """
  insert_streets_one(
    """the row to be inserted"""
    object: streets_insert_input!

    """upsert condition"""
    on_conflict: streets_on_conflict
  ): streets

  """
  insert data into the table: "tags"
  """
  insert_tags(
    """the rows to be inserted"""
    objects: [tags_insert_input!]!

    """upsert condition"""
    on_conflict: tags_on_conflict
  ): tags_mutation_response

  """
  insert a single row into the table: "tags"
  """
  insert_tags_one(
    """the row to be inserted"""
    object: tags_insert_input!

    """upsert condition"""
    on_conflict: tags_on_conflict
  ): tags

  """
  insert data into the table: "user_profiles"
  """
  insert_user_profiles(
    """the rows to be inserted"""
    objects: [user_profiles_insert_input!]!

    """upsert condition"""
    on_conflict: user_profiles_on_conflict
  ): user_profiles_mutation_response

  """
  insert a single row into the table: "user_profiles"
  """
  insert_user_profiles_one(
    """the row to be inserted"""
    object: user_profiles_insert_input!

    """upsert condition"""
    on_conflict: user_profiles_on_conflict
  ): user_profiles

  """
  insert data into the table: "user_roles"
  """
  insert_user_roles(
    """the rows to be inserted"""
    objects: [user_roles_insert_input!]!

    """upsert condition"""
    on_conflict: user_roles_on_conflict
  ): user_roles_mutation_response

  """
  insert a single row into the table: "user_roles"
  """
  insert_user_roles_one(
    """the row to be inserted"""
    object: user_roles_insert_input!

    """upsert condition"""
    on_conflict: user_roles_on_conflict
  ): user_roles

  """
  insert data into the table: "user_sessions"
  """
  insert_user_sessions(
    """the rows to be inserted"""
    objects: [user_sessions_insert_input!]!

    """upsert condition"""
    on_conflict: user_sessions_on_conflict
  ): user_sessions_mutation_response

  """
  insert a single row into the table: "user_sessions"
  """
  insert_user_sessions_one(
    """the row to be inserted"""
    object: user_sessions_insert_input!

    """upsert condition"""
    on_conflict: user_sessions_on_conflict
  ): user_sessions

  """
  insert data into the table: "user_settings"
  """
  insert_user_settings(
    """the rows to be inserted"""
    objects: [user_settings_insert_input!]!

    """upsert condition"""
    on_conflict: user_settings_on_conflict
  ): user_settings_mutation_response

  """
  insert a single row into the table: "user_settings"
  """
  insert_user_settings_one(
    """the row to be inserted"""
    object: user_settings_insert_input!

    """upsert condition"""
    on_conflict: user_settings_on_conflict
  ): user_settings

  """
  insert data into the table: "users"
  """
  insert_users(
    """the rows to be inserted"""
    objects: [users_insert_input!]!

    """upsert condition"""
    on_conflict: users_on_conflict
  ): users_mutation_response

  """
  insert a single row into the table: "users"
  """
  insert_users_one(
    """the row to be inserted"""
    object: users_insert_input!

    """upsert condition"""
    on_conflict: users_on_conflict
  ): users

  """
  insert data into the table: "wishlist_items"
  """
  insert_wishlist_items(
    """the rows to be inserted"""
    objects: [wishlist_items_insert_input!]!

    """upsert condition"""
    on_conflict: wishlist_items_on_conflict
  ): wishlist_items_mutation_response

  """
  insert a single row into the table: "wishlist_items"
  """
  insert_wishlist_items_one(
    """the row to be inserted"""
    object: wishlist_items_insert_input!

    """upsert condition"""
    on_conflict: wishlist_items_on_conflict
  ): wishlist_items

  """
  insert data into the table: "wishlists"
  """
  insert_wishlists(
    """the rows to be inserted"""
    objects: [wishlists_insert_input!]!

    """upsert condition"""
    on_conflict: wishlists_on_conflict
  ): wishlists_mutation_response

  """
  insert a single row into the table: "wishlists"
  """
  insert_wishlists_one(
    """the row to be inserted"""
    object: wishlists_insert_input!

    """upsert condition"""
    on_conflict: wishlists_on_conflict
  ): wishlists

  """
  update data of the table: "analytics_events"
  """
  update_analytics_events(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: analytics_events_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: analytics_events_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: analytics_events_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: analytics_events_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: analytics_events_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: analytics_events_set_input

    """filter the rows which have to be updated"""
    where: analytics_events_bool_exp!
  ): analytics_events_mutation_response

  """
  update single row of the table: "analytics_events"
  """
  update_analytics_events_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: analytics_events_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: analytics_events_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: analytics_events_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: analytics_events_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: analytics_events_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: analytics_events_set_input
    pk_columns: analytics_events_pk_columns_input!
  ): analytics_events

  """
  update multiples rows of table: "analytics_events"
  """
  update_analytics_events_many(
    """updates to execute, in order"""
    updates: [analytics_events_updates!]!
  ): [analytics_events_mutation_response]

  """
  update data of the table: "article_categories"
  """
  update_article_categories(
    """increments the numeric columns with given value of the filtered values"""
    _inc: article_categories_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: article_categories_set_input

    """filter the rows which have to be updated"""
    where: article_categories_bool_exp!
  ): article_categories_mutation_response

  """
  update single row of the table: "article_categories"
  """
  update_article_categories_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: article_categories_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: article_categories_set_input
    pk_columns: article_categories_pk_columns_input!
  ): article_categories

  """
  update multiples rows of table: "article_categories"
  """
  update_article_categories_many(
    """updates to execute, in order"""
    updates: [article_categories_updates!]!
  ): [article_categories_mutation_response]

  """
  update data of the table: "article_category_assignments"
  """
  update_article_category_assignments(
    """sets the columns of the filtered rows to the given values"""
    _set: article_category_assignments_set_input

    """filter the rows which have to be updated"""
    where: article_category_assignments_bool_exp!
  ): article_category_assignments_mutation_response

  """
  update single row of the table: "article_category_assignments"
  """
  update_article_category_assignments_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: article_category_assignments_set_input
    pk_columns: article_category_assignments_pk_columns_input!
  ): article_category_assignments

  """
  update multiples rows of table: "article_category_assignments"
  """
  update_article_category_assignments_many(
    """updates to execute, in order"""
    updates: [article_category_assignments_updates!]!
  ): [article_category_assignments_mutation_response]

  """
  update data of the table: "article_tags"
  """
  update_article_tags(
    """sets the columns of the filtered rows to the given values"""
    _set: article_tags_set_input

    """filter the rows which have to be updated"""
    where: article_tags_bool_exp!
  ): article_tags_mutation_response

  """
  update single row of the table: "article_tags"
  """
  update_article_tags_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: article_tags_set_input
    pk_columns: article_tags_pk_columns_input!
  ): article_tags

  """
  update multiples rows of table: "article_tags"
  """
  update_article_tags_many(
    """updates to execute, in order"""
    updates: [article_tags_updates!]!
  ): [article_tags_mutation_response]

  """
  update data of the table: "articles"
  """
  update_articles(
    """increments the numeric columns with given value of the filtered values"""
    _inc: articles_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: articles_set_input

    """filter the rows which have to be updated"""
    where: articles_bool_exp!
  ): articles_mutation_response

  """
  update single row of the table: "articles"
  """
  update_articles_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: articles_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: articles_set_input
    pk_columns: articles_pk_columns_input!
  ): articles

  """
  update multiples rows of table: "articles"
  """
  update_articles_many(
    """updates to execute, in order"""
    updates: [articles_updates!]!
  ): [articles_mutation_response]

  """
  update data of the table: "author_articles"
  """
  update_author_articles(
    """sets the columns of the filtered rows to the given values"""
    _set: author_articles_set_input

    """filter the rows which have to be updated"""
    where: author_articles_bool_exp!
  ): author_articles_mutation_response

  """
  update single row of the table: "author_articles"
  """
  update_author_articles_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: author_articles_set_input
    pk_columns: author_articles_pk_columns_input!
  ): author_articles

  """
  update multiples rows of table: "author_articles"
  """
  update_author_articles_many(
    """updates to execute, in order"""
    updates: [author_articles_updates!]!
  ): [author_articles_mutation_response]

  """
  update data of the table: "authors"
  """
  update_authors(
    """sets the columns of the filtered rows to the given values"""
    _set: authors_set_input

    """filter the rows which have to be updated"""
    where: authors_bool_exp!
  ): authors_mutation_response

  """
  update single row of the table: "authors"
  """
  update_authors_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: authors_set_input
    pk_columns: authors_pk_columns_input!
  ): authors

  """
  update multiples rows of table: "authors"
  """
  update_authors_many(
    """updates to execute, in order"""
    updates: [authors_updates!]!
  ): [authors_mutation_response]

  """
  update data of the table: "blocks"
  """
  update_blocks(
    """sets the columns of the filtered rows to the given values"""
    _set: blocks_set_input

    """filter the rows which have to be updated"""
    where: blocks_bool_exp!
  ): blocks_mutation_response

  """
  update single row of the table: "blocks"
  """
  update_blocks_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: blocks_set_input
    pk_columns: blocks_pk_columns_input!
  ): blocks

  """
  update multiples rows of table: "blocks"
  """
  update_blocks_many(
    """updates to execute, in order"""
    updates: [blocks_updates!]!
  ): [blocks_mutation_response]

  """
  update data of the table: "bookmarks"
  """
  update_bookmarks(
    """sets the columns of the filtered rows to the given values"""
    _set: bookmarks_set_input

    """filter the rows which have to be updated"""
    where: bookmarks_bool_exp!
  ): bookmarks_mutation_response

  """
  update single row of the table: "bookmarks"
  """
  update_bookmarks_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: bookmarks_set_input
    pk_columns: bookmarks_pk_columns_input!
  ): bookmarks

  """
  update multiples rows of table: "bookmarks"
  """
  update_bookmarks_many(
    """updates to execute, in order"""
    updates: [bookmarks_updates!]!
  ): [bookmarks_mutation_response]

  """
  update data of the table: "brands"
  """
  update_brands(
    """sets the columns of the filtered rows to the given values"""
    _set: brands_set_input

    """filter the rows which have to be updated"""
    where: brands_bool_exp!
  ): brands_mutation_response

  """
  update single row of the table: "brands"
  """
  update_brands_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: brands_set_input
    pk_columns: brands_pk_columns_input!
  ): brands

  """
  update multiples rows of table: "brands"
  """
  update_brands_many(
    """updates to execute, in order"""
    updates: [brands_updates!]!
  ): [brands_mutation_response]

  """
  update data of the table: "cart_items"
  """
  update_cart_items(
    """increments the numeric columns with given value of the filtered values"""
    _inc: cart_items_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: cart_items_set_input

    """filter the rows which have to be updated"""
    where: cart_items_bool_exp!
  ): cart_items_mutation_response

  """
  update single row of the table: "cart_items"
  """
  update_cart_items_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: cart_items_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: cart_items_set_input
    pk_columns: cart_items_pk_columns_input!
  ): cart_items

  """
  update multiples rows of table: "cart_items"
  """
  update_cart_items_many(
    """updates to execute, in order"""
    updates: [cart_items_updates!]!
  ): [cart_items_mutation_response]

  """
  update data of the table: "carts"
  """
  update_carts(
    """sets the columns of the filtered rows to the given values"""
    _set: carts_set_input

    """filter the rows which have to be updated"""
    where: carts_bool_exp!
  ): carts_mutation_response

  """
  update single row of the table: "carts"
  """
  update_carts_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: carts_set_input
    pk_columns: carts_pk_columns_input!
  ): carts

  """
  update multiples rows of table: "carts"
  """
  update_carts_many(
    """updates to execute, in order"""
    updates: [carts_updates!]!
  ): [carts_mutation_response]

  """
  update data of the table: "cities"
  """
  update_cities(
    """sets the columns of the filtered rows to the given values"""
    _set: cities_set_input

    """filter the rows which have to be updated"""
    where: cities_bool_exp!
  ): cities_mutation_response

  """
  update single row of the table: "cities"
  """
  update_cities_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: cities_set_input
    pk_columns: cities_pk_columns_input!
  ): cities

  """
  update multiples rows of table: "cities"
  """
  update_cities_many(
    """updates to execute, in order"""
    updates: [cities_updates!]!
  ): [cities_mutation_response]

  """
  update data of the table: "collections"
  """
  update_collections(
    """sets the columns of the filtered rows to the given values"""
    _set: collections_set_input

    """filter the rows which have to be updated"""
    where: collections_bool_exp!
  ): collections_mutation_response

  """
  update single row of the table: "collections"
  """
  update_collections_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: collections_set_input
    pk_columns: collections_pk_columns_input!
  ): collections

  """
  update multiples rows of table: "collections"
  """
  update_collections_many(
    """updates to execute, in order"""
    updates: [collections_updates!]!
  ): [collections_mutation_response]

  """
  update data of the table: "colors"
  """
  update_colors(
    """increments the numeric columns with given value of the filtered values"""
    _inc: colors_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: colors_set_input

    """filter the rows which have to be updated"""
    where: colors_bool_exp!
  ): colors_mutation_response

  """
  update single row of the table: "colors"
  """
  update_colors_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: colors_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: colors_set_input
    pk_columns: colors_pk_columns_input!
  ): colors

  """
  update multiples rows of table: "colors"
  """
  update_colors_many(
    """updates to execute, in order"""
    updates: [colors_updates!]!
  ): [colors_mutation_response]

  """
  update data of the table: "comments"
  """
  update_comments(
    """sets the columns of the filtered rows to the given values"""
    _set: comments_set_input

    """filter the rows which have to be updated"""
    where: comments_bool_exp!
  ): comments_mutation_response

  """
  update single row of the table: "comments"
  """
  update_comments_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: comments_set_input
    pk_columns: comments_pk_columns_input!
  ): comments

  """
  update multiples rows of table: "comments"
  """
  update_comments_many(
    """updates to execute, in order"""
    updates: [comments_updates!]!
  ): [comments_mutation_response]

  """
  update data of the table: "conversation_participants"
  """
  update_conversation_participants(
    """sets the columns of the filtered rows to the given values"""
    _set: conversation_participants_set_input

    """filter the rows which have to be updated"""
    where: conversation_participants_bool_exp!
  ): conversation_participants_mutation_response

  """
  update single row of the table: "conversation_participants"
  """
  update_conversation_participants_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: conversation_participants_set_input
    pk_columns: conversation_participants_pk_columns_input!
  ): conversation_participants

  """
  update multiples rows of table: "conversation_participants"
  """
  update_conversation_participants_many(
    """updates to execute, in order"""
    updates: [conversation_participants_updates!]!
  ): [conversation_participants_mutation_response]

  """
  update data of the table: "conversations"
  """
  update_conversations(
    """sets the columns of the filtered rows to the given values"""
    _set: conversations_set_input

    """filter the rows which have to be updated"""
    where: conversations_bool_exp!
  ): conversations_mutation_response

  """
  update single row of the table: "conversations"
  """
  update_conversations_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: conversations_set_input
    pk_columns: conversations_pk_columns_input!
  ): conversations

  """
  update multiples rows of table: "conversations"
  """
  update_conversations_many(
    """updates to execute, in order"""
    updates: [conversations_updates!]!
  ): [conversations_mutation_response]

  """
  update data of the table: "countries"
  """
  update_countries(
    """sets the columns of the filtered rows to the given values"""
    _set: countries_set_input

    """filter the rows which have to be updated"""
    where: countries_bool_exp!
  ): countries_mutation_response

  """
  update single row of the table: "countries"
  """
  update_countries_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: countries_set_input
    pk_columns: countries_pk_columns_input!
  ): countries

  """
  update multiples rows of table: "countries"
  """
  update_countries_many(
    """updates to execute, in order"""
    updates: [countries_updates!]!
  ): [countries_mutation_response]

  """
  update data of the table: "coupons"
  """
  update_coupons(
    """increments the numeric columns with given value of the filtered values"""
    _inc: coupons_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: coupons_set_input

    """filter the rows which have to be updated"""
    where: coupons_bool_exp!
  ): coupons_mutation_response

  """
  update single row of the table: "coupons"
  """
  update_coupons_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: coupons_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: coupons_set_input
    pk_columns: coupons_pk_columns_input!
  ): coupons

  """
  update multiples rows of table: "coupons"
  """
  update_coupons_many(
    """updates to execute, in order"""
    updates: [coupons_updates!]!
  ): [coupons_mutation_response]

  """
  update data of the table: "currencies"
  """
  update_currencies(
    """increments the numeric columns with given value of the filtered values"""
    _inc: currencies_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: currencies_set_input

    """filter the rows which have to be updated"""
    where: currencies_bool_exp!
  ): currencies_mutation_response

  """
  update single row of the table: "currencies"
  """
  update_currencies_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: currencies_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: currencies_set_input
    pk_columns: currencies_pk_columns_input!
  ): currencies

  """
  update multiples rows of table: "currencies"
  """
  update_currencies_many(
    """updates to execute, in order"""
    updates: [currencies_updates!]!
  ): [currencies_mutation_response]

  """
  update data of the table: "customer_addresses"
  """
  update_customer_addresses(
    """sets the columns of the filtered rows to the given values"""
    _set: customer_addresses_set_input

    """filter the rows which have to be updated"""
    where: customer_addresses_bool_exp!
  ): customer_addresses_mutation_response

  """
  update single row of the table: "customer_addresses"
  """
  update_customer_addresses_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: customer_addresses_set_input
    pk_columns: customer_addresses_pk_columns_input!
  ): customer_addresses

  """
  update multiples rows of table: "customer_addresses"
  """
  update_customer_addresses_many(
    """updates to execute, in order"""
    updates: [customer_addresses_updates!]!
  ): [customer_addresses_mutation_response]

  """
  update data of the table: "customer_stores"
  """
  update_customer_stores(
    """sets the columns of the filtered rows to the given values"""
    _set: customer_stores_set_input

    """filter the rows which have to be updated"""
    where: customer_stores_bool_exp!
  ): customer_stores_mutation_response

  """
  update single row of the table: "customer_stores"
  """
  update_customer_stores_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: customer_stores_set_input
    pk_columns: customer_stores_pk_columns_input!
  ): customer_stores

  """
  update multiples rows of table: "customer_stores"
  """
  update_customer_stores_many(
    """updates to execute, in order"""
    updates: [customer_stores_updates!]!
  ): [customer_stores_mutation_response]

  """
  update data of the table: "customers"
  """
  update_customers(
    """sets the columns of the filtered rows to the given values"""
    _set: customers_set_input

    """filter the rows which have to be updated"""
    where: customers_bool_exp!
  ): customers_mutation_response

  """
  update single row of the table: "customers"
  """
  update_customers_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: customers_set_input
    pk_columns: customers_pk_columns_input!
  ): customers

  """
  update multiples rows of table: "customers"
  """
  update_customers_many(
    """updates to execute, in order"""
    updates: [customers_updates!]!
  ): [customers_mutation_response]

  """
  update data of the table: "districts"
  """
  update_districts(
    """sets the columns of the filtered rows to the given values"""
    _set: districts_set_input

    """filter the rows which have to be updated"""
    where: districts_bool_exp!
  ): districts_mutation_response

  """
  update single row of the table: "districts"
  """
  update_districts_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: districts_set_input
    pk_columns: districts_pk_columns_input!
  ): districts

  """
  update multiples rows of table: "districts"
  """
  update_districts_many(
    """updates to execute, in order"""
    updates: [districts_updates!]!
  ): [districts_mutation_response]

  """
  update data of the table: "ec_categories"
  """
  update_ec_categories(
    """increments the numeric columns with given value of the filtered values"""
    _inc: ec_categories_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: ec_categories_set_input

    """filter the rows which have to be updated"""
    where: ec_categories_bool_exp!
  ): ec_categories_mutation_response

  """
  update single row of the table: "ec_categories"
  """
  update_ec_categories_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: ec_categories_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: ec_categories_set_input
    pk_columns: ec_categories_pk_columns_input!
  ): ec_categories

  """
  update multiples rows of table: "ec_categories"
  """
  update_ec_categories_many(
    """updates to execute, in order"""
    updates: [ec_categories_updates!]!
  ): [ec_categories_mutation_response]

  """
  update data of the table: "follows"
  """
  update_follows(
    """sets the columns of the filtered rows to the given values"""
    _set: follows_set_input

    """filter the rows which have to be updated"""
    where: follows_bool_exp!
  ): follows_mutation_response

  """
  update single row of the table: "follows"
  """
  update_follows_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: follows_set_input
    pk_columns: follows_pk_columns_input!
  ): follows

  """
  update multiples rows of table: "follows"
  """
  update_follows_many(
    """updates to execute, in order"""
    updates: [follows_updates!]!
  ): [follows_mutation_response]

  """
  update data of the table: "form_submissions"
  """
  update_form_submissions(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: form_submissions_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: form_submissions_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: form_submissions_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: form_submissions_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: form_submissions_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: form_submissions_set_input

    """filter the rows which have to be updated"""
    where: form_submissions_bool_exp!
  ): form_submissions_mutation_response

  """
  update single row of the table: "form_submissions"
  """
  update_form_submissions_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: form_submissions_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: form_submissions_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: form_submissions_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: form_submissions_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: form_submissions_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: form_submissions_set_input
    pk_columns: form_submissions_pk_columns_input!
  ): form_submissions

  """
  update multiples rows of table: "form_submissions"
  """
  update_form_submissions_many(
    """updates to execute, in order"""
    updates: [form_submissions_updates!]!
  ): [form_submissions_mutation_response]

  """
  update data of the table: "forms"
  """
  update_forms(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: forms_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: forms_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: forms_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: forms_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: forms_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: forms_set_input

    """filter the rows which have to be updated"""
    where: forms_bool_exp!
  ): forms_mutation_response

  """
  update single row of the table: "forms"
  """
  update_forms_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: forms_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: forms_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: forms_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: forms_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: forms_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: forms_set_input
    pk_columns: forms_pk_columns_input!
  ): forms

  """
  update multiples rows of table: "forms"
  """
  update_forms_many(
    """updates to execute, in order"""
    updates: [forms_updates!]!
  ): [forms_mutation_response]

  """
  update data of the table: "hashtags"
  """
  update_hashtags(
    """increments the numeric columns with given value of the filtered values"""
    _inc: hashtags_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: hashtags_set_input

    """filter the rows which have to be updated"""
    where: hashtags_bool_exp!
  ): hashtags_mutation_response

  """
  update single row of the table: "hashtags"
  """
  update_hashtags_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: hashtags_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: hashtags_set_input
    pk_columns: hashtags_pk_columns_input!
  ): hashtags

  """
  update multiples rows of table: "hashtags"
  """
  update_hashtags_many(
    """updates to execute, in order"""
    updates: [hashtags_updates!]!
  ): [hashtags_mutation_response]

  """
  update data of the table: "inventory_levels"
  """
  update_inventory_levels(
    """increments the numeric columns with given value of the filtered values"""
    _inc: inventory_levels_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: inventory_levels_set_input

    """filter the rows which have to be updated"""
    where: inventory_levels_bool_exp!
  ): inventory_levels_mutation_response

  """
  update single row of the table: "inventory_levels"
  """
  update_inventory_levels_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: inventory_levels_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: inventory_levels_set_input
    pk_columns: inventory_levels_pk_columns_input!
  ): inventory_levels

  """
  update multiples rows of table: "inventory_levels"
  """
  update_inventory_levels_many(
    """updates to execute, in order"""
    updates: [inventory_levels_updates!]!
  ): [inventory_levels_mutation_response]

  """
  update data of the table: "inventory_locations"
  """
  update_inventory_locations(
    """sets the columns of the filtered rows to the given values"""
    _set: inventory_locations_set_input

    """filter the rows which have to be updated"""
    where: inventory_locations_bool_exp!
  ): inventory_locations_mutation_response

  """
  update single row of the table: "inventory_locations"
  """
  update_inventory_locations_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: inventory_locations_set_input
    pk_columns: inventory_locations_pk_columns_input!
  ): inventory_locations

  """
  update multiples rows of table: "inventory_locations"
  """
  update_inventory_locations_many(
    """updates to execute, in order"""
    updates: [inventory_locations_updates!]!
  ): [inventory_locations_mutation_response]

  """
  update data of the table: "likes"
  """
  update_likes(
    """sets the columns of the filtered rows to the given values"""
    _set: likes_set_input

    """filter the rows which have to be updated"""
    where: likes_bool_exp!
  ): likes_mutation_response

  """
  update single row of the table: "likes"
  """
  update_likes_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: likes_set_input
    pk_columns: likes_pk_columns_input!
  ): likes

  """
  update multiples rows of table: "likes"
  """
  update_likes_many(
    """updates to execute, in order"""
    updates: [likes_updates!]!
  ): [likes_mutation_response]

  """
  update data of the table: "media_files"
  """
  update_media_files(
    """increments the numeric columns with given value of the filtered values"""
    _inc: media_files_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: media_files_set_input

    """filter the rows which have to be updated"""
    where: media_files_bool_exp!
  ): media_files_mutation_response

  """
  update single row of the table: "media_files"
  """
  update_media_files_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: media_files_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: media_files_set_input
    pk_columns: media_files_pk_columns_input!
  ): media_files

  """
  update multiples rows of table: "media_files"
  """
  update_media_files_many(
    """updates to execute, in order"""
    updates: [media_files_updates!]!
  ): [media_files_mutation_response]

  """
  update data of the table: "media_folders"
  """
  update_media_folders(
    """sets the columns of the filtered rows to the given values"""
    _set: media_folders_set_input

    """filter the rows which have to be updated"""
    where: media_folders_bool_exp!
  ): media_folders_mutation_response

  """
  update single row of the table: "media_folders"
  """
  update_media_folders_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: media_folders_set_input
    pk_columns: media_folders_pk_columns_input!
  ): media_folders

  """
  update multiples rows of table: "media_folders"
  """
  update_media_folders_many(
    """updates to execute, in order"""
    updates: [media_folders_updates!]!
  ): [media_folders_mutation_response]

  """
  update data of the table: "mentions"
  """
  update_mentions(
    """sets the columns of the filtered rows to the given values"""
    _set: mentions_set_input

    """filter the rows which have to be updated"""
    where: mentions_bool_exp!
  ): mentions_mutation_response

  """
  update single row of the table: "mentions"
  """
  update_mentions_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: mentions_set_input
    pk_columns: mentions_pk_columns_input!
  ): mentions

  """
  update multiples rows of table: "mentions"
  """
  update_mentions_many(
    """updates to execute, in order"""
    updates: [mentions_updates!]!
  ): [mentions_mutation_response]

  """
  update data of the table: "menu_items"
  """
  update_menu_items(
    """increments the numeric columns with given value of the filtered values"""
    _inc: menu_items_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: menu_items_set_input

    """filter the rows which have to be updated"""
    where: menu_items_bool_exp!
  ): menu_items_mutation_response

  """
  update single row of the table: "menu_items"
  """
  update_menu_items_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: menu_items_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: menu_items_set_input
    pk_columns: menu_items_pk_columns_input!
  ): menu_items

  """
  update multiples rows of table: "menu_items"
  """
  update_menu_items_many(
    """updates to execute, in order"""
    updates: [menu_items_updates!]!
  ): [menu_items_mutation_response]

  """
  update data of the table: "menus"
  """
  update_menus(
    """sets the columns of the filtered rows to the given values"""
    _set: menus_set_input

    """filter the rows which have to be updated"""
    where: menus_bool_exp!
  ): menus_mutation_response

  """
  update single row of the table: "menus"
  """
  update_menus_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: menus_set_input
    pk_columns: menus_pk_columns_input!
  ): menus

  """
  update multiples rows of table: "menus"
  """
  update_menus_many(
    """updates to execute, in order"""
    updates: [menus_updates!]!
  ): [menus_mutation_response]

  """
  update data of the table: "message_reactions"
  """
  update_message_reactions(
    """sets the columns of the filtered rows to the given values"""
    _set: message_reactions_set_input

    """filter the rows which have to be updated"""
    where: message_reactions_bool_exp!
  ): message_reactions_mutation_response

  """
  update single row of the table: "message_reactions"
  """
  update_message_reactions_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: message_reactions_set_input
    pk_columns: message_reactions_pk_columns_input!
  ): message_reactions

  """
  update multiples rows of table: "message_reactions"
  """
  update_message_reactions_many(
    """updates to execute, in order"""
    updates: [message_reactions_updates!]!
  ): [message_reactions_mutation_response]

  """
  update data of the table: "messages"
  """
  update_messages(
    """sets the columns of the filtered rows to the given values"""
    _set: messages_set_input

    """filter the rows which have to be updated"""
    where: messages_bool_exp!
  ): messages_mutation_response

  """
  update single row of the table: "messages"
  """
  update_messages_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: messages_set_input
    pk_columns: messages_pk_columns_input!
  ): messages

  """
  update multiples rows of table: "messages"
  """
  update_messages_many(
    """updates to execute, in order"""
    updates: [messages_updates!]!
  ): [messages_mutation_response]

  """
  update data of the table: "neighborhoods"
  """
  update_neighborhoods(
    """increments the numeric columns with given value of the filtered values"""
    _inc: neighborhoods_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: neighborhoods_set_input

    """filter the rows which have to be updated"""
    where: neighborhoods_bool_exp!
  ): neighborhoods_mutation_response

  """
  update single row of the table: "neighborhoods"
  """
  update_neighborhoods_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: neighborhoods_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: neighborhoods_set_input
    pk_columns: neighborhoods_pk_columns_input!
  ): neighborhoods

  """
  update multiples rows of table: "neighborhoods"
  """
  update_neighborhoods_many(
    """updates to execute, in order"""
    updates: [neighborhoods_updates!]!
  ): [neighborhoods_mutation_response]

  """
  update data of the table: "notifications"
  """
  update_notifications(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: notifications_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: notifications_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: notifications_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: notifications_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: notifications_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: notifications_set_input

    """filter the rows which have to be updated"""
    where: notifications_bool_exp!
  ): notifications_mutation_response

  """
  update single row of the table: "notifications"
  """
  update_notifications_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: notifications_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: notifications_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: notifications_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: notifications_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: notifications_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: notifications_set_input
    pk_columns: notifications_pk_columns_input!
  ): notifications

  """
  update multiples rows of table: "notifications"
  """
  update_notifications_many(
    """updates to execute, in order"""
    updates: [notifications_updates!]!
  ): [notifications_mutation_response]

  """
  update data of the table: "order_coupons"
  """
  update_order_coupons(
    """increments the numeric columns with given value of the filtered values"""
    _inc: order_coupons_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: order_coupons_set_input

    """filter the rows which have to be updated"""
    where: order_coupons_bool_exp!
  ): order_coupons_mutation_response

  """
  update single row of the table: "order_coupons"
  """
  update_order_coupons_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: order_coupons_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: order_coupons_set_input
    pk_columns: order_coupons_pk_columns_input!
  ): order_coupons

  """
  update multiples rows of table: "order_coupons"
  """
  update_order_coupons_many(
    """updates to execute, in order"""
    updates: [order_coupons_updates!]!
  ): [order_coupons_mutation_response]

  """
  update data of the table: "order_items"
  """
  update_order_items(
    """increments the numeric columns with given value of the filtered values"""
    _inc: order_items_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: order_items_set_input

    """filter the rows which have to be updated"""
    where: order_items_bool_exp!
  ): order_items_mutation_response

  """
  update single row of the table: "order_items"
  """
  update_order_items_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: order_items_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: order_items_set_input
    pk_columns: order_items_pk_columns_input!
  ): order_items

  """
  update multiples rows of table: "order_items"
  """
  update_order_items_many(
    """updates to execute, in order"""
    updates: [order_items_updates!]!
  ): [order_items_mutation_response]

  """
  update data of the table: "order_statuses"
  """
  update_order_statuses(
    """increments the numeric columns with given value of the filtered values"""
    _inc: order_statuses_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: order_statuses_set_input

    """filter the rows which have to be updated"""
    where: order_statuses_bool_exp!
  ): order_statuses_mutation_response

  """
  update single row of the table: "order_statuses"
  """
  update_order_statuses_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: order_statuses_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: order_statuses_set_input
    pk_columns: order_statuses_pk_columns_input!
  ): order_statuses

  """
  update multiples rows of table: "order_statuses"
  """
  update_order_statuses_many(
    """updates to execute, in order"""
    updates: [order_statuses_updates!]!
  ): [order_statuses_mutation_response]

  """
  update data of the table: "orders"
  """
  update_orders(
    """increments the numeric columns with given value of the filtered values"""
    _inc: orders_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: orders_set_input

    """filter the rows which have to be updated"""
    where: orders_bool_exp!
  ): orders_mutation_response

  """
  update single row of the table: "orders"
  """
  update_orders_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: orders_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: orders_set_input
    pk_columns: orders_pk_columns_input!
  ): orders

  """
  update multiples rows of table: "orders"
  """
  update_orders_many(
    """updates to execute, in order"""
    updates: [orders_updates!]!
  ): [orders_mutation_response]

  """
  update data of the table: "page_templates"
  """
  update_page_templates(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: page_templates_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: page_templates_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: page_templates_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: page_templates_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: page_templates_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: page_templates_set_input

    """filter the rows which have to be updated"""
    where: page_templates_bool_exp!
  ): page_templates_mutation_response

  """
  update single row of the table: "page_templates"
  """
  update_page_templates_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: page_templates_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: page_templates_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: page_templates_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: page_templates_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: page_templates_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: page_templates_set_input
    pk_columns: page_templates_pk_columns_input!
  ): page_templates

  """
  update multiples rows of table: "page_templates"
  """
  update_page_templates_many(
    """updates to execute, in order"""
    updates: [page_templates_updates!]!
  ): [page_templates_mutation_response]

  """
  update data of the table: "page_versions"
  """
  update_page_versions(
    """increments the numeric columns with given value of the filtered values"""
    _inc: page_versions_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: page_versions_set_input

    """filter the rows which have to be updated"""
    where: page_versions_bool_exp!
  ): page_versions_mutation_response

  """
  update single row of the table: "page_versions"
  """
  update_page_versions_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: page_versions_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: page_versions_set_input
    pk_columns: page_versions_pk_columns_input!
  ): page_versions

  """
  update multiples rows of table: "page_versions"
  """
  update_page_versions_many(
    """updates to execute, in order"""
    updates: [page_versions_updates!]!
  ): [page_versions_mutation_response]

  """
  update data of the table: "pages"
  """
  update_pages(
    """increments the numeric columns with given value of the filtered values"""
    _inc: pages_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: pages_set_input

    """filter the rows which have to be updated"""
    where: pages_bool_exp!
  ): pages_mutation_response

  """
  update single row of the table: "pages"
  """
  update_pages_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: pages_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: pages_set_input
    pk_columns: pages_pk_columns_input!
  ): pages

  """
  update multiples rows of table: "pages"
  """
  update_pages_many(
    """updates to execute, in order"""
    updates: [pages_updates!]!
  ): [pages_mutation_response]

  """
  update data of the table: "payment_methods"
  """
  update_payment_methods(
    """sets the columns of the filtered rows to the given values"""
    _set: payment_methods_set_input

    """filter the rows which have to be updated"""
    where: payment_methods_bool_exp!
  ): payment_methods_mutation_response

  """
  update single row of the table: "payment_methods"
  """
  update_payment_methods_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: payment_methods_set_input
    pk_columns: payment_methods_pk_columns_input!
  ): payment_methods

  """
  update multiples rows of table: "payment_methods"
  """
  update_payment_methods_many(
    """updates to execute, in order"""
    updates: [payment_methods_updates!]!
  ): [payment_methods_mutation_response]

  """
  update data of the table: "payment_statuses"
  """
  update_payment_statuses(
    """increments the numeric columns with given value of the filtered values"""
    _inc: payment_statuses_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: payment_statuses_set_input

    """filter the rows which have to be updated"""
    where: payment_statuses_bool_exp!
  ): payment_statuses_mutation_response

  """
  update single row of the table: "payment_statuses"
  """
  update_payment_statuses_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: payment_statuses_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: payment_statuses_set_input
    pk_columns: payment_statuses_pk_columns_input!
  ): payment_statuses

  """
  update multiples rows of table: "payment_statuses"
  """
  update_payment_statuses_many(
    """updates to execute, in order"""
    updates: [payment_statuses_updates!]!
  ): [payment_statuses_mutation_response]

  """
  update data of the table: "payments"
  """
  update_payments(
    """increments the numeric columns with given value of the filtered values"""
    _inc: payments_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: payments_set_input

    """filter the rows which have to be updated"""
    where: payments_bool_exp!
  ): payments_mutation_response

  """
  update single row of the table: "payments"
  """
  update_payments_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: payments_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: payments_set_input
    pk_columns: payments_pk_columns_input!
  ): payments

  """
  update multiples rows of table: "payments"
  """
  update_payments_many(
    """updates to execute, in order"""
    updates: [payments_updates!]!
  ): [payments_mutation_response]

  """
  update data of the table: "permissions"
  """
  update_permissions(
    """sets the columns of the filtered rows to the given values"""
    _set: permissions_set_input

    """filter the rows which have to be updated"""
    where: permissions_bool_exp!
  ): permissions_mutation_response

  """
  update single row of the table: "permissions"
  """
  update_permissions_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: permissions_set_input
    pk_columns: permissions_pk_columns_input!
  ): permissions

  """
  update multiples rows of table: "permissions"
  """
  update_permissions_many(
    """updates to execute, in order"""
    updates: [permissions_updates!]!
  ): [permissions_mutation_response]

  """
  update data of the table: "post_hashtags"
  """
  update_post_hashtags(
    """sets the columns of the filtered rows to the given values"""
    _set: post_hashtags_set_input

    """filter the rows which have to be updated"""
    where: post_hashtags_bool_exp!
  ): post_hashtags_mutation_response

  """
  update single row of the table: "post_hashtags"
  """
  update_post_hashtags_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: post_hashtags_set_input
    pk_columns: post_hashtags_pk_columns_input!
  ): post_hashtags

  """
  update multiples rows of table: "post_hashtags"
  """
  update_post_hashtags_many(
    """updates to execute, in order"""
    updates: [post_hashtags_updates!]!
  ): [post_hashtags_mutation_response]

  """
  update data of the table: "post_media"
  """
  update_post_media(
    """increments the numeric columns with given value of the filtered values"""
    _inc: post_media_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: post_media_set_input

    """filter the rows which have to be updated"""
    where: post_media_bool_exp!
  ): post_media_mutation_response

  """
  update single row of the table: "post_media"
  """
  update_post_media_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: post_media_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: post_media_set_input
    pk_columns: post_media_pk_columns_input!
  ): post_media

  """
  update multiples rows of table: "post_media"
  """
  update_post_media_many(
    """updates to execute, in order"""
    updates: [post_media_updates!]!
  ): [post_media_mutation_response]

  """
  update data of the table: "posts"
  """
  update_posts(
    """increments the numeric columns with given value of the filtered values"""
    _inc: posts_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: posts_set_input

    """filter the rows which have to be updated"""
    where: posts_bool_exp!
  ): posts_mutation_response

  """
  update single row of the table: "posts"
  """
  update_posts_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: posts_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: posts_set_input
    pk_columns: posts_pk_columns_input!
  ): posts

  """
  update multiples rows of table: "posts"
  """
  update_posts_many(
    """updates to execute, in order"""
    updates: [posts_updates!]!
  ): [posts_mutation_response]

  """
  update data of the table: "product_categories"
  """
  update_product_categories(
    """sets the columns of the filtered rows to the given values"""
    _set: product_categories_set_input

    """filter the rows which have to be updated"""
    where: product_categories_bool_exp!
  ): product_categories_mutation_response

  """
  update single row of the table: "product_categories"
  """
  update_product_categories_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: product_categories_set_input
    pk_columns: product_categories_pk_columns_input!
  ): product_categories

  """
  update multiples rows of table: "product_categories"
  """
  update_product_categories_many(
    """updates to execute, in order"""
    updates: [product_categories_updates!]!
  ): [product_categories_mutation_response]

  """
  update data of the table: "product_collections"
  """
  update_product_collections(
    """increments the numeric columns with given value of the filtered values"""
    _inc: product_collections_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: product_collections_set_input

    """filter the rows which have to be updated"""
    where: product_collections_bool_exp!
  ): product_collections_mutation_response

  """
  update single row of the table: "product_collections"
  """
  update_product_collections_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: product_collections_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: product_collections_set_input
    pk_columns: product_collections_pk_columns_input!
  ): product_collections

  """
  update multiples rows of table: "product_collections"
  """
  update_product_collections_many(
    """updates to execute, in order"""
    updates: [product_collections_updates!]!
  ): [product_collections_mutation_response]

  """
  update data of the table: "product_images"
  """
  update_product_images(
    """increments the numeric columns with given value of the filtered values"""
    _inc: product_images_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: product_images_set_input

    """filter the rows which have to be updated"""
    where: product_images_bool_exp!
  ): product_images_mutation_response

  """
  update single row of the table: "product_images"
  """
  update_product_images_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: product_images_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: product_images_set_input
    pk_columns: product_images_pk_columns_input!
  ): product_images

  """
  update multiples rows of table: "product_images"
  """
  update_product_images_many(
    """updates to execute, in order"""
    updates: [product_images_updates!]!
  ): [product_images_mutation_response]

  """
  update data of the table: "product_variants"
  """
  update_product_variants(
    """increments the numeric columns with given value of the filtered values"""
    _inc: product_variants_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: product_variants_set_input

    """filter the rows which have to be updated"""
    where: product_variants_bool_exp!
  ): product_variants_mutation_response

  """
  update single row of the table: "product_variants"
  """
  update_product_variants_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: product_variants_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: product_variants_set_input
    pk_columns: product_variants_pk_columns_input!
  ): product_variants

  """
  update multiples rows of table: "product_variants"
  """
  update_product_variants_many(
    """updates to execute, in order"""
    updates: [product_variants_updates!]!
  ): [product_variants_mutation_response]

  """
  update data of the table: "products"
  """
  update_products(
    """increments the numeric columns with given value of the filtered values"""
    _inc: products_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: products_set_input

    """filter the rows which have to be updated"""
    where: products_bool_exp!
  ): products_mutation_response

  """
  update single row of the table: "products"
  """
  update_products_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: products_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: products_set_input
    pk_columns: products_pk_columns_input!
  ): products

  """
  update multiples rows of table: "products"
  """
  update_products_many(
    """updates to execute, in order"""
    updates: [products_updates!]!
  ): [products_mutation_response]

  """
  update data of the table: "redirects"
  """
  update_redirects(
    """increments the numeric columns with given value of the filtered values"""
    _inc: redirects_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: redirects_set_input

    """filter the rows which have to be updated"""
    where: redirects_bool_exp!
  ): redirects_mutation_response

  """
  update single row of the table: "redirects"
  """
  update_redirects_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: redirects_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: redirects_set_input
    pk_columns: redirects_pk_columns_input!
  ): redirects

  """
  update multiples rows of table: "redirects"
  """
  update_redirects_many(
    """updates to execute, in order"""
    updates: [redirects_updates!]!
  ): [redirects_mutation_response]

  """
  update data of the table: "regions"
  """
  update_regions(
    """sets the columns of the filtered rows to the given values"""
    _set: regions_set_input

    """filter the rows which have to be updated"""
    where: regions_bool_exp!
  ): regions_mutation_response

  """
  update single row of the table: "regions"
  """
  update_regions_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: regions_set_input
    pk_columns: regions_pk_columns_input!
  ): regions

  """
  update multiples rows of table: "regions"
  """
  update_regions_many(
    """updates to execute, in order"""
    updates: [regions_updates!]!
  ): [regions_mutation_response]

  """
  update data of the table: "related_products"
  """
  update_related_products(
    """increments the numeric columns with given value of the filtered values"""
    _inc: related_products_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: related_products_set_input

    """filter the rows which have to be updated"""
    where: related_products_bool_exp!
  ): related_products_mutation_response

  """
  update single row of the table: "related_products"
  """
  update_related_products_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: related_products_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: related_products_set_input
    pk_columns: related_products_pk_columns_input!
  ): related_products

  """
  update multiples rows of table: "related_products"
  """
  update_related_products_many(
    """updates to execute, in order"""
    updates: [related_products_updates!]!
  ): [related_products_mutation_response]

  """
  update data of the table: "report_statuses"
  """
  update_report_statuses(
    """increments the numeric columns with given value of the filtered values"""
    _inc: report_statuses_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: report_statuses_set_input

    """filter the rows which have to be updated"""
    where: report_statuses_bool_exp!
  ): report_statuses_mutation_response

  """
  update single row of the table: "report_statuses"
  """
  update_report_statuses_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: report_statuses_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: report_statuses_set_input
    pk_columns: report_statuses_pk_columns_input!
  ): report_statuses

  """
  update multiples rows of table: "report_statuses"
  """
  update_report_statuses_many(
    """updates to execute, in order"""
    updates: [report_statuses_updates!]!
  ): [report_statuses_mutation_response]

  """
  update data of the table: "reports"
  """
  update_reports(
    """sets the columns of the filtered rows to the given values"""
    _set: reports_set_input

    """filter the rows which have to be updated"""
    where: reports_bool_exp!
  ): reports_mutation_response

  """
  update single row of the table: "reports"
  """
  update_reports_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: reports_set_input
    pk_columns: reports_pk_columns_input!
  ): reports

  """
  update multiples rows of table: "reports"
  """
  update_reports_many(
    """updates to execute, in order"""
    updates: [reports_updates!]!
  ): [reports_mutation_response]

  """
  update data of the table: "return_requests"
  """
  update_return_requests(
    """sets the columns of the filtered rows to the given values"""
    _set: return_requests_set_input

    """filter the rows which have to be updated"""
    where: return_requests_bool_exp!
  ): return_requests_mutation_response

  """
  update single row of the table: "return_requests"
  """
  update_return_requests_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: return_requests_set_input
    pk_columns: return_requests_pk_columns_input!
  ): return_requests

  """
  update multiples rows of table: "return_requests"
  """
  update_return_requests_many(
    """updates to execute, in order"""
    updates: [return_requests_updates!]!
  ): [return_requests_mutation_response]

  """
  update data of the table: "return_statuses"
  """
  update_return_statuses(
    """increments the numeric columns with given value of the filtered values"""
    _inc: return_statuses_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: return_statuses_set_input

    """filter the rows which have to be updated"""
    where: return_statuses_bool_exp!
  ): return_statuses_mutation_response

  """
  update single row of the table: "return_statuses"
  """
  update_return_statuses_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: return_statuses_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: return_statuses_set_input
    pk_columns: return_statuses_pk_columns_input!
  ): return_statuses

  """
  update multiples rows of table: "return_statuses"
  """
  update_return_statuses_many(
    """updates to execute, in order"""
    updates: [return_statuses_updates!]!
  ): [return_statuses_mutation_response]

  """
  update data of the table: "reviews"
  """
  update_reviews(
    """increments the numeric columns with given value of the filtered values"""
    _inc: reviews_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: reviews_set_input

    """filter the rows which have to be updated"""
    where: reviews_bool_exp!
  ): reviews_mutation_response

  """
  update single row of the table: "reviews"
  """
  update_reviews_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: reviews_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: reviews_set_input
    pk_columns: reviews_pk_columns_input!
  ): reviews

  """
  update multiples rows of table: "reviews"
  """
  update_reviews_many(
    """updates to execute, in order"""
    updates: [reviews_updates!]!
  ): [reviews_mutation_response]

  """
  update data of the table: "role_permissions"
  """
  update_role_permissions(
    """sets the columns of the filtered rows to the given values"""
    _set: role_permissions_set_input

    """filter the rows which have to be updated"""
    where: role_permissions_bool_exp!
  ): role_permissions_mutation_response

  """
  update single row of the table: "role_permissions"
  """
  update_role_permissions_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: role_permissions_set_input
    pk_columns: role_permissions_pk_columns_input!
  ): role_permissions

  """
  update multiples rows of table: "role_permissions"
  """
  update_role_permissions_many(
    """updates to execute, in order"""
    updates: [role_permissions_updates!]!
  ): [role_permissions_mutation_response]

  """
  update data of the table: "roles"
  """
  update_roles(
    """sets the columns of the filtered rows to the given values"""
    _set: roles_set_input

    """filter the rows which have to be updated"""
    where: roles_bool_exp!
  ): roles_mutation_response

  """
  update single row of the table: "roles"
  """
  update_roles_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: roles_set_input
    pk_columns: roles_pk_columns_input!
  ): roles

  """
  update multiples rows of table: "roles"
  """
  update_roles_many(
    """updates to execute, in order"""
    updates: [roles_updates!]!
  ): [roles_mutation_response]

  """
  update data of the table: "seo_settings"
  """
  update_seo_settings(
    """sets the columns of the filtered rows to the given values"""
    _set: seo_settings_set_input

    """filter the rows which have to be updated"""
    where: seo_settings_bool_exp!
  ): seo_settings_mutation_response

  """
  update single row of the table: "seo_settings"
  """
  update_seo_settings_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: seo_settings_set_input
    pk_columns: seo_settings_pk_columns_input!
  ): seo_settings

  """
  update multiples rows of table: "seo_settings"
  """
  update_seo_settings_many(
    """updates to execute, in order"""
    updates: [seo_settings_updates!]!
  ): [seo_settings_mutation_response]

  """
  update data of the table: "shipment_statuses"
  """
  update_shipment_statuses(
    """increments the numeric columns with given value of the filtered values"""
    _inc: shipment_statuses_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: shipment_statuses_set_input

    """filter the rows which have to be updated"""
    where: shipment_statuses_bool_exp!
  ): shipment_statuses_mutation_response

  """
  update single row of the table: "shipment_statuses"
  """
  update_shipment_statuses_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: shipment_statuses_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: shipment_statuses_set_input
    pk_columns: shipment_statuses_pk_columns_input!
  ): shipment_statuses

  """
  update multiples rows of table: "shipment_statuses"
  """
  update_shipment_statuses_many(
    """updates to execute, in order"""
    updates: [shipment_statuses_updates!]!
  ): [shipment_statuses_mutation_response]

  """
  update data of the table: "shipments"
  """
  update_shipments(
    """sets the columns of the filtered rows to the given values"""
    _set: shipments_set_input

    """filter the rows which have to be updated"""
    where: shipments_bool_exp!
  ): shipments_mutation_response

  """
  update single row of the table: "shipments"
  """
  update_shipments_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: shipments_set_input
    pk_columns: shipments_pk_columns_input!
  ): shipments

  """
  update multiples rows of table: "shipments"
  """
  update_shipments_many(
    """updates to execute, in order"""
    updates: [shipments_updates!]!
  ): [shipments_mutation_response]

  """
  update data of the table: "shipping_carriers"
  """
  update_shipping_carriers(
    """sets the columns of the filtered rows to the given values"""
    _set: shipping_carriers_set_input

    """filter the rows which have to be updated"""
    where: shipping_carriers_bool_exp!
  ): shipping_carriers_mutation_response

  """
  update single row of the table: "shipping_carriers"
  """
  update_shipping_carriers_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: shipping_carriers_set_input
    pk_columns: shipping_carriers_pk_columns_input!
  ): shipping_carriers

  """
  update multiples rows of table: "shipping_carriers"
  """
  update_shipping_carriers_many(
    """updates to execute, in order"""
    updates: [shipping_carriers_updates!]!
  ): [shipping_carriers_mutation_response]

  """
  update data of the table: "site_authors"
  """
  update_site_authors(
    """sets the columns of the filtered rows to the given values"""
    _set: site_authors_set_input

    """filter the rows which have to be updated"""
    where: site_authors_bool_exp!
  ): site_authors_mutation_response

  """
  update single row of the table: "site_authors"
  """
  update_site_authors_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: site_authors_set_input
    pk_columns: site_authors_pk_columns_input!
  ): site_authors

  """
  update multiples rows of table: "site_authors"
  """
  update_site_authors_many(
    """updates to execute, in order"""
    updates: [site_authors_updates!]!
  ): [site_authors_mutation_response]

  """
  update data of the table: "sites"
  """
  update_sites(
    """sets the columns of the filtered rows to the given values"""
    _set: sites_set_input

    """filter the rows which have to be updated"""
    where: sites_bool_exp!
  ): sites_mutation_response

  """
  update single row of the table: "sites"
  """
  update_sites_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: sites_set_input
    pk_columns: sites_pk_columns_input!
  ): sites

  """
  update multiples rows of table: "sites"
  """
  update_sites_many(
    """updates to execute, in order"""
    updates: [sites_updates!]!
  ): [sites_mutation_response]

  """
  update data of the table: "sizes"
  """
  update_sizes(
    """increments the numeric columns with given value of the filtered values"""
    _inc: sizes_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: sizes_set_input

    """filter the rows which have to be updated"""
    where: sizes_bool_exp!
  ): sizes_mutation_response

  """
  update single row of the table: "sizes"
  """
  update_sizes_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: sizes_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: sizes_set_input
    pk_columns: sizes_pk_columns_input!
  ): sizes

  """
  update multiples rows of table: "sizes"
  """
  update_sizes_many(
    """updates to execute, in order"""
    updates: [sizes_updates!]!
  ): [sizes_mutation_response]

  """
  update data of the table: "store_currencies"
  """
  update_store_currencies(
    """increments the numeric columns with given value of the filtered values"""
    _inc: store_currencies_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: store_currencies_set_input

    """filter the rows which have to be updated"""
    where: store_currencies_bool_exp!
  ): store_currencies_mutation_response

  """
  update single row of the table: "store_currencies"
  """
  update_store_currencies_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: store_currencies_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: store_currencies_set_input
    pk_columns: store_currencies_pk_columns_input!
  ): store_currencies

  """
  update multiples rows of table: "store_currencies"
  """
  update_store_currencies_many(
    """updates to execute, in order"""
    updates: [store_currencies_updates!]!
  ): [store_currencies_mutation_response]

  """
  update data of the table: "store_payment_methods"
  """
  update_store_payment_methods(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: store_payment_methods_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: store_payment_methods_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: store_payment_methods_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: store_payment_methods_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: store_payment_methods_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: store_payment_methods_set_input

    """filter the rows which have to be updated"""
    where: store_payment_methods_bool_exp!
  ): store_payment_methods_mutation_response

  """
  update single row of the table: "store_payment_methods"
  """
  update_store_payment_methods_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: store_payment_methods_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: store_payment_methods_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: store_payment_methods_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: store_payment_methods_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: store_payment_methods_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: store_payment_methods_set_input
    pk_columns: store_payment_methods_pk_columns_input!
  ): store_payment_methods

  """
  update multiples rows of table: "store_payment_methods"
  """
  update_store_payment_methods_many(
    """updates to execute, in order"""
    updates: [store_payment_methods_updates!]!
  ): [store_payment_methods_mutation_response]

  """
  update data of the table: "store_shipping_carriers"
  """
  update_store_shipping_carriers(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: store_shipping_carriers_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: store_shipping_carriers_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: store_shipping_carriers_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: store_shipping_carriers_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: store_shipping_carriers_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: store_shipping_carriers_set_input

    """filter the rows which have to be updated"""
    where: store_shipping_carriers_bool_exp!
  ): store_shipping_carriers_mutation_response

  """
  update single row of the table: "store_shipping_carriers"
  """
  update_store_shipping_carriers_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: store_shipping_carriers_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: store_shipping_carriers_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: store_shipping_carriers_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: store_shipping_carriers_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: store_shipping_carriers_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: store_shipping_carriers_set_input
    pk_columns: store_shipping_carriers_pk_columns_input!
  ): store_shipping_carriers

  """
  update multiples rows of table: "store_shipping_carriers"
  """
  update_store_shipping_carriers_many(
    """updates to execute, in order"""
    updates: [store_shipping_carriers_updates!]!
  ): [store_shipping_carriers_mutation_response]

  """
  update data of the table: "stores"
  """
  update_stores(
    """sets the columns of the filtered rows to the given values"""
    _set: stores_set_input

    """filter the rows which have to be updated"""
    where: stores_bool_exp!
  ): stores_mutation_response

  """
  update single row of the table: "stores"
  """
  update_stores_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: stores_set_input
    pk_columns: stores_pk_columns_input!
  ): stores

  """
  update multiples rows of table: "stores"
  """
  update_stores_many(
    """updates to execute, in order"""
    updates: [stores_updates!]!
  ): [stores_mutation_response]

  """
  update data of the table: "streets"
  """
  update_streets(
    """sets the columns of the filtered rows to the given values"""
    _set: streets_set_input

    """filter the rows which have to be updated"""
    where: streets_bool_exp!
  ): streets_mutation_response

  """
  update single row of the table: "streets"
  """
  update_streets_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: streets_set_input
    pk_columns: streets_pk_columns_input!
  ): streets

  """
  update multiples rows of table: "streets"
  """
  update_streets_many(
    """updates to execute, in order"""
    updates: [streets_updates!]!
  ): [streets_mutation_response]

  """
  update data of the table: "tags"
  """
  update_tags(
    """sets the columns of the filtered rows to the given values"""
    _set: tags_set_input

    """filter the rows which have to be updated"""
    where: tags_bool_exp!
  ): tags_mutation_response

  """
  update single row of the table: "tags"
  """
  update_tags_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: tags_set_input
    pk_columns: tags_pk_columns_input!
  ): tags

  """
  update multiples rows of table: "tags"
  """
  update_tags_many(
    """updates to execute, in order"""
    updates: [tags_updates!]!
  ): [tags_mutation_response]

  """
  update data of the table: "user_profiles"
  """
  update_user_profiles(
    """sets the columns of the filtered rows to the given values"""
    _set: user_profiles_set_input

    """filter the rows which have to be updated"""
    where: user_profiles_bool_exp!
  ): user_profiles_mutation_response

  """
  update single row of the table: "user_profiles"
  """
  update_user_profiles_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: user_profiles_set_input
    pk_columns: user_profiles_pk_columns_input!
  ): user_profiles

  """
  update multiples rows of table: "user_profiles"
  """
  update_user_profiles_many(
    """updates to execute, in order"""
    updates: [user_profiles_updates!]!
  ): [user_profiles_mutation_response]

  """
  update data of the table: "user_roles"
  """
  update_user_roles(
    """sets the columns of the filtered rows to the given values"""
    _set: user_roles_set_input

    """filter the rows which have to be updated"""
    where: user_roles_bool_exp!
  ): user_roles_mutation_response

  """
  update single row of the table: "user_roles"
  """
  update_user_roles_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: user_roles_set_input
    pk_columns: user_roles_pk_columns_input!
  ): user_roles

  """
  update multiples rows of table: "user_roles"
  """
  update_user_roles_many(
    """updates to execute, in order"""
    updates: [user_roles_updates!]!
  ): [user_roles_mutation_response]

  """
  update data of the table: "user_sessions"
  """
  update_user_sessions(
    """sets the columns of the filtered rows to the given values"""
    _set: user_sessions_set_input

    """filter the rows which have to be updated"""
    where: user_sessions_bool_exp!
  ): user_sessions_mutation_response

  """
  update single row of the table: "user_sessions"
  """
  update_user_sessions_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: user_sessions_set_input
    pk_columns: user_sessions_pk_columns_input!
  ): user_sessions

  """
  update multiples rows of table: "user_sessions"
  """
  update_user_sessions_many(
    """updates to execute, in order"""
    updates: [user_sessions_updates!]!
  ): [user_sessions_mutation_response]

  """
  update data of the table: "user_settings"
  """
  update_user_settings(
    """sets the columns of the filtered rows to the given values"""
    _set: user_settings_set_input

    """filter the rows which have to be updated"""
    where: user_settings_bool_exp!
  ): user_settings_mutation_response

  """
  update single row of the table: "user_settings"
  """
  update_user_settings_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: user_settings_set_input
    pk_columns: user_settings_pk_columns_input!
  ): user_settings

  """
  update multiples rows of table: "user_settings"
  """
  update_user_settings_many(
    """updates to execute, in order"""
    updates: [user_settings_updates!]!
  ): [user_settings_mutation_response]

  """
  update data of the table: "users"
  """
  update_users(
    """sets the columns of the filtered rows to the given values"""
    _set: users_set_input

    """filter the rows which have to be updated"""
    where: users_bool_exp!
  ): users_mutation_response

  """
  update single row of the table: "users"
  """
  update_users_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: users_set_input
    pk_columns: users_pk_columns_input!
  ): users

  """
  update multiples rows of table: "users"
  """
  update_users_many(
    """updates to execute, in order"""
    updates: [users_updates!]!
  ): [users_mutation_response]

  """
  update data of the table: "wishlist_items"
  """
  update_wishlist_items(
    """sets the columns of the filtered rows to the given values"""
    _set: wishlist_items_set_input

    """filter the rows which have to be updated"""
    where: wishlist_items_bool_exp!
  ): wishlist_items_mutation_response

  """
  update single row of the table: "wishlist_items"
  """
  update_wishlist_items_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: wishlist_items_set_input
    pk_columns: wishlist_items_pk_columns_input!
  ): wishlist_items

  """
  update multiples rows of table: "wishlist_items"
  """
  update_wishlist_items_many(
    """updates to execute, in order"""
    updates: [wishlist_items_updates!]!
  ): [wishlist_items_mutation_response]

  """
  update data of the table: "wishlists"
  """
  update_wishlists(
    """sets the columns of the filtered rows to the given values"""
    _set: wishlists_set_input

    """filter the rows which have to be updated"""
    where: wishlists_bool_exp!
  ): wishlists_mutation_response

  """
  update single row of the table: "wishlists"
  """
  update_wishlists_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: wishlists_set_input
    pk_columns: wishlists_pk_columns_input!
  ): wishlists

  """
  update multiples rows of table: "wishlists"
  """
  update_wishlists_many(
    """updates to execute, in order"""
    updates: [wishlists_updates!]!
  ): [wishlists_mutation_response]
}

"""
columns and relationships of "neighborhoods"
"""
type neighborhoods {
  city_id: uuid
  created_at: timestamptz!
  deleted_at: timestamptz
  id: uuid!
  name: String!
  population: Int
  updated_at: timestamptz!
}

"""
aggregated selection of "neighborhoods"
"""
type neighborhoods_aggregate {
  aggregate: neighborhoods_aggregate_fields
  nodes: [neighborhoods!]!
}

"""
aggregate fields of "neighborhoods"
"""
type neighborhoods_aggregate_fields {
  avg: neighborhoods_avg_fields
  count(columns: [neighborhoods_select_column!], distinct: Boolean): Int!
  max: neighborhoods_max_fields
  min: neighborhoods_min_fields
  stddev: neighborhoods_stddev_fields
  stddev_pop: neighborhoods_stddev_pop_fields
  stddev_samp: neighborhoods_stddev_samp_fields
  sum: neighborhoods_sum_fields
  var_pop: neighborhoods_var_pop_fields
  var_samp: neighborhoods_var_samp_fields
  variance: neighborhoods_variance_fields
}

"""aggregate avg on columns"""
type neighborhoods_avg_fields {
  population: Float
}

"""
Boolean expression to filter rows from the table "neighborhoods". All fields are combined with a logical 'AND'.
"""
input neighborhoods_bool_exp {
  _and: [neighborhoods_bool_exp!]
  _not: neighborhoods_bool_exp
  _or: [neighborhoods_bool_exp!]
  city_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  deleted_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
  population: Int_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "neighborhoods"
"""
enum neighborhoods_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  neighborhoods_pkey
}

"""
input type for incrementing numeric columns in table "neighborhoods"
"""
input neighborhoods_inc_input {
  population: Int
}

"""
input type for inserting data into table "neighborhoods"
"""
input neighborhoods_insert_input {
  city_id: uuid
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  name: String
  population: Int
  updated_at: timestamptz
}

"""aggregate max on columns"""
type neighborhoods_max_fields {
  city_id: uuid
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  name: String
  population: Int
  updated_at: timestamptz
}

"""aggregate min on columns"""
type neighborhoods_min_fields {
  city_id: uuid
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  name: String
  population: Int
  updated_at: timestamptz
}

"""
response of any mutation on the table "neighborhoods"
"""
type neighborhoods_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [neighborhoods!]!
}

"""
on_conflict condition type for table "neighborhoods"
"""
input neighborhoods_on_conflict {
  constraint: neighborhoods_constraint!
  update_columns: [neighborhoods_update_column!]! = []
  where: neighborhoods_bool_exp
}

"""Ordering options when selecting data from "neighborhoods"."""
input neighborhoods_order_by {
  city_id: order_by
  created_at: order_by
  deleted_at: order_by
  id: order_by
  name: order_by
  population: order_by
  updated_at: order_by
}

"""primary key columns input for table: neighborhoods"""
input neighborhoods_pk_columns_input {
  id: uuid!
}

"""
select columns of table "neighborhoods"
"""
enum neighborhoods_select_column {
  """column name"""
  city_id

  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  name

  """column name"""
  population

  """column name"""
  updated_at
}

"""
input type for updating data in table "neighborhoods"
"""
input neighborhoods_set_input {
  city_id: uuid
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  name: String
  population: Int
  updated_at: timestamptz
}

"""aggregate stddev on columns"""
type neighborhoods_stddev_fields {
  population: Float
}

"""aggregate stddev_pop on columns"""
type neighborhoods_stddev_pop_fields {
  population: Float
}

"""aggregate stddev_samp on columns"""
type neighborhoods_stddev_samp_fields {
  population: Float
}

"""
Streaming cursor of the table "neighborhoods"
"""
input neighborhoods_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: neighborhoods_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input neighborhoods_stream_cursor_value_input {
  city_id: uuid
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  name: String
  population: Int
  updated_at: timestamptz
}

"""aggregate sum on columns"""
type neighborhoods_sum_fields {
  population: Int
}

"""
update columns of table "neighborhoods"
"""
enum neighborhoods_update_column {
  """column name"""
  city_id

  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  name

  """column name"""
  population

  """column name"""
  updated_at
}

input neighborhoods_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: neighborhoods_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: neighborhoods_set_input

  """filter the rows which have to be updated"""
  where: neighborhoods_bool_exp!
}

"""aggregate var_pop on columns"""
type neighborhoods_var_pop_fields {
  population: Float
}

"""aggregate var_samp on columns"""
type neighborhoods_var_samp_fields {
  population: Float
}

"""aggregate variance on columns"""
type neighborhoods_variance_fields {
  population: Float
}

"""
columns and relationships of "notifications"
"""
type notifications {
  actor_id: uuid
  body: String
  created_at: timestamptz!
  data(
    """JSON select path"""
    path: String
  ): jsonb
  deleted_at: timestamptz
  id: uuid!
  read_at: timestamptz
  title: String!
  type: String!
  updated_at: timestamptz!
  user_id: uuid
}

"""
aggregated selection of "notifications"
"""
type notifications_aggregate {
  aggregate: notifications_aggregate_fields
  nodes: [notifications!]!
}

"""
aggregate fields of "notifications"
"""
type notifications_aggregate_fields {
  count(columns: [notifications_select_column!], distinct: Boolean): Int!
  max: notifications_max_fields
  min: notifications_min_fields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input notifications_append_input {
  data: jsonb
}

"""
Boolean expression to filter rows from the table "notifications". All fields are combined with a logical 'AND'.
"""
input notifications_bool_exp {
  _and: [notifications_bool_exp!]
  _not: notifications_bool_exp
  _or: [notifications_bool_exp!]
  actor_id: uuid_comparison_exp
  body: String_comparison_exp
  created_at: timestamptz_comparison_exp
  data: jsonb_comparison_exp
  deleted_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  read_at: timestamptz_comparison_exp
  title: String_comparison_exp
  type: String_comparison_exp
  updated_at: timestamptz_comparison_exp
  user_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "notifications"
"""
enum notifications_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  notifications_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input notifications_delete_at_path_input {
  data: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input notifications_delete_elem_input {
  data: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input notifications_delete_key_input {
  data: String
}

"""
input type for inserting data into table "notifications"
"""
input notifications_insert_input {
  actor_id: uuid
  body: String
  created_at: timestamptz
  data: jsonb
  deleted_at: timestamptz
  id: uuid
  read_at: timestamptz
  title: String
  type: String
  updated_at: timestamptz
  user_id: uuid
}

"""aggregate max on columns"""
type notifications_max_fields {
  actor_id: uuid
  body: String
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  read_at: timestamptz
  title: String
  type: String
  updated_at: timestamptz
  user_id: uuid
}

"""aggregate min on columns"""
type notifications_min_fields {
  actor_id: uuid
  body: String
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  read_at: timestamptz
  title: String
  type: String
  updated_at: timestamptz
  user_id: uuid
}

"""
response of any mutation on the table "notifications"
"""
type notifications_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [notifications!]!
}

"""
on_conflict condition type for table "notifications"
"""
input notifications_on_conflict {
  constraint: notifications_constraint!
  update_columns: [notifications_update_column!]! = []
  where: notifications_bool_exp
}

"""Ordering options when selecting data from "notifications"."""
input notifications_order_by {
  actor_id: order_by
  body: order_by
  created_at: order_by
  data: order_by
  deleted_at: order_by
  id: order_by
  read_at: order_by
  title: order_by
  type: order_by
  updated_at: order_by
  user_id: order_by
}

"""primary key columns input for table: notifications"""
input notifications_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input notifications_prepend_input {
  data: jsonb
}

"""
select columns of table "notifications"
"""
enum notifications_select_column {
  """column name"""
  actor_id

  """column name"""
  body

  """column name"""
  created_at

  """column name"""
  data

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  read_at

  """column name"""
  title

  """column name"""
  type

  """column name"""
  updated_at

  """column name"""
  user_id
}

"""
input type for updating data in table "notifications"
"""
input notifications_set_input {
  actor_id: uuid
  body: String
  created_at: timestamptz
  data: jsonb
  deleted_at: timestamptz
  id: uuid
  read_at: timestamptz
  title: String
  type: String
  updated_at: timestamptz
  user_id: uuid
}

"""
Streaming cursor of the table "notifications"
"""
input notifications_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: notifications_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input notifications_stream_cursor_value_input {
  actor_id: uuid
  body: String
  created_at: timestamptz
  data: jsonb
  deleted_at: timestamptz
  id: uuid
  read_at: timestamptz
  title: String
  type: String
  updated_at: timestamptz
  user_id: uuid
}

"""
update columns of table "notifications"
"""
enum notifications_update_column {
  """column name"""
  actor_id

  """column name"""
  body

  """column name"""
  created_at

  """column name"""
  data

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  read_at

  """column name"""
  title

  """column name"""
  type

  """column name"""
  updated_at

  """column name"""
  user_id
}

input notifications_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: notifications_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: notifications_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: notifications_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: notifications_delete_key_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: notifications_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: notifications_set_input

  """filter the rows which have to be updated"""
  where: notifications_bool_exp!
}

scalar numeric

"""
Boolean expression to compare columns of type "numeric". All fields are combined with logical 'AND'.
"""
input numeric_comparison_exp {
  _eq: numeric
  _gt: numeric
  _gte: numeric
  _in: [numeric!]
  _is_null: Boolean
  _lt: numeric
  _lte: numeric
  _neq: numeric
  _nin: [numeric!]
}

"""column ordering options"""
enum order_by {
  """in ascending order, nulls last"""
  asc

  """in ascending order, nulls first"""
  asc_nulls_first

  """in ascending order, nulls last"""
  asc_nulls_last

  """in descending order, nulls first"""
  desc

  """in descending order, nulls first"""
  desc_nulls_first

  """in descending order, nulls last"""
  desc_nulls_last
}

"""
columns and relationships of "order_coupons"
"""
type order_coupons {
  coupon_id: uuid
  created_at: timestamptz!
  deleted_at: timestamptz
  discount_amount: numeric!
  id: uuid!
  order_id: uuid
  updated_at: timestamptz!
}

"""
aggregated selection of "order_coupons"
"""
type order_coupons_aggregate {
  aggregate: order_coupons_aggregate_fields
  nodes: [order_coupons!]!
}

"""
aggregate fields of "order_coupons"
"""
type order_coupons_aggregate_fields {
  avg: order_coupons_avg_fields
  count(columns: [order_coupons_select_column!], distinct: Boolean): Int!
  max: order_coupons_max_fields
  min: order_coupons_min_fields
  stddev: order_coupons_stddev_fields
  stddev_pop: order_coupons_stddev_pop_fields
  stddev_samp: order_coupons_stddev_samp_fields
  sum: order_coupons_sum_fields
  var_pop: order_coupons_var_pop_fields
  var_samp: order_coupons_var_samp_fields
  variance: order_coupons_variance_fields
}

"""aggregate avg on columns"""
type order_coupons_avg_fields {
  discount_amount: Float
}

"""
Boolean expression to filter rows from the table "order_coupons". All fields are combined with a logical 'AND'.
"""
input order_coupons_bool_exp {
  _and: [order_coupons_bool_exp!]
  _not: order_coupons_bool_exp
  _or: [order_coupons_bool_exp!]
  coupon_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  deleted_at: timestamptz_comparison_exp
  discount_amount: numeric_comparison_exp
  id: uuid_comparison_exp
  order_id: uuid_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "order_coupons"
"""
enum order_coupons_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  order_coupons_pkey
}

"""
input type for incrementing numeric columns in table "order_coupons"
"""
input order_coupons_inc_input {
  discount_amount: numeric
}

"""
input type for inserting data into table "order_coupons"
"""
input order_coupons_insert_input {
  coupon_id: uuid
  created_at: timestamptz
  deleted_at: timestamptz
  discount_amount: numeric
  id: uuid
  order_id: uuid
  updated_at: timestamptz
}

"""aggregate max on columns"""
type order_coupons_max_fields {
  coupon_id: uuid
  created_at: timestamptz
  deleted_at: timestamptz
  discount_amount: numeric
  id: uuid
  order_id: uuid
  updated_at: timestamptz
}

"""aggregate min on columns"""
type order_coupons_min_fields {
  coupon_id: uuid
  created_at: timestamptz
  deleted_at: timestamptz
  discount_amount: numeric
  id: uuid
  order_id: uuid
  updated_at: timestamptz
}

"""
response of any mutation on the table "order_coupons"
"""
type order_coupons_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [order_coupons!]!
}

"""
on_conflict condition type for table "order_coupons"
"""
input order_coupons_on_conflict {
  constraint: order_coupons_constraint!
  update_columns: [order_coupons_update_column!]! = []
  where: order_coupons_bool_exp
}

"""Ordering options when selecting data from "order_coupons"."""
input order_coupons_order_by {
  coupon_id: order_by
  created_at: order_by
  deleted_at: order_by
  discount_amount: order_by
  id: order_by
  order_id: order_by
  updated_at: order_by
}

"""primary key columns input for table: order_coupons"""
input order_coupons_pk_columns_input {
  id: uuid!
}

"""
select columns of table "order_coupons"
"""
enum order_coupons_select_column {
  """column name"""
  coupon_id

  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  discount_amount

  """column name"""
  id

  """column name"""
  order_id

  """column name"""
  updated_at
}

"""
input type for updating data in table "order_coupons"
"""
input order_coupons_set_input {
  coupon_id: uuid
  created_at: timestamptz
  deleted_at: timestamptz
  discount_amount: numeric
  id: uuid
  order_id: uuid
  updated_at: timestamptz
}

"""aggregate stddev on columns"""
type order_coupons_stddev_fields {
  discount_amount: Float
}

"""aggregate stddev_pop on columns"""
type order_coupons_stddev_pop_fields {
  discount_amount: Float
}

"""aggregate stddev_samp on columns"""
type order_coupons_stddev_samp_fields {
  discount_amount: Float
}

"""
Streaming cursor of the table "order_coupons"
"""
input order_coupons_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: order_coupons_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input order_coupons_stream_cursor_value_input {
  coupon_id: uuid
  created_at: timestamptz
  deleted_at: timestamptz
  discount_amount: numeric
  id: uuid
  order_id: uuid
  updated_at: timestamptz
}

"""aggregate sum on columns"""
type order_coupons_sum_fields {
  discount_amount: numeric
}

"""
update columns of table "order_coupons"
"""
enum order_coupons_update_column {
  """column name"""
  coupon_id

  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  discount_amount

  """column name"""
  id

  """column name"""
  order_id

  """column name"""
  updated_at
}

input order_coupons_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: order_coupons_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: order_coupons_set_input

  """filter the rows which have to be updated"""
  where: order_coupons_bool_exp!
}

"""aggregate var_pop on columns"""
type order_coupons_var_pop_fields {
  discount_amount: Float
}

"""aggregate var_samp on columns"""
type order_coupons_var_samp_fields {
  discount_amount: Float
}

"""aggregate variance on columns"""
type order_coupons_variance_fields {
  discount_amount: Float
}

"""
columns and relationships of "order_items"
"""
type order_items {
  created_at: timestamptz!
  deleted_at: timestamptz
  id: uuid!
  order_id: uuid
  quantity: Int!
  total_price: numeric!
  unit_price: numeric!
  updated_at: timestamptz!
  variant_id: uuid
}

"""
aggregated selection of "order_items"
"""
type order_items_aggregate {
  aggregate: order_items_aggregate_fields
  nodes: [order_items!]!
}

"""
aggregate fields of "order_items"
"""
type order_items_aggregate_fields {
  avg: order_items_avg_fields
  count(columns: [order_items_select_column!], distinct: Boolean): Int!
  max: order_items_max_fields
  min: order_items_min_fields
  stddev: order_items_stddev_fields
  stddev_pop: order_items_stddev_pop_fields
  stddev_samp: order_items_stddev_samp_fields
  sum: order_items_sum_fields
  var_pop: order_items_var_pop_fields
  var_samp: order_items_var_samp_fields
  variance: order_items_variance_fields
}

"""aggregate avg on columns"""
type order_items_avg_fields {
  quantity: Float
  total_price: Float
  unit_price: Float
}

"""
Boolean expression to filter rows from the table "order_items". All fields are combined with a logical 'AND'.
"""
input order_items_bool_exp {
  _and: [order_items_bool_exp!]
  _not: order_items_bool_exp
  _or: [order_items_bool_exp!]
  created_at: timestamptz_comparison_exp
  deleted_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  order_id: uuid_comparison_exp
  quantity: Int_comparison_exp
  total_price: numeric_comparison_exp
  unit_price: numeric_comparison_exp
  updated_at: timestamptz_comparison_exp
  variant_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "order_items"
"""
enum order_items_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  order_items_pkey
}

"""
input type for incrementing numeric columns in table "order_items"
"""
input order_items_inc_input {
  quantity: Int
  total_price: numeric
  unit_price: numeric
}

"""
input type for inserting data into table "order_items"
"""
input order_items_insert_input {
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  order_id: uuid
  quantity: Int
  total_price: numeric
  unit_price: numeric
  updated_at: timestamptz
  variant_id: uuid
}

"""aggregate max on columns"""
type order_items_max_fields {
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  order_id: uuid
  quantity: Int
  total_price: numeric
  unit_price: numeric
  updated_at: timestamptz
  variant_id: uuid
}

"""aggregate min on columns"""
type order_items_min_fields {
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  order_id: uuid
  quantity: Int
  total_price: numeric
  unit_price: numeric
  updated_at: timestamptz
  variant_id: uuid
}

"""
response of any mutation on the table "order_items"
"""
type order_items_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [order_items!]!
}

"""
on_conflict condition type for table "order_items"
"""
input order_items_on_conflict {
  constraint: order_items_constraint!
  update_columns: [order_items_update_column!]! = []
  where: order_items_bool_exp
}

"""Ordering options when selecting data from "order_items"."""
input order_items_order_by {
  created_at: order_by
  deleted_at: order_by
  id: order_by
  order_id: order_by
  quantity: order_by
  total_price: order_by
  unit_price: order_by
  updated_at: order_by
  variant_id: order_by
}

"""primary key columns input for table: order_items"""
input order_items_pk_columns_input {
  id: uuid!
}

"""
select columns of table "order_items"
"""
enum order_items_select_column {
  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  order_id

  """column name"""
  quantity

  """column name"""
  total_price

  """column name"""
  unit_price

  """column name"""
  updated_at

  """column name"""
  variant_id
}

"""
input type for updating data in table "order_items"
"""
input order_items_set_input {
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  order_id: uuid
  quantity: Int
  total_price: numeric
  unit_price: numeric
  updated_at: timestamptz
  variant_id: uuid
}

"""aggregate stddev on columns"""
type order_items_stddev_fields {
  quantity: Float
  total_price: Float
  unit_price: Float
}

"""aggregate stddev_pop on columns"""
type order_items_stddev_pop_fields {
  quantity: Float
  total_price: Float
  unit_price: Float
}

"""aggregate stddev_samp on columns"""
type order_items_stddev_samp_fields {
  quantity: Float
  total_price: Float
  unit_price: Float
}

"""
Streaming cursor of the table "order_items"
"""
input order_items_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: order_items_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input order_items_stream_cursor_value_input {
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  order_id: uuid
  quantity: Int
  total_price: numeric
  unit_price: numeric
  updated_at: timestamptz
  variant_id: uuid
}

"""aggregate sum on columns"""
type order_items_sum_fields {
  quantity: Int
  total_price: numeric
  unit_price: numeric
}

"""
update columns of table "order_items"
"""
enum order_items_update_column {
  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  order_id

  """column name"""
  quantity

  """column name"""
  total_price

  """column name"""
  unit_price

  """column name"""
  updated_at

  """column name"""
  variant_id
}

input order_items_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: order_items_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: order_items_set_input

  """filter the rows which have to be updated"""
  where: order_items_bool_exp!
}

"""aggregate var_pop on columns"""
type order_items_var_pop_fields {
  quantity: Float
  total_price: Float
  unit_price: Float
}

"""aggregate var_samp on columns"""
type order_items_var_samp_fields {
  quantity: Float
  total_price: Float
  unit_price: Float
}

"""aggregate variance on columns"""
type order_items_variance_fields {
  quantity: Float
  total_price: Float
  unit_price: Float
}

"""
columns and relationships of "order_statuses"
"""
type order_statuses {
  code: String!
  created_at: timestamptz!
  deleted_at: timestamptz
  id: uuid!
  is_final: Boolean!
  name: String!
  sort_order: Int!
  updated_at: timestamptz!
}

"""
aggregated selection of "order_statuses"
"""
type order_statuses_aggregate {
  aggregate: order_statuses_aggregate_fields
  nodes: [order_statuses!]!
}

"""
aggregate fields of "order_statuses"
"""
type order_statuses_aggregate_fields {
  avg: order_statuses_avg_fields
  count(columns: [order_statuses_select_column!], distinct: Boolean): Int!
  max: order_statuses_max_fields
  min: order_statuses_min_fields
  stddev: order_statuses_stddev_fields
  stddev_pop: order_statuses_stddev_pop_fields
  stddev_samp: order_statuses_stddev_samp_fields
  sum: order_statuses_sum_fields
  var_pop: order_statuses_var_pop_fields
  var_samp: order_statuses_var_samp_fields
  variance: order_statuses_variance_fields
}

"""aggregate avg on columns"""
type order_statuses_avg_fields {
  sort_order: Float
}

"""
Boolean expression to filter rows from the table "order_statuses". All fields are combined with a logical 'AND'.
"""
input order_statuses_bool_exp {
  _and: [order_statuses_bool_exp!]
  _not: order_statuses_bool_exp
  _or: [order_statuses_bool_exp!]
  code: String_comparison_exp
  created_at: timestamptz_comparison_exp
  deleted_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  is_final: Boolean_comparison_exp
  name: String_comparison_exp
  sort_order: Int_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "order_statuses"
"""
enum order_statuses_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  order_statuses_pkey
}

"""
input type for incrementing numeric columns in table "order_statuses"
"""
input order_statuses_inc_input {
  sort_order: Int
}

"""
input type for inserting data into table "order_statuses"
"""
input order_statuses_insert_input {
  code: String
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  is_final: Boolean
  name: String
  sort_order: Int
  updated_at: timestamptz
}

"""aggregate max on columns"""
type order_statuses_max_fields {
  code: String
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  name: String
  sort_order: Int
  updated_at: timestamptz
}

"""aggregate min on columns"""
type order_statuses_min_fields {
  code: String
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  name: String
  sort_order: Int
  updated_at: timestamptz
}

"""
response of any mutation on the table "order_statuses"
"""
type order_statuses_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [order_statuses!]!
}

"""
on_conflict condition type for table "order_statuses"
"""
input order_statuses_on_conflict {
  constraint: order_statuses_constraint!
  update_columns: [order_statuses_update_column!]! = []
  where: order_statuses_bool_exp
}

"""Ordering options when selecting data from "order_statuses"."""
input order_statuses_order_by {
  code: order_by
  created_at: order_by
  deleted_at: order_by
  id: order_by
  is_final: order_by
  name: order_by
  sort_order: order_by
  updated_at: order_by
}

"""primary key columns input for table: order_statuses"""
input order_statuses_pk_columns_input {
  id: uuid!
}

"""
select columns of table "order_statuses"
"""
enum order_statuses_select_column {
  """column name"""
  code

  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  is_final

  """column name"""
  name

  """column name"""
  sort_order

  """column name"""
  updated_at
}

"""
input type for updating data in table "order_statuses"
"""
input order_statuses_set_input {
  code: String
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  is_final: Boolean
  name: String
  sort_order: Int
  updated_at: timestamptz
}

"""aggregate stddev on columns"""
type order_statuses_stddev_fields {
  sort_order: Float
}

"""aggregate stddev_pop on columns"""
type order_statuses_stddev_pop_fields {
  sort_order: Float
}

"""aggregate stddev_samp on columns"""
type order_statuses_stddev_samp_fields {
  sort_order: Float
}

"""
Streaming cursor of the table "order_statuses"
"""
input order_statuses_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: order_statuses_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input order_statuses_stream_cursor_value_input {
  code: String
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  is_final: Boolean
  name: String
  sort_order: Int
  updated_at: timestamptz
}

"""aggregate sum on columns"""
type order_statuses_sum_fields {
  sort_order: Int
}

"""
update columns of table "order_statuses"
"""
enum order_statuses_update_column {
  """column name"""
  code

  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  is_final

  """column name"""
  name

  """column name"""
  sort_order

  """column name"""
  updated_at
}

input order_statuses_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: order_statuses_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: order_statuses_set_input

  """filter the rows which have to be updated"""
  where: order_statuses_bool_exp!
}

"""aggregate var_pop on columns"""
type order_statuses_var_pop_fields {
  sort_order: Float
}

"""aggregate var_samp on columns"""
type order_statuses_var_samp_fields {
  sort_order: Float
}

"""aggregate variance on columns"""
type order_statuses_variance_fields {
  sort_order: Float
}

"""
columns and relationships of "orders"
"""
type orders {
  billing_address_id: uuid
  created_at: timestamptz!
  customer_id: uuid
  deleted_at: timestamptz
  id: uuid!
  notes: String
  order_number: String!
  shipping_address_id: uuid
  status_id: uuid
  store_id: uuid
  total_amount: numeric!
  updated_at: timestamptz!
}

"""
aggregated selection of "orders"
"""
type orders_aggregate {
  aggregate: orders_aggregate_fields
  nodes: [orders!]!
}

"""
aggregate fields of "orders"
"""
type orders_aggregate_fields {
  avg: orders_avg_fields
  count(columns: [orders_select_column!], distinct: Boolean): Int!
  max: orders_max_fields
  min: orders_min_fields
  stddev: orders_stddev_fields
  stddev_pop: orders_stddev_pop_fields
  stddev_samp: orders_stddev_samp_fields
  sum: orders_sum_fields
  var_pop: orders_var_pop_fields
  var_samp: orders_var_samp_fields
  variance: orders_variance_fields
}

"""aggregate avg on columns"""
type orders_avg_fields {
  total_amount: Float
}

"""
Boolean expression to filter rows from the table "orders". All fields are combined with a logical 'AND'.
"""
input orders_bool_exp {
  _and: [orders_bool_exp!]
  _not: orders_bool_exp
  _or: [orders_bool_exp!]
  billing_address_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  customer_id: uuid_comparison_exp
  deleted_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  notes: String_comparison_exp
  order_number: String_comparison_exp
  shipping_address_id: uuid_comparison_exp
  status_id: uuid_comparison_exp
  store_id: uuid_comparison_exp
  total_amount: numeric_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "orders"
"""
enum orders_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  orders_pkey
}

"""
input type for incrementing numeric columns in table "orders"
"""
input orders_inc_input {
  total_amount: numeric
}

"""
input type for inserting data into table "orders"
"""
input orders_insert_input {
  billing_address_id: uuid
  created_at: timestamptz
  customer_id: uuid
  deleted_at: timestamptz
  id: uuid
  notes: String
  order_number: String
  shipping_address_id: uuid
  status_id: uuid
  store_id: uuid
  total_amount: numeric
  updated_at: timestamptz
}

"""aggregate max on columns"""
type orders_max_fields {
  billing_address_id: uuid
  created_at: timestamptz
  customer_id: uuid
  deleted_at: timestamptz
  id: uuid
  notes: String
  order_number: String
  shipping_address_id: uuid
  status_id: uuid
  store_id: uuid
  total_amount: numeric
  updated_at: timestamptz
}

"""aggregate min on columns"""
type orders_min_fields {
  billing_address_id: uuid
  created_at: timestamptz
  customer_id: uuid
  deleted_at: timestamptz
  id: uuid
  notes: String
  order_number: String
  shipping_address_id: uuid
  status_id: uuid
  store_id: uuid
  total_amount: numeric
  updated_at: timestamptz
}

"""
response of any mutation on the table "orders"
"""
type orders_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [orders!]!
}

"""
on_conflict condition type for table "orders"
"""
input orders_on_conflict {
  constraint: orders_constraint!
  update_columns: [orders_update_column!]! = []
  where: orders_bool_exp
}

"""Ordering options when selecting data from "orders"."""
input orders_order_by {
  billing_address_id: order_by
  created_at: order_by
  customer_id: order_by
  deleted_at: order_by
  id: order_by
  notes: order_by
  order_number: order_by
  shipping_address_id: order_by
  status_id: order_by
  store_id: order_by
  total_amount: order_by
  updated_at: order_by
}

"""primary key columns input for table: orders"""
input orders_pk_columns_input {
  id: uuid!
}

"""
select columns of table "orders"
"""
enum orders_select_column {
  """column name"""
  billing_address_id

  """column name"""
  created_at

  """column name"""
  customer_id

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  notes

  """column name"""
  order_number

  """column name"""
  shipping_address_id

  """column name"""
  status_id

  """column name"""
  store_id

  """column name"""
  total_amount

  """column name"""
  updated_at
}

"""
input type for updating data in table "orders"
"""
input orders_set_input {
  billing_address_id: uuid
  created_at: timestamptz
  customer_id: uuid
  deleted_at: timestamptz
  id: uuid
  notes: String
  order_number: String
  shipping_address_id: uuid
  status_id: uuid
  store_id: uuid
  total_amount: numeric
  updated_at: timestamptz
}

"""aggregate stddev on columns"""
type orders_stddev_fields {
  total_amount: Float
}

"""aggregate stddev_pop on columns"""
type orders_stddev_pop_fields {
  total_amount: Float
}

"""aggregate stddev_samp on columns"""
type orders_stddev_samp_fields {
  total_amount: Float
}

"""
Streaming cursor of the table "orders"
"""
input orders_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: orders_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input orders_stream_cursor_value_input {
  billing_address_id: uuid
  created_at: timestamptz
  customer_id: uuid
  deleted_at: timestamptz
  id: uuid
  notes: String
  order_number: String
  shipping_address_id: uuid
  status_id: uuid
  store_id: uuid
  total_amount: numeric
  updated_at: timestamptz
}

"""aggregate sum on columns"""
type orders_sum_fields {
  total_amount: numeric
}

"""
update columns of table "orders"
"""
enum orders_update_column {
  """column name"""
  billing_address_id

  """column name"""
  created_at

  """column name"""
  customer_id

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  notes

  """column name"""
  order_number

  """column name"""
  shipping_address_id

  """column name"""
  status_id

  """column name"""
  store_id

  """column name"""
  total_amount

  """column name"""
  updated_at
}

input orders_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: orders_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: orders_set_input

  """filter the rows which have to be updated"""
  where: orders_bool_exp!
}

"""aggregate var_pop on columns"""
type orders_var_pop_fields {
  total_amount: Float
}

"""aggregate var_samp on columns"""
type orders_var_samp_fields {
  total_amount: Float
}

"""aggregate variance on columns"""
type orders_variance_fields {
  total_amount: Float
}

"""
columns and relationships of "page_templates"
"""
type page_templates {
  created_at: timestamptz!
  deleted_at: timestamptz
  id: uuid!
  name: String!
  schema(
    """JSON select path"""
    path: String
  ): jsonb
  site_id: uuid
  slug: String!
  updated_at: timestamptz!
}

"""
aggregated selection of "page_templates"
"""
type page_templates_aggregate {
  aggregate: page_templates_aggregate_fields
  nodes: [page_templates!]!
}

"""
aggregate fields of "page_templates"
"""
type page_templates_aggregate_fields {
  count(columns: [page_templates_select_column!], distinct: Boolean): Int!
  max: page_templates_max_fields
  min: page_templates_min_fields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input page_templates_append_input {
  schema: jsonb
}

"""
Boolean expression to filter rows from the table "page_templates". All fields are combined with a logical 'AND'.
"""
input page_templates_bool_exp {
  _and: [page_templates_bool_exp!]
  _not: page_templates_bool_exp
  _or: [page_templates_bool_exp!]
  created_at: timestamptz_comparison_exp
  deleted_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
  schema: jsonb_comparison_exp
  site_id: uuid_comparison_exp
  slug: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "page_templates"
"""
enum page_templates_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  page_templates_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input page_templates_delete_at_path_input {
  schema: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input page_templates_delete_elem_input {
  schema: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input page_templates_delete_key_input {
  schema: String
}

"""
input type for inserting data into table "page_templates"
"""
input page_templates_insert_input {
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  name: String
  schema: jsonb
  site_id: uuid
  slug: String
  updated_at: timestamptz
}

"""aggregate max on columns"""
type page_templates_max_fields {
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  name: String
  site_id: uuid
  slug: String
  updated_at: timestamptz
}

"""aggregate min on columns"""
type page_templates_min_fields {
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  name: String
  site_id: uuid
  slug: String
  updated_at: timestamptz
}

"""
response of any mutation on the table "page_templates"
"""
type page_templates_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [page_templates!]!
}

"""
on_conflict condition type for table "page_templates"
"""
input page_templates_on_conflict {
  constraint: page_templates_constraint!
  update_columns: [page_templates_update_column!]! = []
  where: page_templates_bool_exp
}

"""Ordering options when selecting data from "page_templates"."""
input page_templates_order_by {
  created_at: order_by
  deleted_at: order_by
  id: order_by
  name: order_by
  schema: order_by
  site_id: order_by
  slug: order_by
  updated_at: order_by
}

"""primary key columns input for table: page_templates"""
input page_templates_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input page_templates_prepend_input {
  schema: jsonb
}

"""
select columns of table "page_templates"
"""
enum page_templates_select_column {
  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  name

  """column name"""
  schema

  """column name"""
  site_id

  """column name"""
  slug

  """column name"""
  updated_at
}

"""
input type for updating data in table "page_templates"
"""
input page_templates_set_input {
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  name: String
  schema: jsonb
  site_id: uuid
  slug: String
  updated_at: timestamptz
}

"""
Streaming cursor of the table "page_templates"
"""
input page_templates_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: page_templates_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input page_templates_stream_cursor_value_input {
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  name: String
  schema: jsonb
  site_id: uuid
  slug: String
  updated_at: timestamptz
}

"""
update columns of table "page_templates"
"""
enum page_templates_update_column {
  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  name

  """column name"""
  schema

  """column name"""
  site_id

  """column name"""
  slug

  """column name"""
  updated_at
}

input page_templates_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: page_templates_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: page_templates_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: page_templates_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: page_templates_delete_key_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: page_templates_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: page_templates_set_input

  """filter the rows which have to be updated"""
  where: page_templates_bool_exp!
}

"""
columns and relationships of "page_versions"
"""
type page_versions {
  author_id: uuid
  content: String!
  created_at: timestamptz!
  deleted_at: timestamptz
  id: uuid!
  page_id: uuid
  published_at: timestamptz
  updated_at: timestamptz!
  version_number: Int!
}

"""
aggregated selection of "page_versions"
"""
type page_versions_aggregate {
  aggregate: page_versions_aggregate_fields
  nodes: [page_versions!]!
}

"""
aggregate fields of "page_versions"
"""
type page_versions_aggregate_fields {
  avg: page_versions_avg_fields
  count(columns: [page_versions_select_column!], distinct: Boolean): Int!
  max: page_versions_max_fields
  min: page_versions_min_fields
  stddev: page_versions_stddev_fields
  stddev_pop: page_versions_stddev_pop_fields
  stddev_samp: page_versions_stddev_samp_fields
  sum: page_versions_sum_fields
  var_pop: page_versions_var_pop_fields
  var_samp: page_versions_var_samp_fields
  variance: page_versions_variance_fields
}

"""aggregate avg on columns"""
type page_versions_avg_fields {
  version_number: Float
}

"""
Boolean expression to filter rows from the table "page_versions". All fields are combined with a logical 'AND'.
"""
input page_versions_bool_exp {
  _and: [page_versions_bool_exp!]
  _not: page_versions_bool_exp
  _or: [page_versions_bool_exp!]
  author_id: uuid_comparison_exp
  content: String_comparison_exp
  created_at: timestamptz_comparison_exp
  deleted_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  page_id: uuid_comparison_exp
  published_at: timestamptz_comparison_exp
  updated_at: timestamptz_comparison_exp
  version_number: Int_comparison_exp
}

"""
unique or primary key constraints on table "page_versions"
"""
enum page_versions_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  page_versions_pkey
}

"""
input type for incrementing numeric columns in table "page_versions"
"""
input page_versions_inc_input {
  version_number: Int
}

"""
input type for inserting data into table "page_versions"
"""
input page_versions_insert_input {
  author_id: uuid
  content: String
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  page_id: uuid
  published_at: timestamptz
  updated_at: timestamptz
  version_number: Int
}

"""aggregate max on columns"""
type page_versions_max_fields {
  author_id: uuid
  content: String
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  page_id: uuid
  published_at: timestamptz
  updated_at: timestamptz
  version_number: Int
}

"""aggregate min on columns"""
type page_versions_min_fields {
  author_id: uuid
  content: String
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  page_id: uuid
  published_at: timestamptz
  updated_at: timestamptz
  version_number: Int
}

"""
response of any mutation on the table "page_versions"
"""
type page_versions_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [page_versions!]!
}

"""
on_conflict condition type for table "page_versions"
"""
input page_versions_on_conflict {
  constraint: page_versions_constraint!
  update_columns: [page_versions_update_column!]! = []
  where: page_versions_bool_exp
}

"""Ordering options when selecting data from "page_versions"."""
input page_versions_order_by {
  author_id: order_by
  content: order_by
  created_at: order_by
  deleted_at: order_by
  id: order_by
  page_id: order_by
  published_at: order_by
  updated_at: order_by
  version_number: order_by
}

"""primary key columns input for table: page_versions"""
input page_versions_pk_columns_input {
  id: uuid!
}

"""
select columns of table "page_versions"
"""
enum page_versions_select_column {
  """column name"""
  author_id

  """column name"""
  content

  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  page_id

  """column name"""
  published_at

  """column name"""
  updated_at

  """column name"""
  version_number
}

"""
input type for updating data in table "page_versions"
"""
input page_versions_set_input {
  author_id: uuid
  content: String
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  page_id: uuid
  published_at: timestamptz
  updated_at: timestamptz
  version_number: Int
}

"""aggregate stddev on columns"""
type page_versions_stddev_fields {
  version_number: Float
}

"""aggregate stddev_pop on columns"""
type page_versions_stddev_pop_fields {
  version_number: Float
}

"""aggregate stddev_samp on columns"""
type page_versions_stddev_samp_fields {
  version_number: Float
}

"""
Streaming cursor of the table "page_versions"
"""
input page_versions_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: page_versions_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input page_versions_stream_cursor_value_input {
  author_id: uuid
  content: String
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  page_id: uuid
  published_at: timestamptz
  updated_at: timestamptz
  version_number: Int
}

"""aggregate sum on columns"""
type page_versions_sum_fields {
  version_number: Int
}

"""
update columns of table "page_versions"
"""
enum page_versions_update_column {
  """column name"""
  author_id

  """column name"""
  content

  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  page_id

  """column name"""
  published_at

  """column name"""
  updated_at

  """column name"""
  version_number
}

input page_versions_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: page_versions_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: page_versions_set_input

  """filter the rows which have to be updated"""
  where: page_versions_bool_exp!
}

"""aggregate var_pop on columns"""
type page_versions_var_pop_fields {
  version_number: Float
}

"""aggregate var_samp on columns"""
type page_versions_var_samp_fields {
  version_number: Float
}

"""aggregate variance on columns"""
type page_versions_variance_fields {
  version_number: Float
}

"""
columns and relationships of "pages"
"""
type pages {
  content: String
  created_at: timestamptz!
  deleted_at: timestamptz
  id: uuid!
  is_published: Boolean!
  meta_description: String
  meta_title: String
  parent_id: uuid
  published_at: timestamptz
  site_id: uuid
  slug: String!
  sort_order: Int!
  template_id: uuid
  title: String!
  updated_at: timestamptz!
}

"""
aggregated selection of "pages"
"""
type pages_aggregate {
  aggregate: pages_aggregate_fields
  nodes: [pages!]!
}

"""
aggregate fields of "pages"
"""
type pages_aggregate_fields {
  avg: pages_avg_fields
  count(columns: [pages_select_column!], distinct: Boolean): Int!
  max: pages_max_fields
  min: pages_min_fields
  stddev: pages_stddev_fields
  stddev_pop: pages_stddev_pop_fields
  stddev_samp: pages_stddev_samp_fields
  sum: pages_sum_fields
  var_pop: pages_var_pop_fields
  var_samp: pages_var_samp_fields
  variance: pages_variance_fields
}

"""aggregate avg on columns"""
type pages_avg_fields {
  sort_order: Float
}

"""
Boolean expression to filter rows from the table "pages". All fields are combined with a logical 'AND'.
"""
input pages_bool_exp {
  _and: [pages_bool_exp!]
  _not: pages_bool_exp
  _or: [pages_bool_exp!]
  content: String_comparison_exp
  created_at: timestamptz_comparison_exp
  deleted_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  is_published: Boolean_comparison_exp
  meta_description: String_comparison_exp
  meta_title: String_comparison_exp
  parent_id: uuid_comparison_exp
  published_at: timestamptz_comparison_exp
  site_id: uuid_comparison_exp
  slug: String_comparison_exp
  sort_order: Int_comparison_exp
  template_id: uuid_comparison_exp
  title: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "pages"
"""
enum pages_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  pages_pkey
}

"""
input type for incrementing numeric columns in table "pages"
"""
input pages_inc_input {
  sort_order: Int
}

"""
input type for inserting data into table "pages"
"""
input pages_insert_input {
  content: String
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  is_published: Boolean
  meta_description: String
  meta_title: String
  parent_id: uuid
  published_at: timestamptz
  site_id: uuid
  slug: String
  sort_order: Int
  template_id: uuid
  title: String
  updated_at: timestamptz
}

"""aggregate max on columns"""
type pages_max_fields {
  content: String
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  meta_description: String
  meta_title: String
  parent_id: uuid
  published_at: timestamptz
  site_id: uuid
  slug: String
  sort_order: Int
  template_id: uuid
  title: String
  updated_at: timestamptz
}

"""aggregate min on columns"""
type pages_min_fields {
  content: String
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  meta_description: String
  meta_title: String
  parent_id: uuid
  published_at: timestamptz
  site_id: uuid
  slug: String
  sort_order: Int
  template_id: uuid
  title: String
  updated_at: timestamptz
}

"""
response of any mutation on the table "pages"
"""
type pages_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [pages!]!
}

"""
on_conflict condition type for table "pages"
"""
input pages_on_conflict {
  constraint: pages_constraint!
  update_columns: [pages_update_column!]! = []
  where: pages_bool_exp
}

"""Ordering options when selecting data from "pages"."""
input pages_order_by {
  content: order_by
  created_at: order_by
  deleted_at: order_by
  id: order_by
  is_published: order_by
  meta_description: order_by
  meta_title: order_by
  parent_id: order_by
  published_at: order_by
  site_id: order_by
  slug: order_by
  sort_order: order_by
  template_id: order_by
  title: order_by
  updated_at: order_by
}

"""primary key columns input for table: pages"""
input pages_pk_columns_input {
  id: uuid!
}

"""
select columns of table "pages"
"""
enum pages_select_column {
  """column name"""
  content

  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  is_published

  """column name"""
  meta_description

  """column name"""
  meta_title

  """column name"""
  parent_id

  """column name"""
  published_at

  """column name"""
  site_id

  """column name"""
  slug

  """column name"""
  sort_order

  """column name"""
  template_id

  """column name"""
  title

  """column name"""
  updated_at
}

"""
input type for updating data in table "pages"
"""
input pages_set_input {
  content: String
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  is_published: Boolean
  meta_description: String
  meta_title: String
  parent_id: uuid
  published_at: timestamptz
  site_id: uuid
  slug: String
  sort_order: Int
  template_id: uuid
  title: String
  updated_at: timestamptz
}

"""aggregate stddev on columns"""
type pages_stddev_fields {
  sort_order: Float
}

"""aggregate stddev_pop on columns"""
type pages_stddev_pop_fields {
  sort_order: Float
}

"""aggregate stddev_samp on columns"""
type pages_stddev_samp_fields {
  sort_order: Float
}

"""
Streaming cursor of the table "pages"
"""
input pages_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: pages_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input pages_stream_cursor_value_input {
  content: String
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  is_published: Boolean
  meta_description: String
  meta_title: String
  parent_id: uuid
  published_at: timestamptz
  site_id: uuid
  slug: String
  sort_order: Int
  template_id: uuid
  title: String
  updated_at: timestamptz
}

"""aggregate sum on columns"""
type pages_sum_fields {
  sort_order: Int
}

"""
update columns of table "pages"
"""
enum pages_update_column {
  """column name"""
  content

  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  is_published

  """column name"""
  meta_description

  """column name"""
  meta_title

  """column name"""
  parent_id

  """column name"""
  published_at

  """column name"""
  site_id

  """column name"""
  slug

  """column name"""
  sort_order

  """column name"""
  template_id

  """column name"""
  title

  """column name"""
  updated_at
}

input pages_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: pages_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: pages_set_input

  """filter the rows which have to be updated"""
  where: pages_bool_exp!
}

"""aggregate var_pop on columns"""
type pages_var_pop_fields {
  sort_order: Float
}

"""aggregate var_samp on columns"""
type pages_var_samp_fields {
  sort_order: Float
}

"""aggregate variance on columns"""
type pages_variance_fields {
  sort_order: Float
}

"""
columns and relationships of "payment_methods"
"""
type payment_methods {
  code: String!
  created_at: timestamptz!
  deleted_at: timestamptz
  id: uuid!
  is_active: Boolean!
  name: String!
  updated_at: timestamptz!
}

"""
aggregated selection of "payment_methods"
"""
type payment_methods_aggregate {
  aggregate: payment_methods_aggregate_fields
  nodes: [payment_methods!]!
}

"""
aggregate fields of "payment_methods"
"""
type payment_methods_aggregate_fields {
  count(columns: [payment_methods_select_column!], distinct: Boolean): Int!
  max: payment_methods_max_fields
  min: payment_methods_min_fields
}

"""
Boolean expression to filter rows from the table "payment_methods". All fields are combined with a logical 'AND'.
"""
input payment_methods_bool_exp {
  _and: [payment_methods_bool_exp!]
  _not: payment_methods_bool_exp
  _or: [payment_methods_bool_exp!]
  code: String_comparison_exp
  created_at: timestamptz_comparison_exp
  deleted_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  is_active: Boolean_comparison_exp
  name: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "payment_methods"
"""
enum payment_methods_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  payment_methods_pkey
}

"""
input type for inserting data into table "payment_methods"
"""
input payment_methods_insert_input {
  code: String
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  is_active: Boolean
  name: String
  updated_at: timestamptz
}

"""aggregate max on columns"""
type payment_methods_max_fields {
  code: String
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  name: String
  updated_at: timestamptz
}

"""aggregate min on columns"""
type payment_methods_min_fields {
  code: String
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  name: String
  updated_at: timestamptz
}

"""
response of any mutation on the table "payment_methods"
"""
type payment_methods_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [payment_methods!]!
}

"""
on_conflict condition type for table "payment_methods"
"""
input payment_methods_on_conflict {
  constraint: payment_methods_constraint!
  update_columns: [payment_methods_update_column!]! = []
  where: payment_methods_bool_exp
}

"""Ordering options when selecting data from "payment_methods"."""
input payment_methods_order_by {
  code: order_by
  created_at: order_by
  deleted_at: order_by
  id: order_by
  is_active: order_by
  name: order_by
  updated_at: order_by
}

"""primary key columns input for table: payment_methods"""
input payment_methods_pk_columns_input {
  id: uuid!
}

"""
select columns of table "payment_methods"
"""
enum payment_methods_select_column {
  """column name"""
  code

  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  is_active

  """column name"""
  name

  """column name"""
  updated_at
}

"""
input type for updating data in table "payment_methods"
"""
input payment_methods_set_input {
  code: String
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  is_active: Boolean
  name: String
  updated_at: timestamptz
}

"""
Streaming cursor of the table "payment_methods"
"""
input payment_methods_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: payment_methods_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input payment_methods_stream_cursor_value_input {
  code: String
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  is_active: Boolean
  name: String
  updated_at: timestamptz
}

"""
update columns of table "payment_methods"
"""
enum payment_methods_update_column {
  """column name"""
  code

  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  is_active

  """column name"""
  name

  """column name"""
  updated_at
}

input payment_methods_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: payment_methods_set_input

  """filter the rows which have to be updated"""
  where: payment_methods_bool_exp!
}

"""
columns and relationships of "payment_statuses"
"""
type payment_statuses {
  code: String!
  created_at: timestamptz!
  deleted_at: timestamptz
  id: uuid!
  name: String!
  sort_order: Int!
  updated_at: timestamptz!
}

"""
aggregated selection of "payment_statuses"
"""
type payment_statuses_aggregate {
  aggregate: payment_statuses_aggregate_fields
  nodes: [payment_statuses!]!
}

"""
aggregate fields of "payment_statuses"
"""
type payment_statuses_aggregate_fields {
  avg: payment_statuses_avg_fields
  count(columns: [payment_statuses_select_column!], distinct: Boolean): Int!
  max: payment_statuses_max_fields
  min: payment_statuses_min_fields
  stddev: payment_statuses_stddev_fields
  stddev_pop: payment_statuses_stddev_pop_fields
  stddev_samp: payment_statuses_stddev_samp_fields
  sum: payment_statuses_sum_fields
  var_pop: payment_statuses_var_pop_fields
  var_samp: payment_statuses_var_samp_fields
  variance: payment_statuses_variance_fields
}

"""aggregate avg on columns"""
type payment_statuses_avg_fields {
  sort_order: Float
}

"""
Boolean expression to filter rows from the table "payment_statuses". All fields are combined with a logical 'AND'.
"""
input payment_statuses_bool_exp {
  _and: [payment_statuses_bool_exp!]
  _not: payment_statuses_bool_exp
  _or: [payment_statuses_bool_exp!]
  code: String_comparison_exp
  created_at: timestamptz_comparison_exp
  deleted_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
  sort_order: Int_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "payment_statuses"
"""
enum payment_statuses_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  payment_statuses_pkey
}

"""
input type for incrementing numeric columns in table "payment_statuses"
"""
input payment_statuses_inc_input {
  sort_order: Int
}

"""
input type for inserting data into table "payment_statuses"
"""
input payment_statuses_insert_input {
  code: String
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  name: String
  sort_order: Int
  updated_at: timestamptz
}

"""aggregate max on columns"""
type payment_statuses_max_fields {
  code: String
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  name: String
  sort_order: Int
  updated_at: timestamptz
}

"""aggregate min on columns"""
type payment_statuses_min_fields {
  code: String
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  name: String
  sort_order: Int
  updated_at: timestamptz
}

"""
response of any mutation on the table "payment_statuses"
"""
type payment_statuses_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [payment_statuses!]!
}

"""
on_conflict condition type for table "payment_statuses"
"""
input payment_statuses_on_conflict {
  constraint: payment_statuses_constraint!
  update_columns: [payment_statuses_update_column!]! = []
  where: payment_statuses_bool_exp
}

"""Ordering options when selecting data from "payment_statuses"."""
input payment_statuses_order_by {
  code: order_by
  created_at: order_by
  deleted_at: order_by
  id: order_by
  name: order_by
  sort_order: order_by
  updated_at: order_by
}

"""primary key columns input for table: payment_statuses"""
input payment_statuses_pk_columns_input {
  id: uuid!
}

"""
select columns of table "payment_statuses"
"""
enum payment_statuses_select_column {
  """column name"""
  code

  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  name

  """column name"""
  sort_order

  """column name"""
  updated_at
}

"""
input type for updating data in table "payment_statuses"
"""
input payment_statuses_set_input {
  code: String
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  name: String
  sort_order: Int
  updated_at: timestamptz
}

"""aggregate stddev on columns"""
type payment_statuses_stddev_fields {
  sort_order: Float
}

"""aggregate stddev_pop on columns"""
type payment_statuses_stddev_pop_fields {
  sort_order: Float
}

"""aggregate stddev_samp on columns"""
type payment_statuses_stddev_samp_fields {
  sort_order: Float
}

"""
Streaming cursor of the table "payment_statuses"
"""
input payment_statuses_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: payment_statuses_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input payment_statuses_stream_cursor_value_input {
  code: String
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  name: String
  sort_order: Int
  updated_at: timestamptz
}

"""aggregate sum on columns"""
type payment_statuses_sum_fields {
  sort_order: Int
}

"""
update columns of table "payment_statuses"
"""
enum payment_statuses_update_column {
  """column name"""
  code

  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  name

  """column name"""
  sort_order

  """column name"""
  updated_at
}

input payment_statuses_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: payment_statuses_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: payment_statuses_set_input

  """filter the rows which have to be updated"""
  where: payment_statuses_bool_exp!
}

"""aggregate var_pop on columns"""
type payment_statuses_var_pop_fields {
  sort_order: Float
}

"""aggregate var_samp on columns"""
type payment_statuses_var_samp_fields {
  sort_order: Float
}

"""aggregate variance on columns"""
type payment_statuses_variance_fields {
  sort_order: Float
}

"""
columns and relationships of "payments"
"""
type payments {
  amount: numeric!
  created_at: timestamptz!
  deleted_at: timestamptz
  id: uuid!
  method_id: uuid
  order_id: uuid
  paid_at: timestamptz
  status_id: uuid
  transaction_id: String
  updated_at: timestamptz!
}

"""
aggregated selection of "payments"
"""
type payments_aggregate {
  aggregate: payments_aggregate_fields
  nodes: [payments!]!
}

"""
aggregate fields of "payments"
"""
type payments_aggregate_fields {
  avg: payments_avg_fields
  count(columns: [payments_select_column!], distinct: Boolean): Int!
  max: payments_max_fields
  min: payments_min_fields
  stddev: payments_stddev_fields
  stddev_pop: payments_stddev_pop_fields
  stddev_samp: payments_stddev_samp_fields
  sum: payments_sum_fields
  var_pop: payments_var_pop_fields
  var_samp: payments_var_samp_fields
  variance: payments_variance_fields
}

"""aggregate avg on columns"""
type payments_avg_fields {
  amount: Float
}

"""
Boolean expression to filter rows from the table "payments". All fields are combined with a logical 'AND'.
"""
input payments_bool_exp {
  _and: [payments_bool_exp!]
  _not: payments_bool_exp
  _or: [payments_bool_exp!]
  amount: numeric_comparison_exp
  created_at: timestamptz_comparison_exp
  deleted_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  method_id: uuid_comparison_exp
  order_id: uuid_comparison_exp
  paid_at: timestamptz_comparison_exp
  status_id: uuid_comparison_exp
  transaction_id: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "payments"
"""
enum payments_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  payments_pkey
}

"""
input type for incrementing numeric columns in table "payments"
"""
input payments_inc_input {
  amount: numeric
}

"""
input type for inserting data into table "payments"
"""
input payments_insert_input {
  amount: numeric
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  method_id: uuid
  order_id: uuid
  paid_at: timestamptz
  status_id: uuid
  transaction_id: String
  updated_at: timestamptz
}

"""aggregate max on columns"""
type payments_max_fields {
  amount: numeric
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  method_id: uuid
  order_id: uuid
  paid_at: timestamptz
  status_id: uuid
  transaction_id: String
  updated_at: timestamptz
}

"""aggregate min on columns"""
type payments_min_fields {
  amount: numeric
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  method_id: uuid
  order_id: uuid
  paid_at: timestamptz
  status_id: uuid
  transaction_id: String
  updated_at: timestamptz
}

"""
response of any mutation on the table "payments"
"""
type payments_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [payments!]!
}

"""
on_conflict condition type for table "payments"
"""
input payments_on_conflict {
  constraint: payments_constraint!
  update_columns: [payments_update_column!]! = []
  where: payments_bool_exp
}

"""Ordering options when selecting data from "payments"."""
input payments_order_by {
  amount: order_by
  created_at: order_by
  deleted_at: order_by
  id: order_by
  method_id: order_by
  order_id: order_by
  paid_at: order_by
  status_id: order_by
  transaction_id: order_by
  updated_at: order_by
}

"""primary key columns input for table: payments"""
input payments_pk_columns_input {
  id: uuid!
}

"""
select columns of table "payments"
"""
enum payments_select_column {
  """column name"""
  amount

  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  method_id

  """column name"""
  order_id

  """column name"""
  paid_at

  """column name"""
  status_id

  """column name"""
  transaction_id

  """column name"""
  updated_at
}

"""
input type for updating data in table "payments"
"""
input payments_set_input {
  amount: numeric
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  method_id: uuid
  order_id: uuid
  paid_at: timestamptz
  status_id: uuid
  transaction_id: String
  updated_at: timestamptz
}

"""aggregate stddev on columns"""
type payments_stddev_fields {
  amount: Float
}

"""aggregate stddev_pop on columns"""
type payments_stddev_pop_fields {
  amount: Float
}

"""aggregate stddev_samp on columns"""
type payments_stddev_samp_fields {
  amount: Float
}

"""
Streaming cursor of the table "payments"
"""
input payments_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: payments_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input payments_stream_cursor_value_input {
  amount: numeric
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  method_id: uuid
  order_id: uuid
  paid_at: timestamptz
  status_id: uuid
  transaction_id: String
  updated_at: timestamptz
}

"""aggregate sum on columns"""
type payments_sum_fields {
  amount: numeric
}

"""
update columns of table "payments"
"""
enum payments_update_column {
  """column name"""
  amount

  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  method_id

  """column name"""
  order_id

  """column name"""
  paid_at

  """column name"""
  status_id

  """column name"""
  transaction_id

  """column name"""
  updated_at
}

input payments_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: payments_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: payments_set_input

  """filter the rows which have to be updated"""
  where: payments_bool_exp!
}

"""aggregate var_pop on columns"""
type payments_var_pop_fields {
  amount: Float
}

"""aggregate var_samp on columns"""
type payments_var_samp_fields {
  amount: Float
}

"""aggregate variance on columns"""
type payments_variance_fields {
  amount: Float
}

"""
columns and relationships of "permissions"
"""
type permissions {
  code: String!
  created_at: timestamptz!
  deleted_at: timestamptz
  description: String
  id: uuid!
  name: String!
  updated_at: timestamptz!
}

"""
aggregated selection of "permissions"
"""
type permissions_aggregate {
  aggregate: permissions_aggregate_fields
  nodes: [permissions!]!
}

"""
aggregate fields of "permissions"
"""
type permissions_aggregate_fields {
  count(columns: [permissions_select_column!], distinct: Boolean): Int!
  max: permissions_max_fields
  min: permissions_min_fields
}

"""
Boolean expression to filter rows from the table "permissions". All fields are combined with a logical 'AND'.
"""
input permissions_bool_exp {
  _and: [permissions_bool_exp!]
  _not: permissions_bool_exp
  _or: [permissions_bool_exp!]
  code: String_comparison_exp
  created_at: timestamptz_comparison_exp
  deleted_at: timestamptz_comparison_exp
  description: String_comparison_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "permissions"
"""
enum permissions_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  permissions_pkey
}

"""
input type for inserting data into table "permissions"
"""
input permissions_insert_input {
  code: String
  created_at: timestamptz
  deleted_at: timestamptz
  description: String
  id: uuid
  name: String
  updated_at: timestamptz
}

"""aggregate max on columns"""
type permissions_max_fields {
  code: String
  created_at: timestamptz
  deleted_at: timestamptz
  description: String
  id: uuid
  name: String
  updated_at: timestamptz
}

"""aggregate min on columns"""
type permissions_min_fields {
  code: String
  created_at: timestamptz
  deleted_at: timestamptz
  description: String
  id: uuid
  name: String
  updated_at: timestamptz
}

"""
response of any mutation on the table "permissions"
"""
type permissions_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [permissions!]!
}

"""
on_conflict condition type for table "permissions"
"""
input permissions_on_conflict {
  constraint: permissions_constraint!
  update_columns: [permissions_update_column!]! = []
  where: permissions_bool_exp
}

"""Ordering options when selecting data from "permissions"."""
input permissions_order_by {
  code: order_by
  created_at: order_by
  deleted_at: order_by
  description: order_by
  id: order_by
  name: order_by
  updated_at: order_by
}

"""primary key columns input for table: permissions"""
input permissions_pk_columns_input {
  id: uuid!
}

"""
select columns of table "permissions"
"""
enum permissions_select_column {
  """column name"""
  code

  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  description

  """column name"""
  id

  """column name"""
  name

  """column name"""
  updated_at
}

"""
input type for updating data in table "permissions"
"""
input permissions_set_input {
  code: String
  created_at: timestamptz
  deleted_at: timestamptz
  description: String
  id: uuid
  name: String
  updated_at: timestamptz
}

"""
Streaming cursor of the table "permissions"
"""
input permissions_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: permissions_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input permissions_stream_cursor_value_input {
  code: String
  created_at: timestamptz
  deleted_at: timestamptz
  description: String
  id: uuid
  name: String
  updated_at: timestamptz
}

"""
update columns of table "permissions"
"""
enum permissions_update_column {
  """column name"""
  code

  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  description

  """column name"""
  id

  """column name"""
  name

  """column name"""
  updated_at
}

input permissions_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: permissions_set_input

  """filter the rows which have to be updated"""
  where: permissions_bool_exp!
}

"""
columns and relationships of "post_hashtags"
"""
type post_hashtags {
  created_at: timestamptz!
  deleted_at: timestamptz
  hashtag_id: uuid
  id: uuid!
  post_id: uuid
  updated_at: timestamptz!
}

"""
aggregated selection of "post_hashtags"
"""
type post_hashtags_aggregate {
  aggregate: post_hashtags_aggregate_fields
  nodes: [post_hashtags!]!
}

"""
aggregate fields of "post_hashtags"
"""
type post_hashtags_aggregate_fields {
  count(columns: [post_hashtags_select_column!], distinct: Boolean): Int!
  max: post_hashtags_max_fields
  min: post_hashtags_min_fields
}

"""
Boolean expression to filter rows from the table "post_hashtags". All fields are combined with a logical 'AND'.
"""
input post_hashtags_bool_exp {
  _and: [post_hashtags_bool_exp!]
  _not: post_hashtags_bool_exp
  _or: [post_hashtags_bool_exp!]
  created_at: timestamptz_comparison_exp
  deleted_at: timestamptz_comparison_exp
  hashtag_id: uuid_comparison_exp
  id: uuid_comparison_exp
  post_id: uuid_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "post_hashtags"
"""
enum post_hashtags_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  post_hashtags_pkey
}

"""
input type for inserting data into table "post_hashtags"
"""
input post_hashtags_insert_input {
  created_at: timestamptz
  deleted_at: timestamptz
  hashtag_id: uuid
  id: uuid
  post_id: uuid
  updated_at: timestamptz
}

"""aggregate max on columns"""
type post_hashtags_max_fields {
  created_at: timestamptz
  deleted_at: timestamptz
  hashtag_id: uuid
  id: uuid
  post_id: uuid
  updated_at: timestamptz
}

"""aggregate min on columns"""
type post_hashtags_min_fields {
  created_at: timestamptz
  deleted_at: timestamptz
  hashtag_id: uuid
  id: uuid
  post_id: uuid
  updated_at: timestamptz
}

"""
response of any mutation on the table "post_hashtags"
"""
type post_hashtags_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [post_hashtags!]!
}

"""
on_conflict condition type for table "post_hashtags"
"""
input post_hashtags_on_conflict {
  constraint: post_hashtags_constraint!
  update_columns: [post_hashtags_update_column!]! = []
  where: post_hashtags_bool_exp
}

"""Ordering options when selecting data from "post_hashtags"."""
input post_hashtags_order_by {
  created_at: order_by
  deleted_at: order_by
  hashtag_id: order_by
  id: order_by
  post_id: order_by
  updated_at: order_by
}

"""primary key columns input for table: post_hashtags"""
input post_hashtags_pk_columns_input {
  id: uuid!
}

"""
select columns of table "post_hashtags"
"""
enum post_hashtags_select_column {
  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  hashtag_id

  """column name"""
  id

  """column name"""
  post_id

  """column name"""
  updated_at
}

"""
input type for updating data in table "post_hashtags"
"""
input post_hashtags_set_input {
  created_at: timestamptz
  deleted_at: timestamptz
  hashtag_id: uuid
  id: uuid
  post_id: uuid
  updated_at: timestamptz
}

"""
Streaming cursor of the table "post_hashtags"
"""
input post_hashtags_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: post_hashtags_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input post_hashtags_stream_cursor_value_input {
  created_at: timestamptz
  deleted_at: timestamptz
  hashtag_id: uuid
  id: uuid
  post_id: uuid
  updated_at: timestamptz
}

"""
update columns of table "post_hashtags"
"""
enum post_hashtags_update_column {
  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  hashtag_id

  """column name"""
  id

  """column name"""
  post_id

  """column name"""
  updated_at
}

input post_hashtags_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: post_hashtags_set_input

  """filter the rows which have to be updated"""
  where: post_hashtags_bool_exp!
}

"""
columns and relationships of "post_media"
"""
type post_media {
  alt_text: String
  created_at: timestamptz!
  deleted_at: timestamptz
  id: uuid!
  media_type: String!
  post_id: uuid
  sort_order: Int!
  thumbnail_url: String
  updated_at: timestamptz!
  url: String!
}

"""
aggregated selection of "post_media"
"""
type post_media_aggregate {
  aggregate: post_media_aggregate_fields
  nodes: [post_media!]!
}

"""
aggregate fields of "post_media"
"""
type post_media_aggregate_fields {
  avg: post_media_avg_fields
  count(columns: [post_media_select_column!], distinct: Boolean): Int!
  max: post_media_max_fields
  min: post_media_min_fields
  stddev: post_media_stddev_fields
  stddev_pop: post_media_stddev_pop_fields
  stddev_samp: post_media_stddev_samp_fields
  sum: post_media_sum_fields
  var_pop: post_media_var_pop_fields
  var_samp: post_media_var_samp_fields
  variance: post_media_variance_fields
}

"""aggregate avg on columns"""
type post_media_avg_fields {
  sort_order: Float
}

"""
Boolean expression to filter rows from the table "post_media". All fields are combined with a logical 'AND'.
"""
input post_media_bool_exp {
  _and: [post_media_bool_exp!]
  _not: post_media_bool_exp
  _or: [post_media_bool_exp!]
  alt_text: String_comparison_exp
  created_at: timestamptz_comparison_exp
  deleted_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  media_type: String_comparison_exp
  post_id: uuid_comparison_exp
  sort_order: Int_comparison_exp
  thumbnail_url: String_comparison_exp
  updated_at: timestamptz_comparison_exp
  url: String_comparison_exp
}

"""
unique or primary key constraints on table "post_media"
"""
enum post_media_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  post_media_pkey
}

"""
input type for incrementing numeric columns in table "post_media"
"""
input post_media_inc_input {
  sort_order: Int
}

"""
input type for inserting data into table "post_media"
"""
input post_media_insert_input {
  alt_text: String
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  media_type: String
  post_id: uuid
  sort_order: Int
  thumbnail_url: String
  updated_at: timestamptz
  url: String
}

"""aggregate max on columns"""
type post_media_max_fields {
  alt_text: String
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  media_type: String
  post_id: uuid
  sort_order: Int
  thumbnail_url: String
  updated_at: timestamptz
  url: String
}

"""aggregate min on columns"""
type post_media_min_fields {
  alt_text: String
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  media_type: String
  post_id: uuid
  sort_order: Int
  thumbnail_url: String
  updated_at: timestamptz
  url: String
}

"""
response of any mutation on the table "post_media"
"""
type post_media_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [post_media!]!
}

"""
on_conflict condition type for table "post_media"
"""
input post_media_on_conflict {
  constraint: post_media_constraint!
  update_columns: [post_media_update_column!]! = []
  where: post_media_bool_exp
}

"""Ordering options when selecting data from "post_media"."""
input post_media_order_by {
  alt_text: order_by
  created_at: order_by
  deleted_at: order_by
  id: order_by
  media_type: order_by
  post_id: order_by
  sort_order: order_by
  thumbnail_url: order_by
  updated_at: order_by
  url: order_by
}

"""primary key columns input for table: post_media"""
input post_media_pk_columns_input {
  id: uuid!
}

"""
select columns of table "post_media"
"""
enum post_media_select_column {
  """column name"""
  alt_text

  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  media_type

  """column name"""
  post_id

  """column name"""
  sort_order

  """column name"""
  thumbnail_url

  """column name"""
  updated_at

  """column name"""
  url
}

"""
input type for updating data in table "post_media"
"""
input post_media_set_input {
  alt_text: String
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  media_type: String
  post_id: uuid
  sort_order: Int
  thumbnail_url: String
  updated_at: timestamptz
  url: String
}

"""aggregate stddev on columns"""
type post_media_stddev_fields {
  sort_order: Float
}

"""aggregate stddev_pop on columns"""
type post_media_stddev_pop_fields {
  sort_order: Float
}

"""aggregate stddev_samp on columns"""
type post_media_stddev_samp_fields {
  sort_order: Float
}

"""
Streaming cursor of the table "post_media"
"""
input post_media_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: post_media_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input post_media_stream_cursor_value_input {
  alt_text: String
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  media_type: String
  post_id: uuid
  sort_order: Int
  thumbnail_url: String
  updated_at: timestamptz
  url: String
}

"""aggregate sum on columns"""
type post_media_sum_fields {
  sort_order: Int
}

"""
update columns of table "post_media"
"""
enum post_media_update_column {
  """column name"""
  alt_text

  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  media_type

  """column name"""
  post_id

  """column name"""
  sort_order

  """column name"""
  thumbnail_url

  """column name"""
  updated_at

  """column name"""
  url
}

input post_media_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: post_media_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: post_media_set_input

  """filter the rows which have to be updated"""
  where: post_media_bool_exp!
}

"""aggregate var_pop on columns"""
type post_media_var_pop_fields {
  sort_order: Float
}

"""aggregate var_samp on columns"""
type post_media_var_samp_fields {
  sort_order: Float
}

"""aggregate variance on columns"""
type post_media_variance_fields {
  sort_order: Float
}

"""
columns and relationships of "posts"
"""
type posts {
  author_id: uuid
  content: String!
  created_at: timestamptz!
  deleted_at: timestamptz
  id: uuid!
  is_published: Boolean!
  published_at: timestamptz
  reply_to_id: uuid
  updated_at: timestamptz!
  view_count: bigint!
}

"""
aggregated selection of "posts"
"""
type posts_aggregate {
  aggregate: posts_aggregate_fields
  nodes: [posts!]!
}

"""
aggregate fields of "posts"
"""
type posts_aggregate_fields {
  avg: posts_avg_fields
  count(columns: [posts_select_column!], distinct: Boolean): Int!
  max: posts_max_fields
  min: posts_min_fields
  stddev: posts_stddev_fields
  stddev_pop: posts_stddev_pop_fields
  stddev_samp: posts_stddev_samp_fields
  sum: posts_sum_fields
  var_pop: posts_var_pop_fields
  var_samp: posts_var_samp_fields
  variance: posts_variance_fields
}

"""aggregate avg on columns"""
type posts_avg_fields {
  view_count: Float
}

"""
Boolean expression to filter rows from the table "posts". All fields are combined with a logical 'AND'.
"""
input posts_bool_exp {
  _and: [posts_bool_exp!]
  _not: posts_bool_exp
  _or: [posts_bool_exp!]
  author_id: uuid_comparison_exp
  content: String_comparison_exp
  created_at: timestamptz_comparison_exp
  deleted_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  is_published: Boolean_comparison_exp
  published_at: timestamptz_comparison_exp
  reply_to_id: uuid_comparison_exp
  updated_at: timestamptz_comparison_exp
  view_count: bigint_comparison_exp
}

"""
unique or primary key constraints on table "posts"
"""
enum posts_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  posts_pkey
}

"""
input type for incrementing numeric columns in table "posts"
"""
input posts_inc_input {
  view_count: bigint
}

"""
input type for inserting data into table "posts"
"""
input posts_insert_input {
  author_id: uuid
  content: String
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  is_published: Boolean
  published_at: timestamptz
  reply_to_id: uuid
  updated_at: timestamptz
  view_count: bigint
}

"""aggregate max on columns"""
type posts_max_fields {
  author_id: uuid
  content: String
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  published_at: timestamptz
  reply_to_id: uuid
  updated_at: timestamptz
  view_count: bigint
}

"""aggregate min on columns"""
type posts_min_fields {
  author_id: uuid
  content: String
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  published_at: timestamptz
  reply_to_id: uuid
  updated_at: timestamptz
  view_count: bigint
}

"""
response of any mutation on the table "posts"
"""
type posts_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [posts!]!
}

"""
on_conflict condition type for table "posts"
"""
input posts_on_conflict {
  constraint: posts_constraint!
  update_columns: [posts_update_column!]! = []
  where: posts_bool_exp
}

"""Ordering options when selecting data from "posts"."""
input posts_order_by {
  author_id: order_by
  content: order_by
  created_at: order_by
  deleted_at: order_by
  id: order_by
  is_published: order_by
  published_at: order_by
  reply_to_id: order_by
  updated_at: order_by
  view_count: order_by
}

"""primary key columns input for table: posts"""
input posts_pk_columns_input {
  id: uuid!
}

"""
select columns of table "posts"
"""
enum posts_select_column {
  """column name"""
  author_id

  """column name"""
  content

  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  is_published

  """column name"""
  published_at

  """column name"""
  reply_to_id

  """column name"""
  updated_at

  """column name"""
  view_count
}

"""
input type for updating data in table "posts"
"""
input posts_set_input {
  author_id: uuid
  content: String
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  is_published: Boolean
  published_at: timestamptz
  reply_to_id: uuid
  updated_at: timestamptz
  view_count: bigint
}

"""aggregate stddev on columns"""
type posts_stddev_fields {
  view_count: Float
}

"""aggregate stddev_pop on columns"""
type posts_stddev_pop_fields {
  view_count: Float
}

"""aggregate stddev_samp on columns"""
type posts_stddev_samp_fields {
  view_count: Float
}

"""
Streaming cursor of the table "posts"
"""
input posts_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: posts_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input posts_stream_cursor_value_input {
  author_id: uuid
  content: String
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  is_published: Boolean
  published_at: timestamptz
  reply_to_id: uuid
  updated_at: timestamptz
  view_count: bigint
}

"""aggregate sum on columns"""
type posts_sum_fields {
  view_count: bigint
}

"""
update columns of table "posts"
"""
enum posts_update_column {
  """column name"""
  author_id

  """column name"""
  content

  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  is_published

  """column name"""
  published_at

  """column name"""
  reply_to_id

  """column name"""
  updated_at

  """column name"""
  view_count
}

input posts_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: posts_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: posts_set_input

  """filter the rows which have to be updated"""
  where: posts_bool_exp!
}

"""aggregate var_pop on columns"""
type posts_var_pop_fields {
  view_count: Float
}

"""aggregate var_samp on columns"""
type posts_var_samp_fields {
  view_count: Float
}

"""aggregate variance on columns"""
type posts_variance_fields {
  view_count: Float
}

"""
columns and relationships of "product_categories"
"""
type product_categories {
  category_id: uuid
  created_at: timestamptz!
  deleted_at: timestamptz
  id: uuid!
  product_id: uuid
  updated_at: timestamptz!
}

"""
aggregated selection of "product_categories"
"""
type product_categories_aggregate {
  aggregate: product_categories_aggregate_fields
  nodes: [product_categories!]!
}

"""
aggregate fields of "product_categories"
"""
type product_categories_aggregate_fields {
  count(columns: [product_categories_select_column!], distinct: Boolean): Int!
  max: product_categories_max_fields
  min: product_categories_min_fields
}

"""
Boolean expression to filter rows from the table "product_categories". All fields are combined with a logical 'AND'.
"""
input product_categories_bool_exp {
  _and: [product_categories_bool_exp!]
  _not: product_categories_bool_exp
  _or: [product_categories_bool_exp!]
  category_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  deleted_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  product_id: uuid_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "product_categories"
"""
enum product_categories_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  product_categories_pkey
}

"""
input type for inserting data into table "product_categories"
"""
input product_categories_insert_input {
  category_id: uuid
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  product_id: uuid
  updated_at: timestamptz
}

"""aggregate max on columns"""
type product_categories_max_fields {
  category_id: uuid
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  product_id: uuid
  updated_at: timestamptz
}

"""aggregate min on columns"""
type product_categories_min_fields {
  category_id: uuid
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  product_id: uuid
  updated_at: timestamptz
}

"""
response of any mutation on the table "product_categories"
"""
type product_categories_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [product_categories!]!
}

"""
on_conflict condition type for table "product_categories"
"""
input product_categories_on_conflict {
  constraint: product_categories_constraint!
  update_columns: [product_categories_update_column!]! = []
  where: product_categories_bool_exp
}

"""Ordering options when selecting data from "product_categories"."""
input product_categories_order_by {
  category_id: order_by
  created_at: order_by
  deleted_at: order_by
  id: order_by
  product_id: order_by
  updated_at: order_by
}

"""primary key columns input for table: product_categories"""
input product_categories_pk_columns_input {
  id: uuid!
}

"""
select columns of table "product_categories"
"""
enum product_categories_select_column {
  """column name"""
  category_id

  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  product_id

  """column name"""
  updated_at
}

"""
input type for updating data in table "product_categories"
"""
input product_categories_set_input {
  category_id: uuid
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  product_id: uuid
  updated_at: timestamptz
}

"""
Streaming cursor of the table "product_categories"
"""
input product_categories_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: product_categories_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input product_categories_stream_cursor_value_input {
  category_id: uuid
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  product_id: uuid
  updated_at: timestamptz
}

"""
update columns of table "product_categories"
"""
enum product_categories_update_column {
  """column name"""
  category_id

  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  product_id

  """column name"""
  updated_at
}

input product_categories_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: product_categories_set_input

  """filter the rows which have to be updated"""
  where: product_categories_bool_exp!
}

"""
columns and relationships of "product_collections"
"""
type product_collections {
  collection_id: uuid
  created_at: timestamptz!
  deleted_at: timestamptz
  id: uuid!
  product_id: uuid
  sort_order: Int!
  updated_at: timestamptz!
}

"""
aggregated selection of "product_collections"
"""
type product_collections_aggregate {
  aggregate: product_collections_aggregate_fields
  nodes: [product_collections!]!
}

"""
aggregate fields of "product_collections"
"""
type product_collections_aggregate_fields {
  avg: product_collections_avg_fields
  count(columns: [product_collections_select_column!], distinct: Boolean): Int!
  max: product_collections_max_fields
  min: product_collections_min_fields
  stddev: product_collections_stddev_fields
  stddev_pop: product_collections_stddev_pop_fields
  stddev_samp: product_collections_stddev_samp_fields
  sum: product_collections_sum_fields
  var_pop: product_collections_var_pop_fields
  var_samp: product_collections_var_samp_fields
  variance: product_collections_variance_fields
}

"""aggregate avg on columns"""
type product_collections_avg_fields {
  sort_order: Float
}

"""
Boolean expression to filter rows from the table "product_collections". All fields are combined with a logical 'AND'.
"""
input product_collections_bool_exp {
  _and: [product_collections_bool_exp!]
  _not: product_collections_bool_exp
  _or: [product_collections_bool_exp!]
  collection_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  deleted_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  product_id: uuid_comparison_exp
  sort_order: Int_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "product_collections"
"""
enum product_collections_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  product_collections_pkey
}

"""
input type for incrementing numeric columns in table "product_collections"
"""
input product_collections_inc_input {
  sort_order: Int
}

"""
input type for inserting data into table "product_collections"
"""
input product_collections_insert_input {
  collection_id: uuid
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  product_id: uuid
  sort_order: Int
  updated_at: timestamptz
}

"""aggregate max on columns"""
type product_collections_max_fields {
  collection_id: uuid
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  product_id: uuid
  sort_order: Int
  updated_at: timestamptz
}

"""aggregate min on columns"""
type product_collections_min_fields {
  collection_id: uuid
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  product_id: uuid
  sort_order: Int
  updated_at: timestamptz
}

"""
response of any mutation on the table "product_collections"
"""
type product_collections_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [product_collections!]!
}

"""
on_conflict condition type for table "product_collections"
"""
input product_collections_on_conflict {
  constraint: product_collections_constraint!
  update_columns: [product_collections_update_column!]! = []
  where: product_collections_bool_exp
}

"""Ordering options when selecting data from "product_collections"."""
input product_collections_order_by {
  collection_id: order_by
  created_at: order_by
  deleted_at: order_by
  id: order_by
  product_id: order_by
  sort_order: order_by
  updated_at: order_by
}

"""primary key columns input for table: product_collections"""
input product_collections_pk_columns_input {
  id: uuid!
}

"""
select columns of table "product_collections"
"""
enum product_collections_select_column {
  """column name"""
  collection_id

  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  product_id

  """column name"""
  sort_order

  """column name"""
  updated_at
}

"""
input type for updating data in table "product_collections"
"""
input product_collections_set_input {
  collection_id: uuid
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  product_id: uuid
  sort_order: Int
  updated_at: timestamptz
}

"""aggregate stddev on columns"""
type product_collections_stddev_fields {
  sort_order: Float
}

"""aggregate stddev_pop on columns"""
type product_collections_stddev_pop_fields {
  sort_order: Float
}

"""aggregate stddev_samp on columns"""
type product_collections_stddev_samp_fields {
  sort_order: Float
}

"""
Streaming cursor of the table "product_collections"
"""
input product_collections_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: product_collections_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input product_collections_stream_cursor_value_input {
  collection_id: uuid
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  product_id: uuid
  sort_order: Int
  updated_at: timestamptz
}

"""aggregate sum on columns"""
type product_collections_sum_fields {
  sort_order: Int
}

"""
update columns of table "product_collections"
"""
enum product_collections_update_column {
  """column name"""
  collection_id

  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  product_id

  """column name"""
  sort_order

  """column name"""
  updated_at
}

input product_collections_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: product_collections_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: product_collections_set_input

  """filter the rows which have to be updated"""
  where: product_collections_bool_exp!
}

"""aggregate var_pop on columns"""
type product_collections_var_pop_fields {
  sort_order: Float
}

"""aggregate var_samp on columns"""
type product_collections_var_samp_fields {
  sort_order: Float
}

"""aggregate variance on columns"""
type product_collections_variance_fields {
  sort_order: Float
}

"""
columns and relationships of "product_images"
"""
type product_images {
  alt_text: String
  created_at: timestamptz!
  deleted_at: timestamptz
  id: uuid!
  is_primary: Boolean!
  product_id: uuid
  sort_order: Int!
  updated_at: timestamptz!
  url: String!
  variant_id: uuid
}

"""
aggregated selection of "product_images"
"""
type product_images_aggregate {
  aggregate: product_images_aggregate_fields
  nodes: [product_images!]!
}

"""
aggregate fields of "product_images"
"""
type product_images_aggregate_fields {
  avg: product_images_avg_fields
  count(columns: [product_images_select_column!], distinct: Boolean): Int!
  max: product_images_max_fields
  min: product_images_min_fields
  stddev: product_images_stddev_fields
  stddev_pop: product_images_stddev_pop_fields
  stddev_samp: product_images_stddev_samp_fields
  sum: product_images_sum_fields
  var_pop: product_images_var_pop_fields
  var_samp: product_images_var_samp_fields
  variance: product_images_variance_fields
}

"""aggregate avg on columns"""
type product_images_avg_fields {
  sort_order: Float
}

"""
Boolean expression to filter rows from the table "product_images". All fields are combined with a logical 'AND'.
"""
input product_images_bool_exp {
  _and: [product_images_bool_exp!]
  _not: product_images_bool_exp
  _or: [product_images_bool_exp!]
  alt_text: String_comparison_exp
  created_at: timestamptz_comparison_exp
  deleted_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  is_primary: Boolean_comparison_exp
  product_id: uuid_comparison_exp
  sort_order: Int_comparison_exp
  updated_at: timestamptz_comparison_exp
  url: String_comparison_exp
  variant_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "product_images"
"""
enum product_images_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  product_images_pkey
}

"""
input type for incrementing numeric columns in table "product_images"
"""
input product_images_inc_input {
  sort_order: Int
}

"""
input type for inserting data into table "product_images"
"""
input product_images_insert_input {
  alt_text: String
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  is_primary: Boolean
  product_id: uuid
  sort_order: Int
  updated_at: timestamptz
  url: String
  variant_id: uuid
}

"""aggregate max on columns"""
type product_images_max_fields {
  alt_text: String
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  product_id: uuid
  sort_order: Int
  updated_at: timestamptz
  url: String
  variant_id: uuid
}

"""aggregate min on columns"""
type product_images_min_fields {
  alt_text: String
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  product_id: uuid
  sort_order: Int
  updated_at: timestamptz
  url: String
  variant_id: uuid
}

"""
response of any mutation on the table "product_images"
"""
type product_images_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [product_images!]!
}

"""
on_conflict condition type for table "product_images"
"""
input product_images_on_conflict {
  constraint: product_images_constraint!
  update_columns: [product_images_update_column!]! = []
  where: product_images_bool_exp
}

"""Ordering options when selecting data from "product_images"."""
input product_images_order_by {
  alt_text: order_by
  created_at: order_by
  deleted_at: order_by
  id: order_by
  is_primary: order_by
  product_id: order_by
  sort_order: order_by
  updated_at: order_by
  url: order_by
  variant_id: order_by
}

"""primary key columns input for table: product_images"""
input product_images_pk_columns_input {
  id: uuid!
}

"""
select columns of table "product_images"
"""
enum product_images_select_column {
  """column name"""
  alt_text

  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  is_primary

  """column name"""
  product_id

  """column name"""
  sort_order

  """column name"""
  updated_at

  """column name"""
  url

  """column name"""
  variant_id
}

"""
input type for updating data in table "product_images"
"""
input product_images_set_input {
  alt_text: String
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  is_primary: Boolean
  product_id: uuid
  sort_order: Int
  updated_at: timestamptz
  url: String
  variant_id: uuid
}

"""aggregate stddev on columns"""
type product_images_stddev_fields {
  sort_order: Float
}

"""aggregate stddev_pop on columns"""
type product_images_stddev_pop_fields {
  sort_order: Float
}

"""aggregate stddev_samp on columns"""
type product_images_stddev_samp_fields {
  sort_order: Float
}

"""
Streaming cursor of the table "product_images"
"""
input product_images_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: product_images_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input product_images_stream_cursor_value_input {
  alt_text: String
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  is_primary: Boolean
  product_id: uuid
  sort_order: Int
  updated_at: timestamptz
  url: String
  variant_id: uuid
}

"""aggregate sum on columns"""
type product_images_sum_fields {
  sort_order: Int
}

"""
update columns of table "product_images"
"""
enum product_images_update_column {
  """column name"""
  alt_text

  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  is_primary

  """column name"""
  product_id

  """column name"""
  sort_order

  """column name"""
  updated_at

  """column name"""
  url

  """column name"""
  variant_id
}

input product_images_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: product_images_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: product_images_set_input

  """filter the rows which have to be updated"""
  where: product_images_bool_exp!
}

"""aggregate var_pop on columns"""
type product_images_var_pop_fields {
  sort_order: Float
}

"""aggregate var_samp on columns"""
type product_images_var_samp_fields {
  sort_order: Float
}

"""aggregate variance on columns"""
type product_images_variance_fields {
  sort_order: Float
}

"""
columns and relationships of "product_variants"
"""
type product_variants {
  color_id: uuid
  created_at: timestamptz!
  deleted_at: timestamptz
  id: uuid!
  price: numeric!
  product_id: uuid
  size_id: uuid
  sku: String!
  stock_quantity: Int!
  updated_at: timestamptz!
}

"""
aggregated selection of "product_variants"
"""
type product_variants_aggregate {
  aggregate: product_variants_aggregate_fields
  nodes: [product_variants!]!
}

"""
aggregate fields of "product_variants"
"""
type product_variants_aggregate_fields {
  avg: product_variants_avg_fields
  count(columns: [product_variants_select_column!], distinct: Boolean): Int!
  max: product_variants_max_fields
  min: product_variants_min_fields
  stddev: product_variants_stddev_fields
  stddev_pop: product_variants_stddev_pop_fields
  stddev_samp: product_variants_stddev_samp_fields
  sum: product_variants_sum_fields
  var_pop: product_variants_var_pop_fields
  var_samp: product_variants_var_samp_fields
  variance: product_variants_variance_fields
}

"""aggregate avg on columns"""
type product_variants_avg_fields {
  price: Float
  stock_quantity: Float
}

"""
Boolean expression to filter rows from the table "product_variants". All fields are combined with a logical 'AND'.
"""
input product_variants_bool_exp {
  _and: [product_variants_bool_exp!]
  _not: product_variants_bool_exp
  _or: [product_variants_bool_exp!]
  color_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  deleted_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  price: numeric_comparison_exp
  product_id: uuid_comparison_exp
  size_id: uuid_comparison_exp
  sku: String_comparison_exp
  stock_quantity: Int_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "product_variants"
"""
enum product_variants_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  product_variants_pkey
}

"""
input type for incrementing numeric columns in table "product_variants"
"""
input product_variants_inc_input {
  price: numeric
  stock_quantity: Int
}

"""
input type for inserting data into table "product_variants"
"""
input product_variants_insert_input {
  color_id: uuid
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  price: numeric
  product_id: uuid
  size_id: uuid
  sku: String
  stock_quantity: Int
  updated_at: timestamptz
}

"""aggregate max on columns"""
type product_variants_max_fields {
  color_id: uuid
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  price: numeric
  product_id: uuid
  size_id: uuid
  sku: String
  stock_quantity: Int
  updated_at: timestamptz
}

"""aggregate min on columns"""
type product_variants_min_fields {
  color_id: uuid
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  price: numeric
  product_id: uuid
  size_id: uuid
  sku: String
  stock_quantity: Int
  updated_at: timestamptz
}

"""
response of any mutation on the table "product_variants"
"""
type product_variants_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [product_variants!]!
}

"""
on_conflict condition type for table "product_variants"
"""
input product_variants_on_conflict {
  constraint: product_variants_constraint!
  update_columns: [product_variants_update_column!]! = []
  where: product_variants_bool_exp
}

"""Ordering options when selecting data from "product_variants"."""
input product_variants_order_by {
  color_id: order_by
  created_at: order_by
  deleted_at: order_by
  id: order_by
  price: order_by
  product_id: order_by
  size_id: order_by
  sku: order_by
  stock_quantity: order_by
  updated_at: order_by
}

"""primary key columns input for table: product_variants"""
input product_variants_pk_columns_input {
  id: uuid!
}

"""
select columns of table "product_variants"
"""
enum product_variants_select_column {
  """column name"""
  color_id

  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  price

  """column name"""
  product_id

  """column name"""
  size_id

  """column name"""
  sku

  """column name"""
  stock_quantity

  """column name"""
  updated_at
}

"""
input type for updating data in table "product_variants"
"""
input product_variants_set_input {
  color_id: uuid
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  price: numeric
  product_id: uuid
  size_id: uuid
  sku: String
  stock_quantity: Int
  updated_at: timestamptz
}

"""aggregate stddev on columns"""
type product_variants_stddev_fields {
  price: Float
  stock_quantity: Float
}

"""aggregate stddev_pop on columns"""
type product_variants_stddev_pop_fields {
  price: Float
  stock_quantity: Float
}

"""aggregate stddev_samp on columns"""
type product_variants_stddev_samp_fields {
  price: Float
  stock_quantity: Float
}

"""
Streaming cursor of the table "product_variants"
"""
input product_variants_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: product_variants_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input product_variants_stream_cursor_value_input {
  color_id: uuid
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  price: numeric
  product_id: uuid
  size_id: uuid
  sku: String
  stock_quantity: Int
  updated_at: timestamptz
}

"""aggregate sum on columns"""
type product_variants_sum_fields {
  price: numeric
  stock_quantity: Int
}

"""
update columns of table "product_variants"
"""
enum product_variants_update_column {
  """column name"""
  color_id

  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  price

  """column name"""
  product_id

  """column name"""
  size_id

  """column name"""
  sku

  """column name"""
  stock_quantity

  """column name"""
  updated_at
}

input product_variants_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: product_variants_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: product_variants_set_input

  """filter the rows which have to be updated"""
  where: product_variants_bool_exp!
}

"""aggregate var_pop on columns"""
type product_variants_var_pop_fields {
  price: Float
  stock_quantity: Float
}

"""aggregate var_samp on columns"""
type product_variants_var_samp_fields {
  price: Float
  stock_quantity: Float
}

"""aggregate variance on columns"""
type product_variants_variance_fields {
  price: Float
  stock_quantity: Float
}

"""
columns and relationships of "products"
"""
type products {
  base_price: numeric!
  brand_id: uuid
  created_at: timestamptz!
  deleted_at: timestamptz
  description: String
  id: uuid!
  is_published: Boolean!
  name: String!
  slug: String!
  store_id: uuid
  updated_at: timestamptz!
}

"""
aggregated selection of "products"
"""
type products_aggregate {
  aggregate: products_aggregate_fields
  nodes: [products!]!
}

"""
aggregate fields of "products"
"""
type products_aggregate_fields {
  avg: products_avg_fields
  count(columns: [products_select_column!], distinct: Boolean): Int!
  max: products_max_fields
  min: products_min_fields
  stddev: products_stddev_fields
  stddev_pop: products_stddev_pop_fields
  stddev_samp: products_stddev_samp_fields
  sum: products_sum_fields
  var_pop: products_var_pop_fields
  var_samp: products_var_samp_fields
  variance: products_variance_fields
}

"""aggregate avg on columns"""
type products_avg_fields {
  base_price: Float
}

"""
Boolean expression to filter rows from the table "products". All fields are combined with a logical 'AND'.
"""
input products_bool_exp {
  _and: [products_bool_exp!]
  _not: products_bool_exp
  _or: [products_bool_exp!]
  base_price: numeric_comparison_exp
  brand_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  deleted_at: timestamptz_comparison_exp
  description: String_comparison_exp
  id: uuid_comparison_exp
  is_published: Boolean_comparison_exp
  name: String_comparison_exp
  slug: String_comparison_exp
  store_id: uuid_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "products"
"""
enum products_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  products_pkey
}

"""
input type for incrementing numeric columns in table "products"
"""
input products_inc_input {
  base_price: numeric
}

"""
input type for inserting data into table "products"
"""
input products_insert_input {
  base_price: numeric
  brand_id: uuid
  created_at: timestamptz
  deleted_at: timestamptz
  description: String
  id: uuid
  is_published: Boolean
  name: String
  slug: String
  store_id: uuid
  updated_at: timestamptz
}

"""aggregate max on columns"""
type products_max_fields {
  base_price: numeric
  brand_id: uuid
  created_at: timestamptz
  deleted_at: timestamptz
  description: String
  id: uuid
  name: String
  slug: String
  store_id: uuid
  updated_at: timestamptz
}

"""aggregate min on columns"""
type products_min_fields {
  base_price: numeric
  brand_id: uuid
  created_at: timestamptz
  deleted_at: timestamptz
  description: String
  id: uuid
  name: String
  slug: String
  store_id: uuid
  updated_at: timestamptz
}

"""
response of any mutation on the table "products"
"""
type products_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [products!]!
}

"""
on_conflict condition type for table "products"
"""
input products_on_conflict {
  constraint: products_constraint!
  update_columns: [products_update_column!]! = []
  where: products_bool_exp
}

"""Ordering options when selecting data from "products"."""
input products_order_by {
  base_price: order_by
  brand_id: order_by
  created_at: order_by
  deleted_at: order_by
  description: order_by
  id: order_by
  is_published: order_by
  name: order_by
  slug: order_by
  store_id: order_by
  updated_at: order_by
}

"""primary key columns input for table: products"""
input products_pk_columns_input {
  id: uuid!
}

"""
select columns of table "products"
"""
enum products_select_column {
  """column name"""
  base_price

  """column name"""
  brand_id

  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  description

  """column name"""
  id

  """column name"""
  is_published

  """column name"""
  name

  """column name"""
  slug

  """column name"""
  store_id

  """column name"""
  updated_at
}

"""
input type for updating data in table "products"
"""
input products_set_input {
  base_price: numeric
  brand_id: uuid
  created_at: timestamptz
  deleted_at: timestamptz
  description: String
  id: uuid
  is_published: Boolean
  name: String
  slug: String
  store_id: uuid
  updated_at: timestamptz
}

"""aggregate stddev on columns"""
type products_stddev_fields {
  base_price: Float
}

"""aggregate stddev_pop on columns"""
type products_stddev_pop_fields {
  base_price: Float
}

"""aggregate stddev_samp on columns"""
type products_stddev_samp_fields {
  base_price: Float
}

"""
Streaming cursor of the table "products"
"""
input products_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: products_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input products_stream_cursor_value_input {
  base_price: numeric
  brand_id: uuid
  created_at: timestamptz
  deleted_at: timestamptz
  description: String
  id: uuid
  is_published: Boolean
  name: String
  slug: String
  store_id: uuid
  updated_at: timestamptz
}

"""aggregate sum on columns"""
type products_sum_fields {
  base_price: numeric
}

"""
update columns of table "products"
"""
enum products_update_column {
  """column name"""
  base_price

  """column name"""
  brand_id

  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  description

  """column name"""
  id

  """column name"""
  is_published

  """column name"""
  name

  """column name"""
  slug

  """column name"""
  store_id

  """column name"""
  updated_at
}

input products_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: products_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: products_set_input

  """filter the rows which have to be updated"""
  where: products_bool_exp!
}

"""aggregate var_pop on columns"""
type products_var_pop_fields {
  base_price: Float
}

"""aggregate var_samp on columns"""
type products_var_samp_fields {
  base_price: Float
}

"""aggregate variance on columns"""
type products_variance_fields {
  base_price: Float
}

type query_root {
  """
  fetch data from the table: "analytics_events"
  """
  analytics_events(
    """distinct select on columns"""
    distinct_on: [analytics_events_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [analytics_events_order_by!]

    """filter the rows returned"""
    where: analytics_events_bool_exp
  ): [analytics_events!]!

  """
  fetch aggregated fields from the table: "analytics_events"
  """
  analytics_events_aggregate(
    """distinct select on columns"""
    distinct_on: [analytics_events_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [analytics_events_order_by!]

    """filter the rows returned"""
    where: analytics_events_bool_exp
  ): analytics_events_aggregate!

  """
  fetch data from the table: "analytics_events" using primary key columns
  """
  analytics_events_by_pk(id: uuid!): analytics_events

  """
  fetch data from the table: "article_categories"
  """
  article_categories(
    """distinct select on columns"""
    distinct_on: [article_categories_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [article_categories_order_by!]

    """filter the rows returned"""
    where: article_categories_bool_exp
  ): [article_categories!]!

  """
  fetch aggregated fields from the table: "article_categories"
  """
  article_categories_aggregate(
    """distinct select on columns"""
    distinct_on: [article_categories_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [article_categories_order_by!]

    """filter the rows returned"""
    where: article_categories_bool_exp
  ): article_categories_aggregate!

  """
  fetch data from the table: "article_categories" using primary key columns
  """
  article_categories_by_pk(id: uuid!): article_categories

  """
  fetch data from the table: "article_category_assignments"
  """
  article_category_assignments(
    """distinct select on columns"""
    distinct_on: [article_category_assignments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [article_category_assignments_order_by!]

    """filter the rows returned"""
    where: article_category_assignments_bool_exp
  ): [article_category_assignments!]!

  """
  fetch aggregated fields from the table: "article_category_assignments"
  """
  article_category_assignments_aggregate(
    """distinct select on columns"""
    distinct_on: [article_category_assignments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [article_category_assignments_order_by!]

    """filter the rows returned"""
    where: article_category_assignments_bool_exp
  ): article_category_assignments_aggregate!

  """
  fetch data from the table: "article_category_assignments" using primary key columns
  """
  article_category_assignments_by_pk(id: uuid!): article_category_assignments

  """
  fetch data from the table: "article_tags"
  """
  article_tags(
    """distinct select on columns"""
    distinct_on: [article_tags_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [article_tags_order_by!]

    """filter the rows returned"""
    where: article_tags_bool_exp
  ): [article_tags!]!

  """
  fetch aggregated fields from the table: "article_tags"
  """
  article_tags_aggregate(
    """distinct select on columns"""
    distinct_on: [article_tags_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [article_tags_order_by!]

    """filter the rows returned"""
    where: article_tags_bool_exp
  ): article_tags_aggregate!

  """fetch data from the table: "article_tags" using primary key columns"""
  article_tags_by_pk(id: uuid!): article_tags

  """
  fetch data from the table: "articles"
  """
  articles(
    """distinct select on columns"""
    distinct_on: [articles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [articles_order_by!]

    """filter the rows returned"""
    where: articles_bool_exp
  ): [articles!]!

  """
  fetch aggregated fields from the table: "articles"
  """
  articles_aggregate(
    """distinct select on columns"""
    distinct_on: [articles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [articles_order_by!]

    """filter the rows returned"""
    where: articles_bool_exp
  ): articles_aggregate!

  """fetch data from the table: "articles" using primary key columns"""
  articles_by_pk(id: uuid!): articles

  """
  fetch data from the table: "author_articles"
  """
  author_articles(
    """distinct select on columns"""
    distinct_on: [author_articles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [author_articles_order_by!]

    """filter the rows returned"""
    where: author_articles_bool_exp
  ): [author_articles!]!

  """
  fetch aggregated fields from the table: "author_articles"
  """
  author_articles_aggregate(
    """distinct select on columns"""
    distinct_on: [author_articles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [author_articles_order_by!]

    """filter the rows returned"""
    where: author_articles_bool_exp
  ): author_articles_aggregate!

  """fetch data from the table: "author_articles" using primary key columns"""
  author_articles_by_pk(id: uuid!): author_articles

  """
  fetch data from the table: "authors"
  """
  authors(
    """distinct select on columns"""
    distinct_on: [authors_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authors_order_by!]

    """filter the rows returned"""
    where: authors_bool_exp
  ): [authors!]!

  """
  fetch aggregated fields from the table: "authors"
  """
  authors_aggregate(
    """distinct select on columns"""
    distinct_on: [authors_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authors_order_by!]

    """filter the rows returned"""
    where: authors_bool_exp
  ): authors_aggregate!

  """fetch data from the table: "authors" using primary key columns"""
  authors_by_pk(id: uuid!): authors

  """
  fetch data from the table: "blocks"
  """
  blocks(
    """distinct select on columns"""
    distinct_on: [blocks_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [blocks_order_by!]

    """filter the rows returned"""
    where: blocks_bool_exp
  ): [blocks!]!

  """
  fetch aggregated fields from the table: "blocks"
  """
  blocks_aggregate(
    """distinct select on columns"""
    distinct_on: [blocks_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [blocks_order_by!]

    """filter the rows returned"""
    where: blocks_bool_exp
  ): blocks_aggregate!

  """fetch data from the table: "blocks" using primary key columns"""
  blocks_by_pk(id: uuid!): blocks

  """
  fetch data from the table: "bookmarks"
  """
  bookmarks(
    """distinct select on columns"""
    distinct_on: [bookmarks_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [bookmarks_order_by!]

    """filter the rows returned"""
    where: bookmarks_bool_exp
  ): [bookmarks!]!

  """
  fetch aggregated fields from the table: "bookmarks"
  """
  bookmarks_aggregate(
    """distinct select on columns"""
    distinct_on: [bookmarks_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [bookmarks_order_by!]

    """filter the rows returned"""
    where: bookmarks_bool_exp
  ): bookmarks_aggregate!

  """fetch data from the table: "bookmarks" using primary key columns"""
  bookmarks_by_pk(id: uuid!): bookmarks

  """
  fetch data from the table: "brands"
  """
  brands(
    """distinct select on columns"""
    distinct_on: [brands_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [brands_order_by!]

    """filter the rows returned"""
    where: brands_bool_exp
  ): [brands!]!

  """
  fetch aggregated fields from the table: "brands"
  """
  brands_aggregate(
    """distinct select on columns"""
    distinct_on: [brands_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [brands_order_by!]

    """filter the rows returned"""
    where: brands_bool_exp
  ): brands_aggregate!

  """fetch data from the table: "brands" using primary key columns"""
  brands_by_pk(id: uuid!): brands

  """
  fetch data from the table: "cart_items"
  """
  cart_items(
    """distinct select on columns"""
    distinct_on: [cart_items_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [cart_items_order_by!]

    """filter the rows returned"""
    where: cart_items_bool_exp
  ): [cart_items!]!

  """
  fetch aggregated fields from the table: "cart_items"
  """
  cart_items_aggregate(
    """distinct select on columns"""
    distinct_on: [cart_items_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [cart_items_order_by!]

    """filter the rows returned"""
    where: cart_items_bool_exp
  ): cart_items_aggregate!

  """fetch data from the table: "cart_items" using primary key columns"""
  cart_items_by_pk(id: uuid!): cart_items

  """
  fetch data from the table: "carts"
  """
  carts(
    """distinct select on columns"""
    distinct_on: [carts_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [carts_order_by!]

    """filter the rows returned"""
    where: carts_bool_exp
  ): [carts!]!

  """
  fetch aggregated fields from the table: "carts"
  """
  carts_aggregate(
    """distinct select on columns"""
    distinct_on: [carts_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [carts_order_by!]

    """filter the rows returned"""
    where: carts_bool_exp
  ): carts_aggregate!

  """fetch data from the table: "carts" using primary key columns"""
  carts_by_pk(id: uuid!): carts

  """
  fetch data from the table: "cities"
  """
  cities(
    """distinct select on columns"""
    distinct_on: [cities_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [cities_order_by!]

    """filter the rows returned"""
    where: cities_bool_exp
  ): [cities!]!

  """
  fetch aggregated fields from the table: "cities"
  """
  cities_aggregate(
    """distinct select on columns"""
    distinct_on: [cities_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [cities_order_by!]

    """filter the rows returned"""
    where: cities_bool_exp
  ): cities_aggregate!

  """fetch data from the table: "cities" using primary key columns"""
  cities_by_pk(id: uuid!): cities

  """
  fetch data from the table: "collections"
  """
  collections(
    """distinct select on columns"""
    distinct_on: [collections_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [collections_order_by!]

    """filter the rows returned"""
    where: collections_bool_exp
  ): [collections!]!

  """
  fetch aggregated fields from the table: "collections"
  """
  collections_aggregate(
    """distinct select on columns"""
    distinct_on: [collections_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [collections_order_by!]

    """filter the rows returned"""
    where: collections_bool_exp
  ): collections_aggregate!

  """fetch data from the table: "collections" using primary key columns"""
  collections_by_pk(id: uuid!): collections

  """
  fetch data from the table: "colors"
  """
  colors(
    """distinct select on columns"""
    distinct_on: [colors_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [colors_order_by!]

    """filter the rows returned"""
    where: colors_bool_exp
  ): [colors!]!

  """
  fetch aggregated fields from the table: "colors"
  """
  colors_aggregate(
    """distinct select on columns"""
    distinct_on: [colors_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [colors_order_by!]

    """filter the rows returned"""
    where: colors_bool_exp
  ): colors_aggregate!

  """fetch data from the table: "colors" using primary key columns"""
  colors_by_pk(id: uuid!): colors

  """
  fetch data from the table: "comments"
  """
  comments(
    """distinct select on columns"""
    distinct_on: [comments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [comments_order_by!]

    """filter the rows returned"""
    where: comments_bool_exp
  ): [comments!]!

  """
  fetch aggregated fields from the table: "comments"
  """
  comments_aggregate(
    """distinct select on columns"""
    distinct_on: [comments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [comments_order_by!]

    """filter the rows returned"""
    where: comments_bool_exp
  ): comments_aggregate!

  """fetch data from the table: "comments" using primary key columns"""
  comments_by_pk(id: uuid!): comments

  """
  fetch data from the table: "conversation_participants"
  """
  conversation_participants(
    """distinct select on columns"""
    distinct_on: [conversation_participants_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [conversation_participants_order_by!]

    """filter the rows returned"""
    where: conversation_participants_bool_exp
  ): [conversation_participants!]!

  """
  fetch aggregated fields from the table: "conversation_participants"
  """
  conversation_participants_aggregate(
    """distinct select on columns"""
    distinct_on: [conversation_participants_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [conversation_participants_order_by!]

    """filter the rows returned"""
    where: conversation_participants_bool_exp
  ): conversation_participants_aggregate!

  """
  fetch data from the table: "conversation_participants" using primary key columns
  """
  conversation_participants_by_pk(id: uuid!): conversation_participants

  """
  fetch data from the table: "conversations"
  """
  conversations(
    """distinct select on columns"""
    distinct_on: [conversations_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [conversations_order_by!]

    """filter the rows returned"""
    where: conversations_bool_exp
  ): [conversations!]!

  """
  fetch aggregated fields from the table: "conversations"
  """
  conversations_aggregate(
    """distinct select on columns"""
    distinct_on: [conversations_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [conversations_order_by!]

    """filter the rows returned"""
    where: conversations_bool_exp
  ): conversations_aggregate!

  """fetch data from the table: "conversations" using primary key columns"""
  conversations_by_pk(id: uuid!): conversations

  """
  fetch data from the table: "countries"
  """
  countries(
    """distinct select on columns"""
    distinct_on: [countries_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [countries_order_by!]

    """filter the rows returned"""
    where: countries_bool_exp
  ): [countries!]!

  """
  fetch aggregated fields from the table: "countries"
  """
  countries_aggregate(
    """distinct select on columns"""
    distinct_on: [countries_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [countries_order_by!]

    """filter the rows returned"""
    where: countries_bool_exp
  ): countries_aggregate!

  """fetch data from the table: "countries" using primary key columns"""
  countries_by_pk(id: uuid!): countries

  """
  fetch data from the table: "coupons"
  """
  coupons(
    """distinct select on columns"""
    distinct_on: [coupons_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [coupons_order_by!]

    """filter the rows returned"""
    where: coupons_bool_exp
  ): [coupons!]!

  """
  fetch aggregated fields from the table: "coupons"
  """
  coupons_aggregate(
    """distinct select on columns"""
    distinct_on: [coupons_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [coupons_order_by!]

    """filter the rows returned"""
    where: coupons_bool_exp
  ): coupons_aggregate!

  """fetch data from the table: "coupons" using primary key columns"""
  coupons_by_pk(id: uuid!): coupons

  """
  fetch data from the table: "currencies"
  """
  currencies(
    """distinct select on columns"""
    distinct_on: [currencies_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [currencies_order_by!]

    """filter the rows returned"""
    where: currencies_bool_exp
  ): [currencies!]!

  """
  fetch aggregated fields from the table: "currencies"
  """
  currencies_aggregate(
    """distinct select on columns"""
    distinct_on: [currencies_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [currencies_order_by!]

    """filter the rows returned"""
    where: currencies_bool_exp
  ): currencies_aggregate!

  """fetch data from the table: "currencies" using primary key columns"""
  currencies_by_pk(id: uuid!): currencies

  """
  fetch data from the table: "customer_addresses"
  """
  customer_addresses(
    """distinct select on columns"""
    distinct_on: [customer_addresses_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [customer_addresses_order_by!]

    """filter the rows returned"""
    where: customer_addresses_bool_exp
  ): [customer_addresses!]!

  """
  fetch aggregated fields from the table: "customer_addresses"
  """
  customer_addresses_aggregate(
    """distinct select on columns"""
    distinct_on: [customer_addresses_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [customer_addresses_order_by!]

    """filter the rows returned"""
    where: customer_addresses_bool_exp
  ): customer_addresses_aggregate!

  """
  fetch data from the table: "customer_addresses" using primary key columns
  """
  customer_addresses_by_pk(id: uuid!): customer_addresses

  """
  fetch data from the table: "customer_stores"
  """
  customer_stores(
    """distinct select on columns"""
    distinct_on: [customer_stores_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [customer_stores_order_by!]

    """filter the rows returned"""
    where: customer_stores_bool_exp
  ): [customer_stores!]!

  """
  fetch aggregated fields from the table: "customer_stores"
  """
  customer_stores_aggregate(
    """distinct select on columns"""
    distinct_on: [customer_stores_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [customer_stores_order_by!]

    """filter the rows returned"""
    where: customer_stores_bool_exp
  ): customer_stores_aggregate!

  """fetch data from the table: "customer_stores" using primary key columns"""
  customer_stores_by_pk(id: uuid!): customer_stores

  """
  fetch data from the table: "customers"
  """
  customers(
    """distinct select on columns"""
    distinct_on: [customers_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [customers_order_by!]

    """filter the rows returned"""
    where: customers_bool_exp
  ): [customers!]!

  """
  fetch aggregated fields from the table: "customers"
  """
  customers_aggregate(
    """distinct select on columns"""
    distinct_on: [customers_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [customers_order_by!]

    """filter the rows returned"""
    where: customers_bool_exp
  ): customers_aggregate!

  """fetch data from the table: "customers" using primary key columns"""
  customers_by_pk(id: uuid!): customers

  """
  fetch data from the table: "districts"
  """
  districts(
    """distinct select on columns"""
    distinct_on: [districts_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [districts_order_by!]

    """filter the rows returned"""
    where: districts_bool_exp
  ): [districts!]!

  """
  fetch aggregated fields from the table: "districts"
  """
  districts_aggregate(
    """distinct select on columns"""
    distinct_on: [districts_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [districts_order_by!]

    """filter the rows returned"""
    where: districts_bool_exp
  ): districts_aggregate!

  """fetch data from the table: "districts" using primary key columns"""
  districts_by_pk(id: uuid!): districts

  """
  fetch data from the table: "ec_categories"
  """
  ec_categories(
    """distinct select on columns"""
    distinct_on: [ec_categories_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [ec_categories_order_by!]

    """filter the rows returned"""
    where: ec_categories_bool_exp
  ): [ec_categories!]!

  """
  fetch aggregated fields from the table: "ec_categories"
  """
  ec_categories_aggregate(
    """distinct select on columns"""
    distinct_on: [ec_categories_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [ec_categories_order_by!]

    """filter the rows returned"""
    where: ec_categories_bool_exp
  ): ec_categories_aggregate!

  """fetch data from the table: "ec_categories" using primary key columns"""
  ec_categories_by_pk(id: uuid!): ec_categories

  """
  fetch data from the table: "follows"
  """
  follows(
    """distinct select on columns"""
    distinct_on: [follows_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [follows_order_by!]

    """filter the rows returned"""
    where: follows_bool_exp
  ): [follows!]!

  """
  fetch aggregated fields from the table: "follows"
  """
  follows_aggregate(
    """distinct select on columns"""
    distinct_on: [follows_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [follows_order_by!]

    """filter the rows returned"""
    where: follows_bool_exp
  ): follows_aggregate!

  """fetch data from the table: "follows" using primary key columns"""
  follows_by_pk(id: uuid!): follows

  """
  fetch data from the table: "form_submissions"
  """
  form_submissions(
    """distinct select on columns"""
    distinct_on: [form_submissions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [form_submissions_order_by!]

    """filter the rows returned"""
    where: form_submissions_bool_exp
  ): [form_submissions!]!

  """
  fetch aggregated fields from the table: "form_submissions"
  """
  form_submissions_aggregate(
    """distinct select on columns"""
    distinct_on: [form_submissions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [form_submissions_order_by!]

    """filter the rows returned"""
    where: form_submissions_bool_exp
  ): form_submissions_aggregate!

  """
  fetch data from the table: "form_submissions" using primary key columns
  """
  form_submissions_by_pk(id: uuid!): form_submissions

  """
  fetch data from the table: "forms"
  """
  forms(
    """distinct select on columns"""
    distinct_on: [forms_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [forms_order_by!]

    """filter the rows returned"""
    where: forms_bool_exp
  ): [forms!]!

  """
  fetch aggregated fields from the table: "forms"
  """
  forms_aggregate(
    """distinct select on columns"""
    distinct_on: [forms_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [forms_order_by!]

    """filter the rows returned"""
    where: forms_bool_exp
  ): forms_aggregate!

  """fetch data from the table: "forms" using primary key columns"""
  forms_by_pk(id: uuid!): forms

  """
  fetch data from the table: "hashtags"
  """
  hashtags(
    """distinct select on columns"""
    distinct_on: [hashtags_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [hashtags_order_by!]

    """filter the rows returned"""
    where: hashtags_bool_exp
  ): [hashtags!]!

  """
  fetch aggregated fields from the table: "hashtags"
  """
  hashtags_aggregate(
    """distinct select on columns"""
    distinct_on: [hashtags_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [hashtags_order_by!]

    """filter the rows returned"""
    where: hashtags_bool_exp
  ): hashtags_aggregate!

  """fetch data from the table: "hashtags" using primary key columns"""
  hashtags_by_pk(id: uuid!): hashtags

  """
  fetch data from the table: "inventory_levels"
  """
  inventory_levels(
    """distinct select on columns"""
    distinct_on: [inventory_levels_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [inventory_levels_order_by!]

    """filter the rows returned"""
    where: inventory_levels_bool_exp
  ): [inventory_levels!]!

  """
  fetch aggregated fields from the table: "inventory_levels"
  """
  inventory_levels_aggregate(
    """distinct select on columns"""
    distinct_on: [inventory_levels_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [inventory_levels_order_by!]

    """filter the rows returned"""
    where: inventory_levels_bool_exp
  ): inventory_levels_aggregate!

  """
  fetch data from the table: "inventory_levels" using primary key columns
  """
  inventory_levels_by_pk(id: uuid!): inventory_levels

  """
  fetch data from the table: "inventory_locations"
  """
  inventory_locations(
    """distinct select on columns"""
    distinct_on: [inventory_locations_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [inventory_locations_order_by!]

    """filter the rows returned"""
    where: inventory_locations_bool_exp
  ): [inventory_locations!]!

  """
  fetch aggregated fields from the table: "inventory_locations"
  """
  inventory_locations_aggregate(
    """distinct select on columns"""
    distinct_on: [inventory_locations_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [inventory_locations_order_by!]

    """filter the rows returned"""
    where: inventory_locations_bool_exp
  ): inventory_locations_aggregate!

  """
  fetch data from the table: "inventory_locations" using primary key columns
  """
  inventory_locations_by_pk(id: uuid!): inventory_locations

  """
  fetch data from the table: "likes"
  """
  likes(
    """distinct select on columns"""
    distinct_on: [likes_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [likes_order_by!]

    """filter the rows returned"""
    where: likes_bool_exp
  ): [likes!]!

  """
  fetch aggregated fields from the table: "likes"
  """
  likes_aggregate(
    """distinct select on columns"""
    distinct_on: [likes_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [likes_order_by!]

    """filter the rows returned"""
    where: likes_bool_exp
  ): likes_aggregate!

  """fetch data from the table: "likes" using primary key columns"""
  likes_by_pk(id: uuid!): likes

  """
  fetch data from the table: "media_files"
  """
  media_files(
    """distinct select on columns"""
    distinct_on: [media_files_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [media_files_order_by!]

    """filter the rows returned"""
    where: media_files_bool_exp
  ): [media_files!]!

  """
  fetch aggregated fields from the table: "media_files"
  """
  media_files_aggregate(
    """distinct select on columns"""
    distinct_on: [media_files_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [media_files_order_by!]

    """filter the rows returned"""
    where: media_files_bool_exp
  ): media_files_aggregate!

  """fetch data from the table: "media_files" using primary key columns"""
  media_files_by_pk(id: uuid!): media_files

  """
  fetch data from the table: "media_folders"
  """
  media_folders(
    """distinct select on columns"""
    distinct_on: [media_folders_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [media_folders_order_by!]

    """filter the rows returned"""
    where: media_folders_bool_exp
  ): [media_folders!]!

  """
  fetch aggregated fields from the table: "media_folders"
  """
  media_folders_aggregate(
    """distinct select on columns"""
    distinct_on: [media_folders_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [media_folders_order_by!]

    """filter the rows returned"""
    where: media_folders_bool_exp
  ): media_folders_aggregate!

  """fetch data from the table: "media_folders" using primary key columns"""
  media_folders_by_pk(id: uuid!): media_folders

  """
  fetch data from the table: "mentions"
  """
  mentions(
    """distinct select on columns"""
    distinct_on: [mentions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [mentions_order_by!]

    """filter the rows returned"""
    where: mentions_bool_exp
  ): [mentions!]!

  """
  fetch aggregated fields from the table: "mentions"
  """
  mentions_aggregate(
    """distinct select on columns"""
    distinct_on: [mentions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [mentions_order_by!]

    """filter the rows returned"""
    where: mentions_bool_exp
  ): mentions_aggregate!

  """fetch data from the table: "mentions" using primary key columns"""
  mentions_by_pk(id: uuid!): mentions

  """
  fetch data from the table: "menu_items"
  """
  menu_items(
    """distinct select on columns"""
    distinct_on: [menu_items_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [menu_items_order_by!]

    """filter the rows returned"""
    where: menu_items_bool_exp
  ): [menu_items!]!

  """
  fetch aggregated fields from the table: "menu_items"
  """
  menu_items_aggregate(
    """distinct select on columns"""
    distinct_on: [menu_items_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [menu_items_order_by!]

    """filter the rows returned"""
    where: menu_items_bool_exp
  ): menu_items_aggregate!

  """fetch data from the table: "menu_items" using primary key columns"""
  menu_items_by_pk(id: uuid!): menu_items

  """
  fetch data from the table: "menus"
  """
  menus(
    """distinct select on columns"""
    distinct_on: [menus_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [menus_order_by!]

    """filter the rows returned"""
    where: menus_bool_exp
  ): [menus!]!

  """
  fetch aggregated fields from the table: "menus"
  """
  menus_aggregate(
    """distinct select on columns"""
    distinct_on: [menus_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [menus_order_by!]

    """filter the rows returned"""
    where: menus_bool_exp
  ): menus_aggregate!

  """fetch data from the table: "menus" using primary key columns"""
  menus_by_pk(id: uuid!): menus

  """
  fetch data from the table: "message_reactions"
  """
  message_reactions(
    """distinct select on columns"""
    distinct_on: [message_reactions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [message_reactions_order_by!]

    """filter the rows returned"""
    where: message_reactions_bool_exp
  ): [message_reactions!]!

  """
  fetch aggregated fields from the table: "message_reactions"
  """
  message_reactions_aggregate(
    """distinct select on columns"""
    distinct_on: [message_reactions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [message_reactions_order_by!]

    """filter the rows returned"""
    where: message_reactions_bool_exp
  ): message_reactions_aggregate!

  """
  fetch data from the table: "message_reactions" using primary key columns
  """
  message_reactions_by_pk(id: uuid!): message_reactions

  """
  fetch data from the table: "messages"
  """
  messages(
    """distinct select on columns"""
    distinct_on: [messages_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [messages_order_by!]

    """filter the rows returned"""
    where: messages_bool_exp
  ): [messages!]!

  """
  fetch aggregated fields from the table: "messages"
  """
  messages_aggregate(
    """distinct select on columns"""
    distinct_on: [messages_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [messages_order_by!]

    """filter the rows returned"""
    where: messages_bool_exp
  ): messages_aggregate!

  """fetch data from the table: "messages" using primary key columns"""
  messages_by_pk(id: uuid!): messages

  """
  fetch data from the table: "neighborhoods"
  """
  neighborhoods(
    """distinct select on columns"""
    distinct_on: [neighborhoods_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [neighborhoods_order_by!]

    """filter the rows returned"""
    where: neighborhoods_bool_exp
  ): [neighborhoods!]!

  """
  fetch aggregated fields from the table: "neighborhoods"
  """
  neighborhoods_aggregate(
    """distinct select on columns"""
    distinct_on: [neighborhoods_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [neighborhoods_order_by!]

    """filter the rows returned"""
    where: neighborhoods_bool_exp
  ): neighborhoods_aggregate!

  """fetch data from the table: "neighborhoods" using primary key columns"""
  neighborhoods_by_pk(id: uuid!): neighborhoods

  """
  fetch data from the table: "notifications"
  """
  notifications(
    """distinct select on columns"""
    distinct_on: [notifications_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notifications_order_by!]

    """filter the rows returned"""
    where: notifications_bool_exp
  ): [notifications!]!

  """
  fetch aggregated fields from the table: "notifications"
  """
  notifications_aggregate(
    """distinct select on columns"""
    distinct_on: [notifications_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notifications_order_by!]

    """filter the rows returned"""
    where: notifications_bool_exp
  ): notifications_aggregate!

  """fetch data from the table: "notifications" using primary key columns"""
  notifications_by_pk(id: uuid!): notifications

  """
  fetch data from the table: "order_coupons"
  """
  order_coupons(
    """distinct select on columns"""
    distinct_on: [order_coupons_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [order_coupons_order_by!]

    """filter the rows returned"""
    where: order_coupons_bool_exp
  ): [order_coupons!]!

  """
  fetch aggregated fields from the table: "order_coupons"
  """
  order_coupons_aggregate(
    """distinct select on columns"""
    distinct_on: [order_coupons_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [order_coupons_order_by!]

    """filter the rows returned"""
    where: order_coupons_bool_exp
  ): order_coupons_aggregate!

  """fetch data from the table: "order_coupons" using primary key columns"""
  order_coupons_by_pk(id: uuid!): order_coupons

  """
  fetch data from the table: "order_items"
  """
  order_items(
    """distinct select on columns"""
    distinct_on: [order_items_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [order_items_order_by!]

    """filter the rows returned"""
    where: order_items_bool_exp
  ): [order_items!]!

  """
  fetch aggregated fields from the table: "order_items"
  """
  order_items_aggregate(
    """distinct select on columns"""
    distinct_on: [order_items_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [order_items_order_by!]

    """filter the rows returned"""
    where: order_items_bool_exp
  ): order_items_aggregate!

  """fetch data from the table: "order_items" using primary key columns"""
  order_items_by_pk(id: uuid!): order_items

  """
  fetch data from the table: "order_statuses"
  """
  order_statuses(
    """distinct select on columns"""
    distinct_on: [order_statuses_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [order_statuses_order_by!]

    """filter the rows returned"""
    where: order_statuses_bool_exp
  ): [order_statuses!]!

  """
  fetch aggregated fields from the table: "order_statuses"
  """
  order_statuses_aggregate(
    """distinct select on columns"""
    distinct_on: [order_statuses_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [order_statuses_order_by!]

    """filter the rows returned"""
    where: order_statuses_bool_exp
  ): order_statuses_aggregate!

  """fetch data from the table: "order_statuses" using primary key columns"""
  order_statuses_by_pk(id: uuid!): order_statuses

  """
  fetch data from the table: "orders"
  """
  orders(
    """distinct select on columns"""
    distinct_on: [orders_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [orders_order_by!]

    """filter the rows returned"""
    where: orders_bool_exp
  ): [orders!]!

  """
  fetch aggregated fields from the table: "orders"
  """
  orders_aggregate(
    """distinct select on columns"""
    distinct_on: [orders_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [orders_order_by!]

    """filter the rows returned"""
    where: orders_bool_exp
  ): orders_aggregate!

  """fetch data from the table: "orders" using primary key columns"""
  orders_by_pk(id: uuid!): orders

  """
  fetch data from the table: "page_templates"
  """
  page_templates(
    """distinct select on columns"""
    distinct_on: [page_templates_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [page_templates_order_by!]

    """filter the rows returned"""
    where: page_templates_bool_exp
  ): [page_templates!]!

  """
  fetch aggregated fields from the table: "page_templates"
  """
  page_templates_aggregate(
    """distinct select on columns"""
    distinct_on: [page_templates_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [page_templates_order_by!]

    """filter the rows returned"""
    where: page_templates_bool_exp
  ): page_templates_aggregate!

  """fetch data from the table: "page_templates" using primary key columns"""
  page_templates_by_pk(id: uuid!): page_templates

  """
  fetch data from the table: "page_versions"
  """
  page_versions(
    """distinct select on columns"""
    distinct_on: [page_versions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [page_versions_order_by!]

    """filter the rows returned"""
    where: page_versions_bool_exp
  ): [page_versions!]!

  """
  fetch aggregated fields from the table: "page_versions"
  """
  page_versions_aggregate(
    """distinct select on columns"""
    distinct_on: [page_versions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [page_versions_order_by!]

    """filter the rows returned"""
    where: page_versions_bool_exp
  ): page_versions_aggregate!

  """fetch data from the table: "page_versions" using primary key columns"""
  page_versions_by_pk(id: uuid!): page_versions

  """
  fetch data from the table: "pages"
  """
  pages(
    """distinct select on columns"""
    distinct_on: [pages_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [pages_order_by!]

    """filter the rows returned"""
    where: pages_bool_exp
  ): [pages!]!

  """
  fetch aggregated fields from the table: "pages"
  """
  pages_aggregate(
    """distinct select on columns"""
    distinct_on: [pages_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [pages_order_by!]

    """filter the rows returned"""
    where: pages_bool_exp
  ): pages_aggregate!

  """fetch data from the table: "pages" using primary key columns"""
  pages_by_pk(id: uuid!): pages

  """
  fetch data from the table: "payment_methods"
  """
  payment_methods(
    """distinct select on columns"""
    distinct_on: [payment_methods_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payment_methods_order_by!]

    """filter the rows returned"""
    where: payment_methods_bool_exp
  ): [payment_methods!]!

  """
  fetch aggregated fields from the table: "payment_methods"
  """
  payment_methods_aggregate(
    """distinct select on columns"""
    distinct_on: [payment_methods_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payment_methods_order_by!]

    """filter the rows returned"""
    where: payment_methods_bool_exp
  ): payment_methods_aggregate!

  """fetch data from the table: "payment_methods" using primary key columns"""
  payment_methods_by_pk(id: uuid!): payment_methods

  """
  fetch data from the table: "payment_statuses"
  """
  payment_statuses(
    """distinct select on columns"""
    distinct_on: [payment_statuses_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payment_statuses_order_by!]

    """filter the rows returned"""
    where: payment_statuses_bool_exp
  ): [payment_statuses!]!

  """
  fetch aggregated fields from the table: "payment_statuses"
  """
  payment_statuses_aggregate(
    """distinct select on columns"""
    distinct_on: [payment_statuses_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payment_statuses_order_by!]

    """filter the rows returned"""
    where: payment_statuses_bool_exp
  ): payment_statuses_aggregate!

  """
  fetch data from the table: "payment_statuses" using primary key columns
  """
  payment_statuses_by_pk(id: uuid!): payment_statuses

  """
  fetch data from the table: "payments"
  """
  payments(
    """distinct select on columns"""
    distinct_on: [payments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payments_order_by!]

    """filter the rows returned"""
    where: payments_bool_exp
  ): [payments!]!

  """
  fetch aggregated fields from the table: "payments"
  """
  payments_aggregate(
    """distinct select on columns"""
    distinct_on: [payments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payments_order_by!]

    """filter the rows returned"""
    where: payments_bool_exp
  ): payments_aggregate!

  """fetch data from the table: "payments" using primary key columns"""
  payments_by_pk(id: uuid!): payments

  """
  fetch data from the table: "permissions"
  """
  permissions(
    """distinct select on columns"""
    distinct_on: [permissions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [permissions_order_by!]

    """filter the rows returned"""
    where: permissions_bool_exp
  ): [permissions!]!

  """
  fetch aggregated fields from the table: "permissions"
  """
  permissions_aggregate(
    """distinct select on columns"""
    distinct_on: [permissions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [permissions_order_by!]

    """filter the rows returned"""
    where: permissions_bool_exp
  ): permissions_aggregate!

  """fetch data from the table: "permissions" using primary key columns"""
  permissions_by_pk(id: uuid!): permissions

  """
  fetch data from the table: "post_hashtags"
  """
  post_hashtags(
    """distinct select on columns"""
    distinct_on: [post_hashtags_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [post_hashtags_order_by!]

    """filter the rows returned"""
    where: post_hashtags_bool_exp
  ): [post_hashtags!]!

  """
  fetch aggregated fields from the table: "post_hashtags"
  """
  post_hashtags_aggregate(
    """distinct select on columns"""
    distinct_on: [post_hashtags_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [post_hashtags_order_by!]

    """filter the rows returned"""
    where: post_hashtags_bool_exp
  ): post_hashtags_aggregate!

  """fetch data from the table: "post_hashtags" using primary key columns"""
  post_hashtags_by_pk(id: uuid!): post_hashtags

  """
  fetch data from the table: "post_media"
  """
  post_media(
    """distinct select on columns"""
    distinct_on: [post_media_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [post_media_order_by!]

    """filter the rows returned"""
    where: post_media_bool_exp
  ): [post_media!]!

  """
  fetch aggregated fields from the table: "post_media"
  """
  post_media_aggregate(
    """distinct select on columns"""
    distinct_on: [post_media_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [post_media_order_by!]

    """filter the rows returned"""
    where: post_media_bool_exp
  ): post_media_aggregate!

  """fetch data from the table: "post_media" using primary key columns"""
  post_media_by_pk(id: uuid!): post_media

  """
  fetch data from the table: "posts"
  """
  posts(
    """distinct select on columns"""
    distinct_on: [posts_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [posts_order_by!]

    """filter the rows returned"""
    where: posts_bool_exp
  ): [posts!]!

  """
  fetch aggregated fields from the table: "posts"
  """
  posts_aggregate(
    """distinct select on columns"""
    distinct_on: [posts_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [posts_order_by!]

    """filter the rows returned"""
    where: posts_bool_exp
  ): posts_aggregate!

  """fetch data from the table: "posts" using primary key columns"""
  posts_by_pk(id: uuid!): posts

  """
  fetch data from the table: "product_categories"
  """
  product_categories(
    """distinct select on columns"""
    distinct_on: [product_categories_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_categories_order_by!]

    """filter the rows returned"""
    where: product_categories_bool_exp
  ): [product_categories!]!

  """
  fetch aggregated fields from the table: "product_categories"
  """
  product_categories_aggregate(
    """distinct select on columns"""
    distinct_on: [product_categories_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_categories_order_by!]

    """filter the rows returned"""
    where: product_categories_bool_exp
  ): product_categories_aggregate!

  """
  fetch data from the table: "product_categories" using primary key columns
  """
  product_categories_by_pk(id: uuid!): product_categories

  """
  fetch data from the table: "product_collections"
  """
  product_collections(
    """distinct select on columns"""
    distinct_on: [product_collections_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_collections_order_by!]

    """filter the rows returned"""
    where: product_collections_bool_exp
  ): [product_collections!]!

  """
  fetch aggregated fields from the table: "product_collections"
  """
  product_collections_aggregate(
    """distinct select on columns"""
    distinct_on: [product_collections_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_collections_order_by!]

    """filter the rows returned"""
    where: product_collections_bool_exp
  ): product_collections_aggregate!

  """
  fetch data from the table: "product_collections" using primary key columns
  """
  product_collections_by_pk(id: uuid!): product_collections

  """
  fetch data from the table: "product_images"
  """
  product_images(
    """distinct select on columns"""
    distinct_on: [product_images_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_images_order_by!]

    """filter the rows returned"""
    where: product_images_bool_exp
  ): [product_images!]!

  """
  fetch aggregated fields from the table: "product_images"
  """
  product_images_aggregate(
    """distinct select on columns"""
    distinct_on: [product_images_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_images_order_by!]

    """filter the rows returned"""
    where: product_images_bool_exp
  ): product_images_aggregate!

  """fetch data from the table: "product_images" using primary key columns"""
  product_images_by_pk(id: uuid!): product_images

  """
  fetch data from the table: "product_variants"
  """
  product_variants(
    """distinct select on columns"""
    distinct_on: [product_variants_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_variants_order_by!]

    """filter the rows returned"""
    where: product_variants_bool_exp
  ): [product_variants!]!

  """
  fetch aggregated fields from the table: "product_variants"
  """
  product_variants_aggregate(
    """distinct select on columns"""
    distinct_on: [product_variants_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_variants_order_by!]

    """filter the rows returned"""
    where: product_variants_bool_exp
  ): product_variants_aggregate!

  """
  fetch data from the table: "product_variants" using primary key columns
  """
  product_variants_by_pk(id: uuid!): product_variants

  """
  fetch data from the table: "products"
  """
  products(
    """distinct select on columns"""
    distinct_on: [products_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [products_order_by!]

    """filter the rows returned"""
    where: products_bool_exp
  ): [products!]!

  """
  fetch aggregated fields from the table: "products"
  """
  products_aggregate(
    """distinct select on columns"""
    distinct_on: [products_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [products_order_by!]

    """filter the rows returned"""
    where: products_bool_exp
  ): products_aggregate!

  """fetch data from the table: "products" using primary key columns"""
  products_by_pk(id: uuid!): products

  """
  fetch data from the table: "redirects"
  """
  redirects(
    """distinct select on columns"""
    distinct_on: [redirects_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [redirects_order_by!]

    """filter the rows returned"""
    where: redirects_bool_exp
  ): [redirects!]!

  """
  fetch aggregated fields from the table: "redirects"
  """
  redirects_aggregate(
    """distinct select on columns"""
    distinct_on: [redirects_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [redirects_order_by!]

    """filter the rows returned"""
    where: redirects_bool_exp
  ): redirects_aggregate!

  """fetch data from the table: "redirects" using primary key columns"""
  redirects_by_pk(id: uuid!): redirects

  """
  fetch data from the table: "regions"
  """
  regions(
    """distinct select on columns"""
    distinct_on: [regions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [regions_order_by!]

    """filter the rows returned"""
    where: regions_bool_exp
  ): [regions!]!

  """
  fetch aggregated fields from the table: "regions"
  """
  regions_aggregate(
    """distinct select on columns"""
    distinct_on: [regions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [regions_order_by!]

    """filter the rows returned"""
    where: regions_bool_exp
  ): regions_aggregate!

  """fetch data from the table: "regions" using primary key columns"""
  regions_by_pk(id: uuid!): regions

  """
  fetch data from the table: "related_products"
  """
  related_products(
    """distinct select on columns"""
    distinct_on: [related_products_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [related_products_order_by!]

    """filter the rows returned"""
    where: related_products_bool_exp
  ): [related_products!]!

  """
  fetch aggregated fields from the table: "related_products"
  """
  related_products_aggregate(
    """distinct select on columns"""
    distinct_on: [related_products_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [related_products_order_by!]

    """filter the rows returned"""
    where: related_products_bool_exp
  ): related_products_aggregate!

  """
  fetch data from the table: "related_products" using primary key columns
  """
  related_products_by_pk(id: uuid!): related_products

  """
  fetch data from the table: "report_statuses"
  """
  report_statuses(
    """distinct select on columns"""
    distinct_on: [report_statuses_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [report_statuses_order_by!]

    """filter the rows returned"""
    where: report_statuses_bool_exp
  ): [report_statuses!]!

  """
  fetch aggregated fields from the table: "report_statuses"
  """
  report_statuses_aggregate(
    """distinct select on columns"""
    distinct_on: [report_statuses_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [report_statuses_order_by!]

    """filter the rows returned"""
    where: report_statuses_bool_exp
  ): report_statuses_aggregate!

  """fetch data from the table: "report_statuses" using primary key columns"""
  report_statuses_by_pk(id: uuid!): report_statuses

  """
  fetch data from the table: "reports"
  """
  reports(
    """distinct select on columns"""
    distinct_on: [reports_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [reports_order_by!]

    """filter the rows returned"""
    where: reports_bool_exp
  ): [reports!]!

  """
  fetch aggregated fields from the table: "reports"
  """
  reports_aggregate(
    """distinct select on columns"""
    distinct_on: [reports_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [reports_order_by!]

    """filter the rows returned"""
    where: reports_bool_exp
  ): reports_aggregate!

  """fetch data from the table: "reports" using primary key columns"""
  reports_by_pk(id: uuid!): reports

  """
  fetch data from the table: "return_requests"
  """
  return_requests(
    """distinct select on columns"""
    distinct_on: [return_requests_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [return_requests_order_by!]

    """filter the rows returned"""
    where: return_requests_bool_exp
  ): [return_requests!]!

  """
  fetch aggregated fields from the table: "return_requests"
  """
  return_requests_aggregate(
    """distinct select on columns"""
    distinct_on: [return_requests_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [return_requests_order_by!]

    """filter the rows returned"""
    where: return_requests_bool_exp
  ): return_requests_aggregate!

  """fetch data from the table: "return_requests" using primary key columns"""
  return_requests_by_pk(id: uuid!): return_requests

  """
  fetch data from the table: "return_statuses"
  """
  return_statuses(
    """distinct select on columns"""
    distinct_on: [return_statuses_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [return_statuses_order_by!]

    """filter the rows returned"""
    where: return_statuses_bool_exp
  ): [return_statuses!]!

  """
  fetch aggregated fields from the table: "return_statuses"
  """
  return_statuses_aggregate(
    """distinct select on columns"""
    distinct_on: [return_statuses_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [return_statuses_order_by!]

    """filter the rows returned"""
    where: return_statuses_bool_exp
  ): return_statuses_aggregate!

  """fetch data from the table: "return_statuses" using primary key columns"""
  return_statuses_by_pk(id: uuid!): return_statuses

  """
  fetch data from the table: "reviews"
  """
  reviews(
    """distinct select on columns"""
    distinct_on: [reviews_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [reviews_order_by!]

    """filter the rows returned"""
    where: reviews_bool_exp
  ): [reviews!]!

  """
  fetch aggregated fields from the table: "reviews"
  """
  reviews_aggregate(
    """distinct select on columns"""
    distinct_on: [reviews_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [reviews_order_by!]

    """filter the rows returned"""
    where: reviews_bool_exp
  ): reviews_aggregate!

  """fetch data from the table: "reviews" using primary key columns"""
  reviews_by_pk(id: uuid!): reviews

  """
  fetch data from the table: "role_permissions"
  """
  role_permissions(
    """distinct select on columns"""
    distinct_on: [role_permissions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [role_permissions_order_by!]

    """filter the rows returned"""
    where: role_permissions_bool_exp
  ): [role_permissions!]!

  """
  fetch aggregated fields from the table: "role_permissions"
  """
  role_permissions_aggregate(
    """distinct select on columns"""
    distinct_on: [role_permissions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [role_permissions_order_by!]

    """filter the rows returned"""
    where: role_permissions_bool_exp
  ): role_permissions_aggregate!

  """
  fetch data from the table: "role_permissions" using primary key columns
  """
  role_permissions_by_pk(id: uuid!): role_permissions

  """
  fetch data from the table: "roles"
  """
  roles(
    """distinct select on columns"""
    distinct_on: [roles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [roles_order_by!]

    """filter the rows returned"""
    where: roles_bool_exp
  ): [roles!]!

  """
  fetch aggregated fields from the table: "roles"
  """
  roles_aggregate(
    """distinct select on columns"""
    distinct_on: [roles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [roles_order_by!]

    """filter the rows returned"""
    where: roles_bool_exp
  ): roles_aggregate!

  """fetch data from the table: "roles" using primary key columns"""
  roles_by_pk(id: uuid!): roles

  """
  fetch data from the table: "seo_settings"
  """
  seo_settings(
    """distinct select on columns"""
    distinct_on: [seo_settings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [seo_settings_order_by!]

    """filter the rows returned"""
    where: seo_settings_bool_exp
  ): [seo_settings!]!

  """
  fetch aggregated fields from the table: "seo_settings"
  """
  seo_settings_aggregate(
    """distinct select on columns"""
    distinct_on: [seo_settings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [seo_settings_order_by!]

    """filter the rows returned"""
    where: seo_settings_bool_exp
  ): seo_settings_aggregate!

  """fetch data from the table: "seo_settings" using primary key columns"""
  seo_settings_by_pk(id: uuid!): seo_settings

  """
  fetch data from the table: "shipment_statuses"
  """
  shipment_statuses(
    """distinct select on columns"""
    distinct_on: [shipment_statuses_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [shipment_statuses_order_by!]

    """filter the rows returned"""
    where: shipment_statuses_bool_exp
  ): [shipment_statuses!]!

  """
  fetch aggregated fields from the table: "shipment_statuses"
  """
  shipment_statuses_aggregate(
    """distinct select on columns"""
    distinct_on: [shipment_statuses_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [shipment_statuses_order_by!]

    """filter the rows returned"""
    where: shipment_statuses_bool_exp
  ): shipment_statuses_aggregate!

  """
  fetch data from the table: "shipment_statuses" using primary key columns
  """
  shipment_statuses_by_pk(id: uuid!): shipment_statuses

  """
  fetch data from the table: "shipments"
  """
  shipments(
    """distinct select on columns"""
    distinct_on: [shipments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [shipments_order_by!]

    """filter the rows returned"""
    where: shipments_bool_exp
  ): [shipments!]!

  """
  fetch aggregated fields from the table: "shipments"
  """
  shipments_aggregate(
    """distinct select on columns"""
    distinct_on: [shipments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [shipments_order_by!]

    """filter the rows returned"""
    where: shipments_bool_exp
  ): shipments_aggregate!

  """fetch data from the table: "shipments" using primary key columns"""
  shipments_by_pk(id: uuid!): shipments

  """
  fetch data from the table: "shipping_carriers"
  """
  shipping_carriers(
    """distinct select on columns"""
    distinct_on: [shipping_carriers_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [shipping_carriers_order_by!]

    """filter the rows returned"""
    where: shipping_carriers_bool_exp
  ): [shipping_carriers!]!

  """
  fetch aggregated fields from the table: "shipping_carriers"
  """
  shipping_carriers_aggregate(
    """distinct select on columns"""
    distinct_on: [shipping_carriers_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [shipping_carriers_order_by!]

    """filter the rows returned"""
    where: shipping_carriers_bool_exp
  ): shipping_carriers_aggregate!

  """
  fetch data from the table: "shipping_carriers" using primary key columns
  """
  shipping_carriers_by_pk(id: uuid!): shipping_carriers

  """
  fetch data from the table: "site_authors"
  """
  site_authors(
    """distinct select on columns"""
    distinct_on: [site_authors_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [site_authors_order_by!]

    """filter the rows returned"""
    where: site_authors_bool_exp
  ): [site_authors!]!

  """
  fetch aggregated fields from the table: "site_authors"
  """
  site_authors_aggregate(
    """distinct select on columns"""
    distinct_on: [site_authors_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [site_authors_order_by!]

    """filter the rows returned"""
    where: site_authors_bool_exp
  ): site_authors_aggregate!

  """fetch data from the table: "site_authors" using primary key columns"""
  site_authors_by_pk(id: uuid!): site_authors

  """
  fetch data from the table: "sites"
  """
  sites(
    """distinct select on columns"""
    distinct_on: [sites_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [sites_order_by!]

    """filter the rows returned"""
    where: sites_bool_exp
  ): [sites!]!

  """
  fetch aggregated fields from the table: "sites"
  """
  sites_aggregate(
    """distinct select on columns"""
    distinct_on: [sites_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [sites_order_by!]

    """filter the rows returned"""
    where: sites_bool_exp
  ): sites_aggregate!

  """fetch data from the table: "sites" using primary key columns"""
  sites_by_pk(id: uuid!): sites

  """
  fetch data from the table: "sizes"
  """
  sizes(
    """distinct select on columns"""
    distinct_on: [sizes_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [sizes_order_by!]

    """filter the rows returned"""
    where: sizes_bool_exp
  ): [sizes!]!

  """
  fetch aggregated fields from the table: "sizes"
  """
  sizes_aggregate(
    """distinct select on columns"""
    distinct_on: [sizes_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [sizes_order_by!]

    """filter the rows returned"""
    where: sizes_bool_exp
  ): sizes_aggregate!

  """fetch data from the table: "sizes" using primary key columns"""
  sizes_by_pk(id: uuid!): sizes

  """
  fetch data from the table: "store_currencies"
  """
  store_currencies(
    """distinct select on columns"""
    distinct_on: [store_currencies_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [store_currencies_order_by!]

    """filter the rows returned"""
    where: store_currencies_bool_exp
  ): [store_currencies!]!

  """
  fetch aggregated fields from the table: "store_currencies"
  """
  store_currencies_aggregate(
    """distinct select on columns"""
    distinct_on: [store_currencies_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [store_currencies_order_by!]

    """filter the rows returned"""
    where: store_currencies_bool_exp
  ): store_currencies_aggregate!

  """
  fetch data from the table: "store_currencies" using primary key columns
  """
  store_currencies_by_pk(id: uuid!): store_currencies

  """
  fetch data from the table: "store_payment_methods"
  """
  store_payment_methods(
    """distinct select on columns"""
    distinct_on: [store_payment_methods_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [store_payment_methods_order_by!]

    """filter the rows returned"""
    where: store_payment_methods_bool_exp
  ): [store_payment_methods!]!

  """
  fetch aggregated fields from the table: "store_payment_methods"
  """
  store_payment_methods_aggregate(
    """distinct select on columns"""
    distinct_on: [store_payment_methods_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [store_payment_methods_order_by!]

    """filter the rows returned"""
    where: store_payment_methods_bool_exp
  ): store_payment_methods_aggregate!

  """
  fetch data from the table: "store_payment_methods" using primary key columns
  """
  store_payment_methods_by_pk(id: uuid!): store_payment_methods

  """
  fetch data from the table: "store_shipping_carriers"
  """
  store_shipping_carriers(
    """distinct select on columns"""
    distinct_on: [store_shipping_carriers_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [store_shipping_carriers_order_by!]

    """filter the rows returned"""
    where: store_shipping_carriers_bool_exp
  ): [store_shipping_carriers!]!

  """
  fetch aggregated fields from the table: "store_shipping_carriers"
  """
  store_shipping_carriers_aggregate(
    """distinct select on columns"""
    distinct_on: [store_shipping_carriers_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [store_shipping_carriers_order_by!]

    """filter the rows returned"""
    where: store_shipping_carriers_bool_exp
  ): store_shipping_carriers_aggregate!

  """
  fetch data from the table: "store_shipping_carriers" using primary key columns
  """
  store_shipping_carriers_by_pk(id: uuid!): store_shipping_carriers

  """
  fetch data from the table: "stores"
  """
  stores(
    """distinct select on columns"""
    distinct_on: [stores_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [stores_order_by!]

    """filter the rows returned"""
    where: stores_bool_exp
  ): [stores!]!

  """
  fetch aggregated fields from the table: "stores"
  """
  stores_aggregate(
    """distinct select on columns"""
    distinct_on: [stores_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [stores_order_by!]

    """filter the rows returned"""
    where: stores_bool_exp
  ): stores_aggregate!

  """fetch data from the table: "stores" using primary key columns"""
  stores_by_pk(id: uuid!): stores

  """
  fetch data from the table: "streets"
  """
  streets(
    """distinct select on columns"""
    distinct_on: [streets_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [streets_order_by!]

    """filter the rows returned"""
    where: streets_bool_exp
  ): [streets!]!

  """
  fetch aggregated fields from the table: "streets"
  """
  streets_aggregate(
    """distinct select on columns"""
    distinct_on: [streets_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [streets_order_by!]

    """filter the rows returned"""
    where: streets_bool_exp
  ): streets_aggregate!

  """fetch data from the table: "streets" using primary key columns"""
  streets_by_pk(id: uuid!): streets

  """
  fetch data from the table: "tags"
  """
  tags(
    """distinct select on columns"""
    distinct_on: [tags_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tags_order_by!]

    """filter the rows returned"""
    where: tags_bool_exp
  ): [tags!]!

  """
  fetch aggregated fields from the table: "tags"
  """
  tags_aggregate(
    """distinct select on columns"""
    distinct_on: [tags_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tags_order_by!]

    """filter the rows returned"""
    where: tags_bool_exp
  ): tags_aggregate!

  """fetch data from the table: "tags" using primary key columns"""
  tags_by_pk(id: uuid!): tags

  """
  fetch data from the table: "user_profiles"
  """
  user_profiles(
    """distinct select on columns"""
    distinct_on: [user_profiles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_profiles_order_by!]

    """filter the rows returned"""
    where: user_profiles_bool_exp
  ): [user_profiles!]!

  """
  fetch aggregated fields from the table: "user_profiles"
  """
  user_profiles_aggregate(
    """distinct select on columns"""
    distinct_on: [user_profiles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_profiles_order_by!]

    """filter the rows returned"""
    where: user_profiles_bool_exp
  ): user_profiles_aggregate!

  """fetch data from the table: "user_profiles" using primary key columns"""
  user_profiles_by_pk(id: uuid!): user_profiles

  """
  fetch data from the table: "user_roles"
  """
  user_roles(
    """distinct select on columns"""
    distinct_on: [user_roles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_roles_order_by!]

    """filter the rows returned"""
    where: user_roles_bool_exp
  ): [user_roles!]!

  """
  fetch aggregated fields from the table: "user_roles"
  """
  user_roles_aggregate(
    """distinct select on columns"""
    distinct_on: [user_roles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_roles_order_by!]

    """filter the rows returned"""
    where: user_roles_bool_exp
  ): user_roles_aggregate!

  """fetch data from the table: "user_roles" using primary key columns"""
  user_roles_by_pk(id: uuid!): user_roles

  """
  fetch data from the table: "user_sessions"
  """
  user_sessions(
    """distinct select on columns"""
    distinct_on: [user_sessions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_sessions_order_by!]

    """filter the rows returned"""
    where: user_sessions_bool_exp
  ): [user_sessions!]!

  """
  fetch aggregated fields from the table: "user_sessions"
  """
  user_sessions_aggregate(
    """distinct select on columns"""
    distinct_on: [user_sessions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_sessions_order_by!]

    """filter the rows returned"""
    where: user_sessions_bool_exp
  ): user_sessions_aggregate!

  """fetch data from the table: "user_sessions" using primary key columns"""
  user_sessions_by_pk(id: uuid!): user_sessions

  """
  fetch data from the table: "user_settings"
  """
  user_settings(
    """distinct select on columns"""
    distinct_on: [user_settings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_settings_order_by!]

    """filter the rows returned"""
    where: user_settings_bool_exp
  ): [user_settings!]!

  """
  fetch aggregated fields from the table: "user_settings"
  """
  user_settings_aggregate(
    """distinct select on columns"""
    distinct_on: [user_settings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_settings_order_by!]

    """filter the rows returned"""
    where: user_settings_bool_exp
  ): user_settings_aggregate!

  """fetch data from the table: "user_settings" using primary key columns"""
  user_settings_by_pk(id: uuid!): user_settings

  """
  fetch data from the table: "users"
  """
  users(
    """distinct select on columns"""
    distinct_on: [users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_order_by!]

    """filter the rows returned"""
    where: users_bool_exp
  ): [users!]!

  """
  fetch aggregated fields from the table: "users"
  """
  users_aggregate(
    """distinct select on columns"""
    distinct_on: [users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_order_by!]

    """filter the rows returned"""
    where: users_bool_exp
  ): users_aggregate!

  """fetch data from the table: "users" using primary key columns"""
  users_by_pk(id: uuid!): users

  """
  fetch data from the table: "wishlist_items"
  """
  wishlist_items(
    """distinct select on columns"""
    distinct_on: [wishlist_items_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [wishlist_items_order_by!]

    """filter the rows returned"""
    where: wishlist_items_bool_exp
  ): [wishlist_items!]!

  """
  fetch aggregated fields from the table: "wishlist_items"
  """
  wishlist_items_aggregate(
    """distinct select on columns"""
    distinct_on: [wishlist_items_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [wishlist_items_order_by!]

    """filter the rows returned"""
    where: wishlist_items_bool_exp
  ): wishlist_items_aggregate!

  """fetch data from the table: "wishlist_items" using primary key columns"""
  wishlist_items_by_pk(id: uuid!): wishlist_items

  """
  fetch data from the table: "wishlists"
  """
  wishlists(
    """distinct select on columns"""
    distinct_on: [wishlists_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [wishlists_order_by!]

    """filter the rows returned"""
    where: wishlists_bool_exp
  ): [wishlists!]!

  """
  fetch aggregated fields from the table: "wishlists"
  """
  wishlists_aggregate(
    """distinct select on columns"""
    distinct_on: [wishlists_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [wishlists_order_by!]

    """filter the rows returned"""
    where: wishlists_bool_exp
  ): wishlists_aggregate!

  """fetch data from the table: "wishlists" using primary key columns"""
  wishlists_by_pk(id: uuid!): wishlists
}

"""
columns and relationships of "redirects"
"""
type redirects {
  created_at: timestamptz!
  deleted_at: timestamptz
  from_path: String!
  id: uuid!
  is_active: Boolean!
  site_id: uuid
  status_code: Int!
  to_path: String!
  updated_at: timestamptz!
}

"""
aggregated selection of "redirects"
"""
type redirects_aggregate {
  aggregate: redirects_aggregate_fields
  nodes: [redirects!]!
}

"""
aggregate fields of "redirects"
"""
type redirects_aggregate_fields {
  avg: redirects_avg_fields
  count(columns: [redirects_select_column!], distinct: Boolean): Int!
  max: redirects_max_fields
  min: redirects_min_fields
  stddev: redirects_stddev_fields
  stddev_pop: redirects_stddev_pop_fields
  stddev_samp: redirects_stddev_samp_fields
  sum: redirects_sum_fields
  var_pop: redirects_var_pop_fields
  var_samp: redirects_var_samp_fields
  variance: redirects_variance_fields
}

"""aggregate avg on columns"""
type redirects_avg_fields {
  status_code: Float
}

"""
Boolean expression to filter rows from the table "redirects". All fields are combined with a logical 'AND'.
"""
input redirects_bool_exp {
  _and: [redirects_bool_exp!]
  _not: redirects_bool_exp
  _or: [redirects_bool_exp!]
  created_at: timestamptz_comparison_exp
  deleted_at: timestamptz_comparison_exp
  from_path: String_comparison_exp
  id: uuid_comparison_exp
  is_active: Boolean_comparison_exp
  site_id: uuid_comparison_exp
  status_code: Int_comparison_exp
  to_path: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "redirects"
"""
enum redirects_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  redirects_pkey
}

"""
input type for incrementing numeric columns in table "redirects"
"""
input redirects_inc_input {
  status_code: Int
}

"""
input type for inserting data into table "redirects"
"""
input redirects_insert_input {
  created_at: timestamptz
  deleted_at: timestamptz
  from_path: String
  id: uuid
  is_active: Boolean
  site_id: uuid
  status_code: Int
  to_path: String
  updated_at: timestamptz
}

"""aggregate max on columns"""
type redirects_max_fields {
  created_at: timestamptz
  deleted_at: timestamptz
  from_path: String
  id: uuid
  site_id: uuid
  status_code: Int
  to_path: String
  updated_at: timestamptz
}

"""aggregate min on columns"""
type redirects_min_fields {
  created_at: timestamptz
  deleted_at: timestamptz
  from_path: String
  id: uuid
  site_id: uuid
  status_code: Int
  to_path: String
  updated_at: timestamptz
}

"""
response of any mutation on the table "redirects"
"""
type redirects_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [redirects!]!
}

"""
on_conflict condition type for table "redirects"
"""
input redirects_on_conflict {
  constraint: redirects_constraint!
  update_columns: [redirects_update_column!]! = []
  where: redirects_bool_exp
}

"""Ordering options when selecting data from "redirects"."""
input redirects_order_by {
  created_at: order_by
  deleted_at: order_by
  from_path: order_by
  id: order_by
  is_active: order_by
  site_id: order_by
  status_code: order_by
  to_path: order_by
  updated_at: order_by
}

"""primary key columns input for table: redirects"""
input redirects_pk_columns_input {
  id: uuid!
}

"""
select columns of table "redirects"
"""
enum redirects_select_column {
  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  from_path

  """column name"""
  id

  """column name"""
  is_active

  """column name"""
  site_id

  """column name"""
  status_code

  """column name"""
  to_path

  """column name"""
  updated_at
}

"""
input type for updating data in table "redirects"
"""
input redirects_set_input {
  created_at: timestamptz
  deleted_at: timestamptz
  from_path: String
  id: uuid
  is_active: Boolean
  site_id: uuid
  status_code: Int
  to_path: String
  updated_at: timestamptz
}

"""aggregate stddev on columns"""
type redirects_stddev_fields {
  status_code: Float
}

"""aggregate stddev_pop on columns"""
type redirects_stddev_pop_fields {
  status_code: Float
}

"""aggregate stddev_samp on columns"""
type redirects_stddev_samp_fields {
  status_code: Float
}

"""
Streaming cursor of the table "redirects"
"""
input redirects_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: redirects_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input redirects_stream_cursor_value_input {
  created_at: timestamptz
  deleted_at: timestamptz
  from_path: String
  id: uuid
  is_active: Boolean
  site_id: uuid
  status_code: Int
  to_path: String
  updated_at: timestamptz
}

"""aggregate sum on columns"""
type redirects_sum_fields {
  status_code: Int
}

"""
update columns of table "redirects"
"""
enum redirects_update_column {
  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  from_path

  """column name"""
  id

  """column name"""
  is_active

  """column name"""
  site_id

  """column name"""
  status_code

  """column name"""
  to_path

  """column name"""
  updated_at
}

input redirects_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: redirects_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: redirects_set_input

  """filter the rows which have to be updated"""
  where: redirects_bool_exp!
}

"""aggregate var_pop on columns"""
type redirects_var_pop_fields {
  status_code: Float
}

"""aggregate var_samp on columns"""
type redirects_var_samp_fields {
  status_code: Float
}

"""aggregate variance on columns"""
type redirects_variance_fields {
  status_code: Float
}

"""
columns and relationships of "regions"
"""
type regions {
  code: String!
  created_at: timestamptz!
  deleted_at: timestamptz
  id: uuid!
  name: String!
  updated_at: timestamptz!
}

"""
aggregated selection of "regions"
"""
type regions_aggregate {
  aggregate: regions_aggregate_fields
  nodes: [regions!]!
}

"""
aggregate fields of "regions"
"""
type regions_aggregate_fields {
  count(columns: [regions_select_column!], distinct: Boolean): Int!
  max: regions_max_fields
  min: regions_min_fields
}

"""
Boolean expression to filter rows from the table "regions". All fields are combined with a logical 'AND'.
"""
input regions_bool_exp {
  _and: [regions_bool_exp!]
  _not: regions_bool_exp
  _or: [regions_bool_exp!]
  code: String_comparison_exp
  created_at: timestamptz_comparison_exp
  deleted_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "regions"
"""
enum regions_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  regions_pkey
}

"""
input type for inserting data into table "regions"
"""
input regions_insert_input {
  code: String
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  name: String
  updated_at: timestamptz
}

"""aggregate max on columns"""
type regions_max_fields {
  code: String
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  name: String
  updated_at: timestamptz
}

"""aggregate min on columns"""
type regions_min_fields {
  code: String
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  name: String
  updated_at: timestamptz
}

"""
response of any mutation on the table "regions"
"""
type regions_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [regions!]!
}

"""
on_conflict condition type for table "regions"
"""
input regions_on_conflict {
  constraint: regions_constraint!
  update_columns: [regions_update_column!]! = []
  where: regions_bool_exp
}

"""Ordering options when selecting data from "regions"."""
input regions_order_by {
  code: order_by
  created_at: order_by
  deleted_at: order_by
  id: order_by
  name: order_by
  updated_at: order_by
}

"""primary key columns input for table: regions"""
input regions_pk_columns_input {
  id: uuid!
}

"""
select columns of table "regions"
"""
enum regions_select_column {
  """column name"""
  code

  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  name

  """column name"""
  updated_at
}

"""
input type for updating data in table "regions"
"""
input regions_set_input {
  code: String
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  name: String
  updated_at: timestamptz
}

"""
Streaming cursor of the table "regions"
"""
input regions_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: regions_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input regions_stream_cursor_value_input {
  code: String
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  name: String
  updated_at: timestamptz
}

"""
update columns of table "regions"
"""
enum regions_update_column {
  """column name"""
  code

  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  name

  """column name"""
  updated_at
}

input regions_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: regions_set_input

  """filter the rows which have to be updated"""
  where: regions_bool_exp!
}

"""
columns and relationships of "related_products"
"""
type related_products {
  created_at: timestamptz!
  deleted_at: timestamptz
  id: uuid!
  product_id: uuid
  related_product_id: uuid
  relationship_type: String!
  sort_order: Int!
  updated_at: timestamptz!
}

"""
aggregated selection of "related_products"
"""
type related_products_aggregate {
  aggregate: related_products_aggregate_fields
  nodes: [related_products!]!
}

"""
aggregate fields of "related_products"
"""
type related_products_aggregate_fields {
  avg: related_products_avg_fields
  count(columns: [related_products_select_column!], distinct: Boolean): Int!
  max: related_products_max_fields
  min: related_products_min_fields
  stddev: related_products_stddev_fields
  stddev_pop: related_products_stddev_pop_fields
  stddev_samp: related_products_stddev_samp_fields
  sum: related_products_sum_fields
  var_pop: related_products_var_pop_fields
  var_samp: related_products_var_samp_fields
  variance: related_products_variance_fields
}

"""aggregate avg on columns"""
type related_products_avg_fields {
  sort_order: Float
}

"""
Boolean expression to filter rows from the table "related_products". All fields are combined with a logical 'AND'.
"""
input related_products_bool_exp {
  _and: [related_products_bool_exp!]
  _not: related_products_bool_exp
  _or: [related_products_bool_exp!]
  created_at: timestamptz_comparison_exp
  deleted_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  product_id: uuid_comparison_exp
  related_product_id: uuid_comparison_exp
  relationship_type: String_comparison_exp
  sort_order: Int_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "related_products"
"""
enum related_products_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  related_products_pkey
}

"""
input type for incrementing numeric columns in table "related_products"
"""
input related_products_inc_input {
  sort_order: Int
}

"""
input type for inserting data into table "related_products"
"""
input related_products_insert_input {
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  product_id: uuid
  related_product_id: uuid
  relationship_type: String
  sort_order: Int
  updated_at: timestamptz
}

"""aggregate max on columns"""
type related_products_max_fields {
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  product_id: uuid
  related_product_id: uuid
  relationship_type: String
  sort_order: Int
  updated_at: timestamptz
}

"""aggregate min on columns"""
type related_products_min_fields {
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  product_id: uuid
  related_product_id: uuid
  relationship_type: String
  sort_order: Int
  updated_at: timestamptz
}

"""
response of any mutation on the table "related_products"
"""
type related_products_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [related_products!]!
}

"""
on_conflict condition type for table "related_products"
"""
input related_products_on_conflict {
  constraint: related_products_constraint!
  update_columns: [related_products_update_column!]! = []
  where: related_products_bool_exp
}

"""Ordering options when selecting data from "related_products"."""
input related_products_order_by {
  created_at: order_by
  deleted_at: order_by
  id: order_by
  product_id: order_by
  related_product_id: order_by
  relationship_type: order_by
  sort_order: order_by
  updated_at: order_by
}

"""primary key columns input for table: related_products"""
input related_products_pk_columns_input {
  id: uuid!
}

"""
select columns of table "related_products"
"""
enum related_products_select_column {
  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  product_id

  """column name"""
  related_product_id

  """column name"""
  relationship_type

  """column name"""
  sort_order

  """column name"""
  updated_at
}

"""
input type for updating data in table "related_products"
"""
input related_products_set_input {
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  product_id: uuid
  related_product_id: uuid
  relationship_type: String
  sort_order: Int
  updated_at: timestamptz
}

"""aggregate stddev on columns"""
type related_products_stddev_fields {
  sort_order: Float
}

"""aggregate stddev_pop on columns"""
type related_products_stddev_pop_fields {
  sort_order: Float
}

"""aggregate stddev_samp on columns"""
type related_products_stddev_samp_fields {
  sort_order: Float
}

"""
Streaming cursor of the table "related_products"
"""
input related_products_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: related_products_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input related_products_stream_cursor_value_input {
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  product_id: uuid
  related_product_id: uuid
  relationship_type: String
  sort_order: Int
  updated_at: timestamptz
}

"""aggregate sum on columns"""
type related_products_sum_fields {
  sort_order: Int
}

"""
update columns of table "related_products"
"""
enum related_products_update_column {
  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  product_id

  """column name"""
  related_product_id

  """column name"""
  relationship_type

  """column name"""
  sort_order

  """column name"""
  updated_at
}

input related_products_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: related_products_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: related_products_set_input

  """filter the rows which have to be updated"""
  where: related_products_bool_exp!
}

"""aggregate var_pop on columns"""
type related_products_var_pop_fields {
  sort_order: Float
}

"""aggregate var_samp on columns"""
type related_products_var_samp_fields {
  sort_order: Float
}

"""aggregate variance on columns"""
type related_products_variance_fields {
  sort_order: Float
}

"""
columns and relationships of "report_statuses"
"""
type report_statuses {
  code: String!
  created_at: timestamptz!
  deleted_at: timestamptz
  id: uuid!
  name: String!
  sort_order: Int!
  updated_at: timestamptz!
}

"""
aggregated selection of "report_statuses"
"""
type report_statuses_aggregate {
  aggregate: report_statuses_aggregate_fields
  nodes: [report_statuses!]!
}

"""
aggregate fields of "report_statuses"
"""
type report_statuses_aggregate_fields {
  avg: report_statuses_avg_fields
  count(columns: [report_statuses_select_column!], distinct: Boolean): Int!
  max: report_statuses_max_fields
  min: report_statuses_min_fields
  stddev: report_statuses_stddev_fields
  stddev_pop: report_statuses_stddev_pop_fields
  stddev_samp: report_statuses_stddev_samp_fields
  sum: report_statuses_sum_fields
  var_pop: report_statuses_var_pop_fields
  var_samp: report_statuses_var_samp_fields
  variance: report_statuses_variance_fields
}

"""aggregate avg on columns"""
type report_statuses_avg_fields {
  sort_order: Float
}

"""
Boolean expression to filter rows from the table "report_statuses". All fields are combined with a logical 'AND'.
"""
input report_statuses_bool_exp {
  _and: [report_statuses_bool_exp!]
  _not: report_statuses_bool_exp
  _or: [report_statuses_bool_exp!]
  code: String_comparison_exp
  created_at: timestamptz_comparison_exp
  deleted_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
  sort_order: Int_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "report_statuses"
"""
enum report_statuses_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  report_statuses_pkey
}

"""
input type for incrementing numeric columns in table "report_statuses"
"""
input report_statuses_inc_input {
  sort_order: Int
}

"""
input type for inserting data into table "report_statuses"
"""
input report_statuses_insert_input {
  code: String
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  name: String
  sort_order: Int
  updated_at: timestamptz
}

"""aggregate max on columns"""
type report_statuses_max_fields {
  code: String
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  name: String
  sort_order: Int
  updated_at: timestamptz
}

"""aggregate min on columns"""
type report_statuses_min_fields {
  code: String
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  name: String
  sort_order: Int
  updated_at: timestamptz
}

"""
response of any mutation on the table "report_statuses"
"""
type report_statuses_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [report_statuses!]!
}

"""
on_conflict condition type for table "report_statuses"
"""
input report_statuses_on_conflict {
  constraint: report_statuses_constraint!
  update_columns: [report_statuses_update_column!]! = []
  where: report_statuses_bool_exp
}

"""Ordering options when selecting data from "report_statuses"."""
input report_statuses_order_by {
  code: order_by
  created_at: order_by
  deleted_at: order_by
  id: order_by
  name: order_by
  sort_order: order_by
  updated_at: order_by
}

"""primary key columns input for table: report_statuses"""
input report_statuses_pk_columns_input {
  id: uuid!
}

"""
select columns of table "report_statuses"
"""
enum report_statuses_select_column {
  """column name"""
  code

  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  name

  """column name"""
  sort_order

  """column name"""
  updated_at
}

"""
input type for updating data in table "report_statuses"
"""
input report_statuses_set_input {
  code: String
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  name: String
  sort_order: Int
  updated_at: timestamptz
}

"""aggregate stddev on columns"""
type report_statuses_stddev_fields {
  sort_order: Float
}

"""aggregate stddev_pop on columns"""
type report_statuses_stddev_pop_fields {
  sort_order: Float
}

"""aggregate stddev_samp on columns"""
type report_statuses_stddev_samp_fields {
  sort_order: Float
}

"""
Streaming cursor of the table "report_statuses"
"""
input report_statuses_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: report_statuses_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input report_statuses_stream_cursor_value_input {
  code: String
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  name: String
  sort_order: Int
  updated_at: timestamptz
}

"""aggregate sum on columns"""
type report_statuses_sum_fields {
  sort_order: Int
}

"""
update columns of table "report_statuses"
"""
enum report_statuses_update_column {
  """column name"""
  code

  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  name

  """column name"""
  sort_order

  """column name"""
  updated_at
}

input report_statuses_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: report_statuses_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: report_statuses_set_input

  """filter the rows which have to be updated"""
  where: report_statuses_bool_exp!
}

"""aggregate var_pop on columns"""
type report_statuses_var_pop_fields {
  sort_order: Float
}

"""aggregate var_samp on columns"""
type report_statuses_var_samp_fields {
  sort_order: Float
}

"""aggregate variance on columns"""
type report_statuses_variance_fields {
  sort_order: Float
}

"""
columns and relationships of "reports"
"""
type reports {
  created_at: timestamptz!
  deleted_at: timestamptz
  description: String
  id: uuid!
  post_id: uuid
  reason: String!
  reporter_id: uuid
  resolved_at: timestamptz
  status_id: uuid
  updated_at: timestamptz!
}

"""
aggregated selection of "reports"
"""
type reports_aggregate {
  aggregate: reports_aggregate_fields
  nodes: [reports!]!
}

"""
aggregate fields of "reports"
"""
type reports_aggregate_fields {
  count(columns: [reports_select_column!], distinct: Boolean): Int!
  max: reports_max_fields
  min: reports_min_fields
}

"""
Boolean expression to filter rows from the table "reports". All fields are combined with a logical 'AND'.
"""
input reports_bool_exp {
  _and: [reports_bool_exp!]
  _not: reports_bool_exp
  _or: [reports_bool_exp!]
  created_at: timestamptz_comparison_exp
  deleted_at: timestamptz_comparison_exp
  description: String_comparison_exp
  id: uuid_comparison_exp
  post_id: uuid_comparison_exp
  reason: String_comparison_exp
  reporter_id: uuid_comparison_exp
  resolved_at: timestamptz_comparison_exp
  status_id: uuid_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "reports"
"""
enum reports_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  reports_pkey
}

"""
input type for inserting data into table "reports"
"""
input reports_insert_input {
  created_at: timestamptz
  deleted_at: timestamptz
  description: String
  id: uuid
  post_id: uuid
  reason: String
  reporter_id: uuid
  resolved_at: timestamptz
  status_id: uuid
  updated_at: timestamptz
}

"""aggregate max on columns"""
type reports_max_fields {
  created_at: timestamptz
  deleted_at: timestamptz
  description: String
  id: uuid
  post_id: uuid
  reason: String
  reporter_id: uuid
  resolved_at: timestamptz
  status_id: uuid
  updated_at: timestamptz
}

"""aggregate min on columns"""
type reports_min_fields {
  created_at: timestamptz
  deleted_at: timestamptz
  description: String
  id: uuid
  post_id: uuid
  reason: String
  reporter_id: uuid
  resolved_at: timestamptz
  status_id: uuid
  updated_at: timestamptz
}

"""
response of any mutation on the table "reports"
"""
type reports_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [reports!]!
}

"""
on_conflict condition type for table "reports"
"""
input reports_on_conflict {
  constraint: reports_constraint!
  update_columns: [reports_update_column!]! = []
  where: reports_bool_exp
}

"""Ordering options when selecting data from "reports"."""
input reports_order_by {
  created_at: order_by
  deleted_at: order_by
  description: order_by
  id: order_by
  post_id: order_by
  reason: order_by
  reporter_id: order_by
  resolved_at: order_by
  status_id: order_by
  updated_at: order_by
}

"""primary key columns input for table: reports"""
input reports_pk_columns_input {
  id: uuid!
}

"""
select columns of table "reports"
"""
enum reports_select_column {
  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  description

  """column name"""
  id

  """column name"""
  post_id

  """column name"""
  reason

  """column name"""
  reporter_id

  """column name"""
  resolved_at

  """column name"""
  status_id

  """column name"""
  updated_at
}

"""
input type for updating data in table "reports"
"""
input reports_set_input {
  created_at: timestamptz
  deleted_at: timestamptz
  description: String
  id: uuid
  post_id: uuid
  reason: String
  reporter_id: uuid
  resolved_at: timestamptz
  status_id: uuid
  updated_at: timestamptz
}

"""
Streaming cursor of the table "reports"
"""
input reports_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: reports_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input reports_stream_cursor_value_input {
  created_at: timestamptz
  deleted_at: timestamptz
  description: String
  id: uuid
  post_id: uuid
  reason: String
  reporter_id: uuid
  resolved_at: timestamptz
  status_id: uuid
  updated_at: timestamptz
}

"""
update columns of table "reports"
"""
enum reports_update_column {
  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  description

  """column name"""
  id

  """column name"""
  post_id

  """column name"""
  reason

  """column name"""
  reporter_id

  """column name"""
  resolved_at

  """column name"""
  status_id

  """column name"""
  updated_at
}

input reports_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: reports_set_input

  """filter the rows which have to be updated"""
  where: reports_bool_exp!
}

"""
columns and relationships of "return_requests"
"""
type return_requests {
  created_at: timestamptz!
  deleted_at: timestamptz
  id: uuid!
  notes: String
  order_id: uuid
  reason: String!
  status_id: uuid
  updated_at: timestamptz!
}

"""
aggregated selection of "return_requests"
"""
type return_requests_aggregate {
  aggregate: return_requests_aggregate_fields
  nodes: [return_requests!]!
}

"""
aggregate fields of "return_requests"
"""
type return_requests_aggregate_fields {
  count(columns: [return_requests_select_column!], distinct: Boolean): Int!
  max: return_requests_max_fields
  min: return_requests_min_fields
}

"""
Boolean expression to filter rows from the table "return_requests". All fields are combined with a logical 'AND'.
"""
input return_requests_bool_exp {
  _and: [return_requests_bool_exp!]
  _not: return_requests_bool_exp
  _or: [return_requests_bool_exp!]
  created_at: timestamptz_comparison_exp
  deleted_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  notes: String_comparison_exp
  order_id: uuid_comparison_exp
  reason: String_comparison_exp
  status_id: uuid_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "return_requests"
"""
enum return_requests_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  return_requests_pkey
}

"""
input type for inserting data into table "return_requests"
"""
input return_requests_insert_input {
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  notes: String
  order_id: uuid
  reason: String
  status_id: uuid
  updated_at: timestamptz
}

"""aggregate max on columns"""
type return_requests_max_fields {
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  notes: String
  order_id: uuid
  reason: String
  status_id: uuid
  updated_at: timestamptz
}

"""aggregate min on columns"""
type return_requests_min_fields {
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  notes: String
  order_id: uuid
  reason: String
  status_id: uuid
  updated_at: timestamptz
}

"""
response of any mutation on the table "return_requests"
"""
type return_requests_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [return_requests!]!
}

"""
on_conflict condition type for table "return_requests"
"""
input return_requests_on_conflict {
  constraint: return_requests_constraint!
  update_columns: [return_requests_update_column!]! = []
  where: return_requests_bool_exp
}

"""Ordering options when selecting data from "return_requests"."""
input return_requests_order_by {
  created_at: order_by
  deleted_at: order_by
  id: order_by
  notes: order_by
  order_id: order_by
  reason: order_by
  status_id: order_by
  updated_at: order_by
}

"""primary key columns input for table: return_requests"""
input return_requests_pk_columns_input {
  id: uuid!
}

"""
select columns of table "return_requests"
"""
enum return_requests_select_column {
  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  notes

  """column name"""
  order_id

  """column name"""
  reason

  """column name"""
  status_id

  """column name"""
  updated_at
}

"""
input type for updating data in table "return_requests"
"""
input return_requests_set_input {
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  notes: String
  order_id: uuid
  reason: String
  status_id: uuid
  updated_at: timestamptz
}

"""
Streaming cursor of the table "return_requests"
"""
input return_requests_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: return_requests_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input return_requests_stream_cursor_value_input {
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  notes: String
  order_id: uuid
  reason: String
  status_id: uuid
  updated_at: timestamptz
}

"""
update columns of table "return_requests"
"""
enum return_requests_update_column {
  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  notes

  """column name"""
  order_id

  """column name"""
  reason

  """column name"""
  status_id

  """column name"""
  updated_at
}

input return_requests_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: return_requests_set_input

  """filter the rows which have to be updated"""
  where: return_requests_bool_exp!
}

"""
columns and relationships of "return_statuses"
"""
type return_statuses {
  code: String!
  created_at: timestamptz!
  deleted_at: timestamptz
  id: uuid!
  name: String!
  sort_order: Int!
  updated_at: timestamptz!
}

"""
aggregated selection of "return_statuses"
"""
type return_statuses_aggregate {
  aggregate: return_statuses_aggregate_fields
  nodes: [return_statuses!]!
}

"""
aggregate fields of "return_statuses"
"""
type return_statuses_aggregate_fields {
  avg: return_statuses_avg_fields
  count(columns: [return_statuses_select_column!], distinct: Boolean): Int!
  max: return_statuses_max_fields
  min: return_statuses_min_fields
  stddev: return_statuses_stddev_fields
  stddev_pop: return_statuses_stddev_pop_fields
  stddev_samp: return_statuses_stddev_samp_fields
  sum: return_statuses_sum_fields
  var_pop: return_statuses_var_pop_fields
  var_samp: return_statuses_var_samp_fields
  variance: return_statuses_variance_fields
}

"""aggregate avg on columns"""
type return_statuses_avg_fields {
  sort_order: Float
}

"""
Boolean expression to filter rows from the table "return_statuses". All fields are combined with a logical 'AND'.
"""
input return_statuses_bool_exp {
  _and: [return_statuses_bool_exp!]
  _not: return_statuses_bool_exp
  _or: [return_statuses_bool_exp!]
  code: String_comparison_exp
  created_at: timestamptz_comparison_exp
  deleted_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
  sort_order: Int_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "return_statuses"
"""
enum return_statuses_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  return_statuses_pkey
}

"""
input type for incrementing numeric columns in table "return_statuses"
"""
input return_statuses_inc_input {
  sort_order: Int
}

"""
input type for inserting data into table "return_statuses"
"""
input return_statuses_insert_input {
  code: String
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  name: String
  sort_order: Int
  updated_at: timestamptz
}

"""aggregate max on columns"""
type return_statuses_max_fields {
  code: String
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  name: String
  sort_order: Int
  updated_at: timestamptz
}

"""aggregate min on columns"""
type return_statuses_min_fields {
  code: String
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  name: String
  sort_order: Int
  updated_at: timestamptz
}

"""
response of any mutation on the table "return_statuses"
"""
type return_statuses_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [return_statuses!]!
}

"""
on_conflict condition type for table "return_statuses"
"""
input return_statuses_on_conflict {
  constraint: return_statuses_constraint!
  update_columns: [return_statuses_update_column!]! = []
  where: return_statuses_bool_exp
}

"""Ordering options when selecting data from "return_statuses"."""
input return_statuses_order_by {
  code: order_by
  created_at: order_by
  deleted_at: order_by
  id: order_by
  name: order_by
  sort_order: order_by
  updated_at: order_by
}

"""primary key columns input for table: return_statuses"""
input return_statuses_pk_columns_input {
  id: uuid!
}

"""
select columns of table "return_statuses"
"""
enum return_statuses_select_column {
  """column name"""
  code

  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  name

  """column name"""
  sort_order

  """column name"""
  updated_at
}

"""
input type for updating data in table "return_statuses"
"""
input return_statuses_set_input {
  code: String
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  name: String
  sort_order: Int
  updated_at: timestamptz
}

"""aggregate stddev on columns"""
type return_statuses_stddev_fields {
  sort_order: Float
}

"""aggregate stddev_pop on columns"""
type return_statuses_stddev_pop_fields {
  sort_order: Float
}

"""aggregate stddev_samp on columns"""
type return_statuses_stddev_samp_fields {
  sort_order: Float
}

"""
Streaming cursor of the table "return_statuses"
"""
input return_statuses_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: return_statuses_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input return_statuses_stream_cursor_value_input {
  code: String
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  name: String
  sort_order: Int
  updated_at: timestamptz
}

"""aggregate sum on columns"""
type return_statuses_sum_fields {
  sort_order: Int
}

"""
update columns of table "return_statuses"
"""
enum return_statuses_update_column {
  """column name"""
  code

  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  name

  """column name"""
  sort_order

  """column name"""
  updated_at
}

input return_statuses_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: return_statuses_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: return_statuses_set_input

  """filter the rows which have to be updated"""
  where: return_statuses_bool_exp!
}

"""aggregate var_pop on columns"""
type return_statuses_var_pop_fields {
  sort_order: Float
}

"""aggregate var_samp on columns"""
type return_statuses_var_samp_fields {
  sort_order: Float
}

"""aggregate variance on columns"""
type return_statuses_variance_fields {
  sort_order: Float
}

"""
columns and relationships of "reviews"
"""
type reviews {
  body: String
  created_at: timestamptz!
  customer_id: uuid
  deleted_at: timestamptz
  id: uuid!
  is_verified: Boolean!
  order_item_id: uuid
  product_id: uuid
  rating: Int!
  title: String
  updated_at: timestamptz!
}

"""
aggregated selection of "reviews"
"""
type reviews_aggregate {
  aggregate: reviews_aggregate_fields
  nodes: [reviews!]!
}

"""
aggregate fields of "reviews"
"""
type reviews_aggregate_fields {
  avg: reviews_avg_fields
  count(columns: [reviews_select_column!], distinct: Boolean): Int!
  max: reviews_max_fields
  min: reviews_min_fields
  stddev: reviews_stddev_fields
  stddev_pop: reviews_stddev_pop_fields
  stddev_samp: reviews_stddev_samp_fields
  sum: reviews_sum_fields
  var_pop: reviews_var_pop_fields
  var_samp: reviews_var_samp_fields
  variance: reviews_variance_fields
}

"""aggregate avg on columns"""
type reviews_avg_fields {
  rating: Float
}

"""
Boolean expression to filter rows from the table "reviews". All fields are combined with a logical 'AND'.
"""
input reviews_bool_exp {
  _and: [reviews_bool_exp!]
  _not: reviews_bool_exp
  _or: [reviews_bool_exp!]
  body: String_comparison_exp
  created_at: timestamptz_comparison_exp
  customer_id: uuid_comparison_exp
  deleted_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  is_verified: Boolean_comparison_exp
  order_item_id: uuid_comparison_exp
  product_id: uuid_comparison_exp
  rating: Int_comparison_exp
  title: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "reviews"
"""
enum reviews_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  reviews_pkey
}

"""
input type for incrementing numeric columns in table "reviews"
"""
input reviews_inc_input {
  rating: Int
}

"""
input type for inserting data into table "reviews"
"""
input reviews_insert_input {
  body: String
  created_at: timestamptz
  customer_id: uuid
  deleted_at: timestamptz
  id: uuid
  is_verified: Boolean
  order_item_id: uuid
  product_id: uuid
  rating: Int
  title: String
  updated_at: timestamptz
}

"""aggregate max on columns"""
type reviews_max_fields {
  body: String
  created_at: timestamptz
  customer_id: uuid
  deleted_at: timestamptz
  id: uuid
  order_item_id: uuid
  product_id: uuid
  rating: Int
  title: String
  updated_at: timestamptz
}

"""aggregate min on columns"""
type reviews_min_fields {
  body: String
  created_at: timestamptz
  customer_id: uuid
  deleted_at: timestamptz
  id: uuid
  order_item_id: uuid
  product_id: uuid
  rating: Int
  title: String
  updated_at: timestamptz
}

"""
response of any mutation on the table "reviews"
"""
type reviews_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [reviews!]!
}

"""
on_conflict condition type for table "reviews"
"""
input reviews_on_conflict {
  constraint: reviews_constraint!
  update_columns: [reviews_update_column!]! = []
  where: reviews_bool_exp
}

"""Ordering options when selecting data from "reviews"."""
input reviews_order_by {
  body: order_by
  created_at: order_by
  customer_id: order_by
  deleted_at: order_by
  id: order_by
  is_verified: order_by
  order_item_id: order_by
  product_id: order_by
  rating: order_by
  title: order_by
  updated_at: order_by
}

"""primary key columns input for table: reviews"""
input reviews_pk_columns_input {
  id: uuid!
}

"""
select columns of table "reviews"
"""
enum reviews_select_column {
  """column name"""
  body

  """column name"""
  created_at

  """column name"""
  customer_id

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  is_verified

  """column name"""
  order_item_id

  """column name"""
  product_id

  """column name"""
  rating

  """column name"""
  title

  """column name"""
  updated_at
}

"""
input type for updating data in table "reviews"
"""
input reviews_set_input {
  body: String
  created_at: timestamptz
  customer_id: uuid
  deleted_at: timestamptz
  id: uuid
  is_verified: Boolean
  order_item_id: uuid
  product_id: uuid
  rating: Int
  title: String
  updated_at: timestamptz
}

"""aggregate stddev on columns"""
type reviews_stddev_fields {
  rating: Float
}

"""aggregate stddev_pop on columns"""
type reviews_stddev_pop_fields {
  rating: Float
}

"""aggregate stddev_samp on columns"""
type reviews_stddev_samp_fields {
  rating: Float
}

"""
Streaming cursor of the table "reviews"
"""
input reviews_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: reviews_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input reviews_stream_cursor_value_input {
  body: String
  created_at: timestamptz
  customer_id: uuid
  deleted_at: timestamptz
  id: uuid
  is_verified: Boolean
  order_item_id: uuid
  product_id: uuid
  rating: Int
  title: String
  updated_at: timestamptz
}

"""aggregate sum on columns"""
type reviews_sum_fields {
  rating: Int
}

"""
update columns of table "reviews"
"""
enum reviews_update_column {
  """column name"""
  body

  """column name"""
  created_at

  """column name"""
  customer_id

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  is_verified

  """column name"""
  order_item_id

  """column name"""
  product_id

  """column name"""
  rating

  """column name"""
  title

  """column name"""
  updated_at
}

input reviews_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: reviews_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: reviews_set_input

  """filter the rows which have to be updated"""
  where: reviews_bool_exp!
}

"""aggregate var_pop on columns"""
type reviews_var_pop_fields {
  rating: Float
}

"""aggregate var_samp on columns"""
type reviews_var_samp_fields {
  rating: Float
}

"""aggregate variance on columns"""
type reviews_variance_fields {
  rating: Float
}

"""
columns and relationships of "role_permissions"
"""
type role_permissions {
  created_at: timestamptz!
  deleted_at: timestamptz
  id: uuid!
  permission_id: uuid
  role_id: uuid
  updated_at: timestamptz!
}

"""
aggregated selection of "role_permissions"
"""
type role_permissions_aggregate {
  aggregate: role_permissions_aggregate_fields
  nodes: [role_permissions!]!
}

"""
aggregate fields of "role_permissions"
"""
type role_permissions_aggregate_fields {
  count(columns: [role_permissions_select_column!], distinct: Boolean): Int!
  max: role_permissions_max_fields
  min: role_permissions_min_fields
}

"""
Boolean expression to filter rows from the table "role_permissions". All fields are combined with a logical 'AND'.
"""
input role_permissions_bool_exp {
  _and: [role_permissions_bool_exp!]
  _not: role_permissions_bool_exp
  _or: [role_permissions_bool_exp!]
  created_at: timestamptz_comparison_exp
  deleted_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  permission_id: uuid_comparison_exp
  role_id: uuid_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "role_permissions"
"""
enum role_permissions_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  role_permissions_pkey
}

"""
input type for inserting data into table "role_permissions"
"""
input role_permissions_insert_input {
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  permission_id: uuid
  role_id: uuid
  updated_at: timestamptz
}

"""aggregate max on columns"""
type role_permissions_max_fields {
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  permission_id: uuid
  role_id: uuid
  updated_at: timestamptz
}

"""aggregate min on columns"""
type role_permissions_min_fields {
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  permission_id: uuid
  role_id: uuid
  updated_at: timestamptz
}

"""
response of any mutation on the table "role_permissions"
"""
type role_permissions_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [role_permissions!]!
}

"""
on_conflict condition type for table "role_permissions"
"""
input role_permissions_on_conflict {
  constraint: role_permissions_constraint!
  update_columns: [role_permissions_update_column!]! = []
  where: role_permissions_bool_exp
}

"""Ordering options when selecting data from "role_permissions"."""
input role_permissions_order_by {
  created_at: order_by
  deleted_at: order_by
  id: order_by
  permission_id: order_by
  role_id: order_by
  updated_at: order_by
}

"""primary key columns input for table: role_permissions"""
input role_permissions_pk_columns_input {
  id: uuid!
}

"""
select columns of table "role_permissions"
"""
enum role_permissions_select_column {
  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  permission_id

  """column name"""
  role_id

  """column name"""
  updated_at
}

"""
input type for updating data in table "role_permissions"
"""
input role_permissions_set_input {
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  permission_id: uuid
  role_id: uuid
  updated_at: timestamptz
}

"""
Streaming cursor of the table "role_permissions"
"""
input role_permissions_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: role_permissions_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input role_permissions_stream_cursor_value_input {
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  permission_id: uuid
  role_id: uuid
  updated_at: timestamptz
}

"""
update columns of table "role_permissions"
"""
enum role_permissions_update_column {
  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  permission_id

  """column name"""
  role_id

  """column name"""
  updated_at
}

input role_permissions_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: role_permissions_set_input

  """filter the rows which have to be updated"""
  where: role_permissions_bool_exp!
}

"""
columns and relationships of "roles"
"""
type roles {
  code: String!
  created_at: timestamptz!
  deleted_at: timestamptz
  description: String
  id: uuid!
  name: String!
  updated_at: timestamptz!
}

"""
aggregated selection of "roles"
"""
type roles_aggregate {
  aggregate: roles_aggregate_fields
  nodes: [roles!]!
}

"""
aggregate fields of "roles"
"""
type roles_aggregate_fields {
  count(columns: [roles_select_column!], distinct: Boolean): Int!
  max: roles_max_fields
  min: roles_min_fields
}

"""
Boolean expression to filter rows from the table "roles". All fields are combined with a logical 'AND'.
"""
input roles_bool_exp {
  _and: [roles_bool_exp!]
  _not: roles_bool_exp
  _or: [roles_bool_exp!]
  code: String_comparison_exp
  created_at: timestamptz_comparison_exp
  deleted_at: timestamptz_comparison_exp
  description: String_comparison_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "roles"
"""
enum roles_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  roles_pkey
}

"""
input type for inserting data into table "roles"
"""
input roles_insert_input {
  code: String
  created_at: timestamptz
  deleted_at: timestamptz
  description: String
  id: uuid
  name: String
  updated_at: timestamptz
}

"""aggregate max on columns"""
type roles_max_fields {
  code: String
  created_at: timestamptz
  deleted_at: timestamptz
  description: String
  id: uuid
  name: String
  updated_at: timestamptz
}

"""aggregate min on columns"""
type roles_min_fields {
  code: String
  created_at: timestamptz
  deleted_at: timestamptz
  description: String
  id: uuid
  name: String
  updated_at: timestamptz
}

"""
response of any mutation on the table "roles"
"""
type roles_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [roles!]!
}

"""
on_conflict condition type for table "roles"
"""
input roles_on_conflict {
  constraint: roles_constraint!
  update_columns: [roles_update_column!]! = []
  where: roles_bool_exp
}

"""Ordering options when selecting data from "roles"."""
input roles_order_by {
  code: order_by
  created_at: order_by
  deleted_at: order_by
  description: order_by
  id: order_by
  name: order_by
  updated_at: order_by
}

"""primary key columns input for table: roles"""
input roles_pk_columns_input {
  id: uuid!
}

"""
select columns of table "roles"
"""
enum roles_select_column {
  """column name"""
  code

  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  description

  """column name"""
  id

  """column name"""
  name

  """column name"""
  updated_at
}

"""
input type for updating data in table "roles"
"""
input roles_set_input {
  code: String
  created_at: timestamptz
  deleted_at: timestamptz
  description: String
  id: uuid
  name: String
  updated_at: timestamptz
}

"""
Streaming cursor of the table "roles"
"""
input roles_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: roles_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input roles_stream_cursor_value_input {
  code: String
  created_at: timestamptz
  deleted_at: timestamptz
  description: String
  id: uuid
  name: String
  updated_at: timestamptz
}

"""
update columns of table "roles"
"""
enum roles_update_column {
  """column name"""
  code

  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  description

  """column name"""
  id

  """column name"""
  name

  """column name"""
  updated_at
}

input roles_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: roles_set_input

  """filter the rows which have to be updated"""
  where: roles_bool_exp!
}

"""
columns and relationships of "seo_settings"
"""
type seo_settings {
  created_at: timestamptz!
  default_description: String
  default_title: String
  deleted_at: timestamptz
  id: uuid!
  og_image_url: String
  robots_txt: String
  site_id: uuid
  title_template: String
  updated_at: timestamptz!
}

"""
aggregated selection of "seo_settings"
"""
type seo_settings_aggregate {
  aggregate: seo_settings_aggregate_fields
  nodes: [seo_settings!]!
}

"""
aggregate fields of "seo_settings"
"""
type seo_settings_aggregate_fields {
  count(columns: [seo_settings_select_column!], distinct: Boolean): Int!
  max: seo_settings_max_fields
  min: seo_settings_min_fields
}

"""
Boolean expression to filter rows from the table "seo_settings". All fields are combined with a logical 'AND'.
"""
input seo_settings_bool_exp {
  _and: [seo_settings_bool_exp!]
  _not: seo_settings_bool_exp
  _or: [seo_settings_bool_exp!]
  created_at: timestamptz_comparison_exp
  default_description: String_comparison_exp
  default_title: String_comparison_exp
  deleted_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  og_image_url: String_comparison_exp
  robots_txt: String_comparison_exp
  site_id: uuid_comparison_exp
  title_template: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "seo_settings"
"""
enum seo_settings_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  seo_settings_pkey
}

"""
input type for inserting data into table "seo_settings"
"""
input seo_settings_insert_input {
  created_at: timestamptz
  default_description: String
  default_title: String
  deleted_at: timestamptz
  id: uuid
  og_image_url: String
  robots_txt: String
  site_id: uuid
  title_template: String
  updated_at: timestamptz
}

"""aggregate max on columns"""
type seo_settings_max_fields {
  created_at: timestamptz
  default_description: String
  default_title: String
  deleted_at: timestamptz
  id: uuid
  og_image_url: String
  robots_txt: String
  site_id: uuid
  title_template: String
  updated_at: timestamptz
}

"""aggregate min on columns"""
type seo_settings_min_fields {
  created_at: timestamptz
  default_description: String
  default_title: String
  deleted_at: timestamptz
  id: uuid
  og_image_url: String
  robots_txt: String
  site_id: uuid
  title_template: String
  updated_at: timestamptz
}

"""
response of any mutation on the table "seo_settings"
"""
type seo_settings_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [seo_settings!]!
}

"""
on_conflict condition type for table "seo_settings"
"""
input seo_settings_on_conflict {
  constraint: seo_settings_constraint!
  update_columns: [seo_settings_update_column!]! = []
  where: seo_settings_bool_exp
}

"""Ordering options when selecting data from "seo_settings"."""
input seo_settings_order_by {
  created_at: order_by
  default_description: order_by
  default_title: order_by
  deleted_at: order_by
  id: order_by
  og_image_url: order_by
  robots_txt: order_by
  site_id: order_by
  title_template: order_by
  updated_at: order_by
}

"""primary key columns input for table: seo_settings"""
input seo_settings_pk_columns_input {
  id: uuid!
}

"""
select columns of table "seo_settings"
"""
enum seo_settings_select_column {
  """column name"""
  created_at

  """column name"""
  default_description

  """column name"""
  default_title

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  og_image_url

  """column name"""
  robots_txt

  """column name"""
  site_id

  """column name"""
  title_template

  """column name"""
  updated_at
}

"""
input type for updating data in table "seo_settings"
"""
input seo_settings_set_input {
  created_at: timestamptz
  default_description: String
  default_title: String
  deleted_at: timestamptz
  id: uuid
  og_image_url: String
  robots_txt: String
  site_id: uuid
  title_template: String
  updated_at: timestamptz
}

"""
Streaming cursor of the table "seo_settings"
"""
input seo_settings_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: seo_settings_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input seo_settings_stream_cursor_value_input {
  created_at: timestamptz
  default_description: String
  default_title: String
  deleted_at: timestamptz
  id: uuid
  og_image_url: String
  robots_txt: String
  site_id: uuid
  title_template: String
  updated_at: timestamptz
}

"""
update columns of table "seo_settings"
"""
enum seo_settings_update_column {
  """column name"""
  created_at

  """column name"""
  default_description

  """column name"""
  default_title

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  og_image_url

  """column name"""
  robots_txt

  """column name"""
  site_id

  """column name"""
  title_template

  """column name"""
  updated_at
}

input seo_settings_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: seo_settings_set_input

  """filter the rows which have to be updated"""
  where: seo_settings_bool_exp!
}

"""
columns and relationships of "shipment_statuses"
"""
type shipment_statuses {
  code: String!
  created_at: timestamptz!
  deleted_at: timestamptz
  id: uuid!
  name: String!
  sort_order: Int!
  updated_at: timestamptz!
}

"""
aggregated selection of "shipment_statuses"
"""
type shipment_statuses_aggregate {
  aggregate: shipment_statuses_aggregate_fields
  nodes: [shipment_statuses!]!
}

"""
aggregate fields of "shipment_statuses"
"""
type shipment_statuses_aggregate_fields {
  avg: shipment_statuses_avg_fields
  count(columns: [shipment_statuses_select_column!], distinct: Boolean): Int!
  max: shipment_statuses_max_fields
  min: shipment_statuses_min_fields
  stddev: shipment_statuses_stddev_fields
  stddev_pop: shipment_statuses_stddev_pop_fields
  stddev_samp: shipment_statuses_stddev_samp_fields
  sum: shipment_statuses_sum_fields
  var_pop: shipment_statuses_var_pop_fields
  var_samp: shipment_statuses_var_samp_fields
  variance: shipment_statuses_variance_fields
}

"""aggregate avg on columns"""
type shipment_statuses_avg_fields {
  sort_order: Float
}

"""
Boolean expression to filter rows from the table "shipment_statuses". All fields are combined with a logical 'AND'.
"""
input shipment_statuses_bool_exp {
  _and: [shipment_statuses_bool_exp!]
  _not: shipment_statuses_bool_exp
  _or: [shipment_statuses_bool_exp!]
  code: String_comparison_exp
  created_at: timestamptz_comparison_exp
  deleted_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
  sort_order: Int_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "shipment_statuses"
"""
enum shipment_statuses_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  shipment_statuses_pkey
}

"""
input type for incrementing numeric columns in table "shipment_statuses"
"""
input shipment_statuses_inc_input {
  sort_order: Int
}

"""
input type for inserting data into table "shipment_statuses"
"""
input shipment_statuses_insert_input {
  code: String
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  name: String
  sort_order: Int
  updated_at: timestamptz
}

"""aggregate max on columns"""
type shipment_statuses_max_fields {
  code: String
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  name: String
  sort_order: Int
  updated_at: timestamptz
}

"""aggregate min on columns"""
type shipment_statuses_min_fields {
  code: String
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  name: String
  sort_order: Int
  updated_at: timestamptz
}

"""
response of any mutation on the table "shipment_statuses"
"""
type shipment_statuses_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [shipment_statuses!]!
}

"""
on_conflict condition type for table "shipment_statuses"
"""
input shipment_statuses_on_conflict {
  constraint: shipment_statuses_constraint!
  update_columns: [shipment_statuses_update_column!]! = []
  where: shipment_statuses_bool_exp
}

"""Ordering options when selecting data from "shipment_statuses"."""
input shipment_statuses_order_by {
  code: order_by
  created_at: order_by
  deleted_at: order_by
  id: order_by
  name: order_by
  sort_order: order_by
  updated_at: order_by
}

"""primary key columns input for table: shipment_statuses"""
input shipment_statuses_pk_columns_input {
  id: uuid!
}

"""
select columns of table "shipment_statuses"
"""
enum shipment_statuses_select_column {
  """column name"""
  code

  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  name

  """column name"""
  sort_order

  """column name"""
  updated_at
}

"""
input type for updating data in table "shipment_statuses"
"""
input shipment_statuses_set_input {
  code: String
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  name: String
  sort_order: Int
  updated_at: timestamptz
}

"""aggregate stddev on columns"""
type shipment_statuses_stddev_fields {
  sort_order: Float
}

"""aggregate stddev_pop on columns"""
type shipment_statuses_stddev_pop_fields {
  sort_order: Float
}

"""aggregate stddev_samp on columns"""
type shipment_statuses_stddev_samp_fields {
  sort_order: Float
}

"""
Streaming cursor of the table "shipment_statuses"
"""
input shipment_statuses_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: shipment_statuses_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input shipment_statuses_stream_cursor_value_input {
  code: String
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  name: String
  sort_order: Int
  updated_at: timestamptz
}

"""aggregate sum on columns"""
type shipment_statuses_sum_fields {
  sort_order: Int
}

"""
update columns of table "shipment_statuses"
"""
enum shipment_statuses_update_column {
  """column name"""
  code

  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  name

  """column name"""
  sort_order

  """column name"""
  updated_at
}

input shipment_statuses_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: shipment_statuses_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: shipment_statuses_set_input

  """filter the rows which have to be updated"""
  where: shipment_statuses_bool_exp!
}

"""aggregate var_pop on columns"""
type shipment_statuses_var_pop_fields {
  sort_order: Float
}

"""aggregate var_samp on columns"""
type shipment_statuses_var_samp_fields {
  sort_order: Float
}

"""aggregate variance on columns"""
type shipment_statuses_variance_fields {
  sort_order: Float
}

"""
columns and relationships of "shipments"
"""
type shipments {
  carrier_id: uuid
  created_at: timestamptz!
  deleted_at: timestamptz
  delivered_at: timestamptz
  id: uuid!
  order_id: uuid
  shipped_at: timestamptz
  status_id: uuid
  tracking_number: String
  updated_at: timestamptz!
}

"""
aggregated selection of "shipments"
"""
type shipments_aggregate {
  aggregate: shipments_aggregate_fields
  nodes: [shipments!]!
}

"""
aggregate fields of "shipments"
"""
type shipments_aggregate_fields {
  count(columns: [shipments_select_column!], distinct: Boolean): Int!
  max: shipments_max_fields
  min: shipments_min_fields
}

"""
Boolean expression to filter rows from the table "shipments". All fields are combined with a logical 'AND'.
"""
input shipments_bool_exp {
  _and: [shipments_bool_exp!]
  _not: shipments_bool_exp
  _or: [shipments_bool_exp!]
  carrier_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  deleted_at: timestamptz_comparison_exp
  delivered_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  order_id: uuid_comparison_exp
  shipped_at: timestamptz_comparison_exp
  status_id: uuid_comparison_exp
  tracking_number: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "shipments"
"""
enum shipments_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  shipments_pkey
}

"""
input type for inserting data into table "shipments"
"""
input shipments_insert_input {
  carrier_id: uuid
  created_at: timestamptz
  deleted_at: timestamptz
  delivered_at: timestamptz
  id: uuid
  order_id: uuid
  shipped_at: timestamptz
  status_id: uuid
  tracking_number: String
  updated_at: timestamptz
}

"""aggregate max on columns"""
type shipments_max_fields {
  carrier_id: uuid
  created_at: timestamptz
  deleted_at: timestamptz
  delivered_at: timestamptz
  id: uuid
  order_id: uuid
  shipped_at: timestamptz
  status_id: uuid
  tracking_number: String
  updated_at: timestamptz
}

"""aggregate min on columns"""
type shipments_min_fields {
  carrier_id: uuid
  created_at: timestamptz
  deleted_at: timestamptz
  delivered_at: timestamptz
  id: uuid
  order_id: uuid
  shipped_at: timestamptz
  status_id: uuid
  tracking_number: String
  updated_at: timestamptz
}

"""
response of any mutation on the table "shipments"
"""
type shipments_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [shipments!]!
}

"""
on_conflict condition type for table "shipments"
"""
input shipments_on_conflict {
  constraint: shipments_constraint!
  update_columns: [shipments_update_column!]! = []
  where: shipments_bool_exp
}

"""Ordering options when selecting data from "shipments"."""
input shipments_order_by {
  carrier_id: order_by
  created_at: order_by
  deleted_at: order_by
  delivered_at: order_by
  id: order_by
  order_id: order_by
  shipped_at: order_by
  status_id: order_by
  tracking_number: order_by
  updated_at: order_by
}

"""primary key columns input for table: shipments"""
input shipments_pk_columns_input {
  id: uuid!
}

"""
select columns of table "shipments"
"""
enum shipments_select_column {
  """column name"""
  carrier_id

  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  delivered_at

  """column name"""
  id

  """column name"""
  order_id

  """column name"""
  shipped_at

  """column name"""
  status_id

  """column name"""
  tracking_number

  """column name"""
  updated_at
}

"""
input type for updating data in table "shipments"
"""
input shipments_set_input {
  carrier_id: uuid
  created_at: timestamptz
  deleted_at: timestamptz
  delivered_at: timestamptz
  id: uuid
  order_id: uuid
  shipped_at: timestamptz
  status_id: uuid
  tracking_number: String
  updated_at: timestamptz
}

"""
Streaming cursor of the table "shipments"
"""
input shipments_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: shipments_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input shipments_stream_cursor_value_input {
  carrier_id: uuid
  created_at: timestamptz
  deleted_at: timestamptz
  delivered_at: timestamptz
  id: uuid
  order_id: uuid
  shipped_at: timestamptz
  status_id: uuid
  tracking_number: String
  updated_at: timestamptz
}

"""
update columns of table "shipments"
"""
enum shipments_update_column {
  """column name"""
  carrier_id

  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  delivered_at

  """column name"""
  id

  """column name"""
  order_id

  """column name"""
  shipped_at

  """column name"""
  status_id

  """column name"""
  tracking_number

  """column name"""
  updated_at
}

input shipments_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: shipments_set_input

  """filter the rows which have to be updated"""
  where: shipments_bool_exp!
}

"""
columns and relationships of "shipping_carriers"
"""
type shipping_carriers {
  code: String!
  created_at: timestamptz!
  deleted_at: timestamptz
  id: uuid!
  name: String!
  tracking_url_template: String
  updated_at: timestamptz!
}

"""
aggregated selection of "shipping_carriers"
"""
type shipping_carriers_aggregate {
  aggregate: shipping_carriers_aggregate_fields
  nodes: [shipping_carriers!]!
}

"""
aggregate fields of "shipping_carriers"
"""
type shipping_carriers_aggregate_fields {
  count(columns: [shipping_carriers_select_column!], distinct: Boolean): Int!
  max: shipping_carriers_max_fields
  min: shipping_carriers_min_fields
}

"""
Boolean expression to filter rows from the table "shipping_carriers". All fields are combined with a logical 'AND'.
"""
input shipping_carriers_bool_exp {
  _and: [shipping_carriers_bool_exp!]
  _not: shipping_carriers_bool_exp
  _or: [shipping_carriers_bool_exp!]
  code: String_comparison_exp
  created_at: timestamptz_comparison_exp
  deleted_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
  tracking_url_template: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "shipping_carriers"
"""
enum shipping_carriers_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  shipping_carriers_pkey
}

"""
input type for inserting data into table "shipping_carriers"
"""
input shipping_carriers_insert_input {
  code: String
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  name: String
  tracking_url_template: String
  updated_at: timestamptz
}

"""aggregate max on columns"""
type shipping_carriers_max_fields {
  code: String
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  name: String
  tracking_url_template: String
  updated_at: timestamptz
}

"""aggregate min on columns"""
type shipping_carriers_min_fields {
  code: String
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  name: String
  tracking_url_template: String
  updated_at: timestamptz
}

"""
response of any mutation on the table "shipping_carriers"
"""
type shipping_carriers_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [shipping_carriers!]!
}

"""
on_conflict condition type for table "shipping_carriers"
"""
input shipping_carriers_on_conflict {
  constraint: shipping_carriers_constraint!
  update_columns: [shipping_carriers_update_column!]! = []
  where: shipping_carriers_bool_exp
}

"""Ordering options when selecting data from "shipping_carriers"."""
input shipping_carriers_order_by {
  code: order_by
  created_at: order_by
  deleted_at: order_by
  id: order_by
  name: order_by
  tracking_url_template: order_by
  updated_at: order_by
}

"""primary key columns input for table: shipping_carriers"""
input shipping_carriers_pk_columns_input {
  id: uuid!
}

"""
select columns of table "shipping_carriers"
"""
enum shipping_carriers_select_column {
  """column name"""
  code

  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  name

  """column name"""
  tracking_url_template

  """column name"""
  updated_at
}

"""
input type for updating data in table "shipping_carriers"
"""
input shipping_carriers_set_input {
  code: String
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  name: String
  tracking_url_template: String
  updated_at: timestamptz
}

"""
Streaming cursor of the table "shipping_carriers"
"""
input shipping_carriers_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: shipping_carriers_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input shipping_carriers_stream_cursor_value_input {
  code: String
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  name: String
  tracking_url_template: String
  updated_at: timestamptz
}

"""
update columns of table "shipping_carriers"
"""
enum shipping_carriers_update_column {
  """column name"""
  code

  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  name

  """column name"""
  tracking_url_template

  """column name"""
  updated_at
}

input shipping_carriers_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: shipping_carriers_set_input

  """filter the rows which have to be updated"""
  where: shipping_carriers_bool_exp!
}

"""
columns and relationships of "site_authors"
"""
type site_authors {
  author_id: uuid
  created_at: timestamptz!
  deleted_at: timestamptz
  id: uuid!
  is_admin: Boolean!
  site_id: uuid
  updated_at: timestamptz!
}

"""
aggregated selection of "site_authors"
"""
type site_authors_aggregate {
  aggregate: site_authors_aggregate_fields
  nodes: [site_authors!]!
}

"""
aggregate fields of "site_authors"
"""
type site_authors_aggregate_fields {
  count(columns: [site_authors_select_column!], distinct: Boolean): Int!
  max: site_authors_max_fields
  min: site_authors_min_fields
}

"""
Boolean expression to filter rows from the table "site_authors". All fields are combined with a logical 'AND'.
"""
input site_authors_bool_exp {
  _and: [site_authors_bool_exp!]
  _not: site_authors_bool_exp
  _or: [site_authors_bool_exp!]
  author_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  deleted_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  is_admin: Boolean_comparison_exp
  site_id: uuid_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "site_authors"
"""
enum site_authors_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  site_authors_pkey
}

"""
input type for inserting data into table "site_authors"
"""
input site_authors_insert_input {
  author_id: uuid
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  is_admin: Boolean
  site_id: uuid
  updated_at: timestamptz
}

"""aggregate max on columns"""
type site_authors_max_fields {
  author_id: uuid
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  site_id: uuid
  updated_at: timestamptz
}

"""aggregate min on columns"""
type site_authors_min_fields {
  author_id: uuid
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  site_id: uuid
  updated_at: timestamptz
}

"""
response of any mutation on the table "site_authors"
"""
type site_authors_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [site_authors!]!
}

"""
on_conflict condition type for table "site_authors"
"""
input site_authors_on_conflict {
  constraint: site_authors_constraint!
  update_columns: [site_authors_update_column!]! = []
  where: site_authors_bool_exp
}

"""Ordering options when selecting data from "site_authors"."""
input site_authors_order_by {
  author_id: order_by
  created_at: order_by
  deleted_at: order_by
  id: order_by
  is_admin: order_by
  site_id: order_by
  updated_at: order_by
}

"""primary key columns input for table: site_authors"""
input site_authors_pk_columns_input {
  id: uuid!
}

"""
select columns of table "site_authors"
"""
enum site_authors_select_column {
  """column name"""
  author_id

  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  is_admin

  """column name"""
  site_id

  """column name"""
  updated_at
}

"""
input type for updating data in table "site_authors"
"""
input site_authors_set_input {
  author_id: uuid
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  is_admin: Boolean
  site_id: uuid
  updated_at: timestamptz
}

"""
Streaming cursor of the table "site_authors"
"""
input site_authors_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: site_authors_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input site_authors_stream_cursor_value_input {
  author_id: uuid
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  is_admin: Boolean
  site_id: uuid
  updated_at: timestamptz
}

"""
update columns of table "site_authors"
"""
enum site_authors_update_column {
  """column name"""
  author_id

  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  is_admin

  """column name"""
  site_id

  """column name"""
  updated_at
}

input site_authors_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: site_authors_set_input

  """filter the rows which have to be updated"""
  where: site_authors_bool_exp!
}

"""
columns and relationships of "sites"
"""
type sites {
  created_at: timestamptz!
  deleted_at: timestamptz
  domain: String!
  id: uuid!
  is_published: Boolean!
  name: String!
  updated_at: timestamptz!
}

"""
aggregated selection of "sites"
"""
type sites_aggregate {
  aggregate: sites_aggregate_fields
  nodes: [sites!]!
}

"""
aggregate fields of "sites"
"""
type sites_aggregate_fields {
  count(columns: [sites_select_column!], distinct: Boolean): Int!
  max: sites_max_fields
  min: sites_min_fields
}

"""
Boolean expression to filter rows from the table "sites". All fields are combined with a logical 'AND'.
"""
input sites_bool_exp {
  _and: [sites_bool_exp!]
  _not: sites_bool_exp
  _or: [sites_bool_exp!]
  created_at: timestamptz_comparison_exp
  deleted_at: timestamptz_comparison_exp
  domain: String_comparison_exp
  id: uuid_comparison_exp
  is_published: Boolean_comparison_exp
  name: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "sites"
"""
enum sites_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  sites_pkey
}

"""
input type for inserting data into table "sites"
"""
input sites_insert_input {
  created_at: timestamptz
  deleted_at: timestamptz
  domain: String
  id: uuid
  is_published: Boolean
  name: String
  updated_at: timestamptz
}

"""aggregate max on columns"""
type sites_max_fields {
  created_at: timestamptz
  deleted_at: timestamptz
  domain: String
  id: uuid
  name: String
  updated_at: timestamptz
}

"""aggregate min on columns"""
type sites_min_fields {
  created_at: timestamptz
  deleted_at: timestamptz
  domain: String
  id: uuid
  name: String
  updated_at: timestamptz
}

"""
response of any mutation on the table "sites"
"""
type sites_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [sites!]!
}

"""
on_conflict condition type for table "sites"
"""
input sites_on_conflict {
  constraint: sites_constraint!
  update_columns: [sites_update_column!]! = []
  where: sites_bool_exp
}

"""Ordering options when selecting data from "sites"."""
input sites_order_by {
  created_at: order_by
  deleted_at: order_by
  domain: order_by
  id: order_by
  is_published: order_by
  name: order_by
  updated_at: order_by
}

"""primary key columns input for table: sites"""
input sites_pk_columns_input {
  id: uuid!
}

"""
select columns of table "sites"
"""
enum sites_select_column {
  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  domain

  """column name"""
  id

  """column name"""
  is_published

  """column name"""
  name

  """column name"""
  updated_at
}

"""
input type for updating data in table "sites"
"""
input sites_set_input {
  created_at: timestamptz
  deleted_at: timestamptz
  domain: String
  id: uuid
  is_published: Boolean
  name: String
  updated_at: timestamptz
}

"""
Streaming cursor of the table "sites"
"""
input sites_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: sites_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input sites_stream_cursor_value_input {
  created_at: timestamptz
  deleted_at: timestamptz
  domain: String
  id: uuid
  is_published: Boolean
  name: String
  updated_at: timestamptz
}

"""
update columns of table "sites"
"""
enum sites_update_column {
  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  domain

  """column name"""
  id

  """column name"""
  is_published

  """column name"""
  name

  """column name"""
  updated_at
}

input sites_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: sites_set_input

  """filter the rows which have to be updated"""
  where: sites_bool_exp!
}

"""
columns and relationships of "sizes"
"""
type sizes {
  code: String!
  created_at: timestamptz!
  deleted_at: timestamptz
  id: uuid!
  name: String!
  sort_order: Int!
  updated_at: timestamptz!
}

"""
aggregated selection of "sizes"
"""
type sizes_aggregate {
  aggregate: sizes_aggregate_fields
  nodes: [sizes!]!
}

"""
aggregate fields of "sizes"
"""
type sizes_aggregate_fields {
  avg: sizes_avg_fields
  count(columns: [sizes_select_column!], distinct: Boolean): Int!
  max: sizes_max_fields
  min: sizes_min_fields
  stddev: sizes_stddev_fields
  stddev_pop: sizes_stddev_pop_fields
  stddev_samp: sizes_stddev_samp_fields
  sum: sizes_sum_fields
  var_pop: sizes_var_pop_fields
  var_samp: sizes_var_samp_fields
  variance: sizes_variance_fields
}

"""aggregate avg on columns"""
type sizes_avg_fields {
  sort_order: Float
}

"""
Boolean expression to filter rows from the table "sizes". All fields are combined with a logical 'AND'.
"""
input sizes_bool_exp {
  _and: [sizes_bool_exp!]
  _not: sizes_bool_exp
  _or: [sizes_bool_exp!]
  code: String_comparison_exp
  created_at: timestamptz_comparison_exp
  deleted_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
  sort_order: Int_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "sizes"
"""
enum sizes_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  sizes_pkey
}

"""
input type for incrementing numeric columns in table "sizes"
"""
input sizes_inc_input {
  sort_order: Int
}

"""
input type for inserting data into table "sizes"
"""
input sizes_insert_input {
  code: String
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  name: String
  sort_order: Int
  updated_at: timestamptz
}

"""aggregate max on columns"""
type sizes_max_fields {
  code: String
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  name: String
  sort_order: Int
  updated_at: timestamptz
}

"""aggregate min on columns"""
type sizes_min_fields {
  code: String
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  name: String
  sort_order: Int
  updated_at: timestamptz
}

"""
response of any mutation on the table "sizes"
"""
type sizes_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [sizes!]!
}

"""
on_conflict condition type for table "sizes"
"""
input sizes_on_conflict {
  constraint: sizes_constraint!
  update_columns: [sizes_update_column!]! = []
  where: sizes_bool_exp
}

"""Ordering options when selecting data from "sizes"."""
input sizes_order_by {
  code: order_by
  created_at: order_by
  deleted_at: order_by
  id: order_by
  name: order_by
  sort_order: order_by
  updated_at: order_by
}

"""primary key columns input for table: sizes"""
input sizes_pk_columns_input {
  id: uuid!
}

"""
select columns of table "sizes"
"""
enum sizes_select_column {
  """column name"""
  code

  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  name

  """column name"""
  sort_order

  """column name"""
  updated_at
}

"""
input type for updating data in table "sizes"
"""
input sizes_set_input {
  code: String
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  name: String
  sort_order: Int
  updated_at: timestamptz
}

"""aggregate stddev on columns"""
type sizes_stddev_fields {
  sort_order: Float
}

"""aggregate stddev_pop on columns"""
type sizes_stddev_pop_fields {
  sort_order: Float
}

"""aggregate stddev_samp on columns"""
type sizes_stddev_samp_fields {
  sort_order: Float
}

"""
Streaming cursor of the table "sizes"
"""
input sizes_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: sizes_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input sizes_stream_cursor_value_input {
  code: String
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  name: String
  sort_order: Int
  updated_at: timestamptz
}

"""aggregate sum on columns"""
type sizes_sum_fields {
  sort_order: Int
}

"""
update columns of table "sizes"
"""
enum sizes_update_column {
  """column name"""
  code

  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  name

  """column name"""
  sort_order

  """column name"""
  updated_at
}

input sizes_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: sizes_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: sizes_set_input

  """filter the rows which have to be updated"""
  where: sizes_bool_exp!
}

"""aggregate var_pop on columns"""
type sizes_var_pop_fields {
  sort_order: Float
}

"""aggregate var_samp on columns"""
type sizes_var_samp_fields {
  sort_order: Float
}

"""aggregate variance on columns"""
type sizes_variance_fields {
  sort_order: Float
}

"""
columns and relationships of "store_currencies"
"""
type store_currencies {
  created_at: timestamptz!
  currency_id: uuid
  deleted_at: timestamptz
  exchange_rate: numeric!
  id: uuid!
  is_default: Boolean!
  store_id: uuid
  updated_at: timestamptz!
}

"""
aggregated selection of "store_currencies"
"""
type store_currencies_aggregate {
  aggregate: store_currencies_aggregate_fields
  nodes: [store_currencies!]!
}

"""
aggregate fields of "store_currencies"
"""
type store_currencies_aggregate_fields {
  avg: store_currencies_avg_fields
  count(columns: [store_currencies_select_column!], distinct: Boolean): Int!
  max: store_currencies_max_fields
  min: store_currencies_min_fields
  stddev: store_currencies_stddev_fields
  stddev_pop: store_currencies_stddev_pop_fields
  stddev_samp: store_currencies_stddev_samp_fields
  sum: store_currencies_sum_fields
  var_pop: store_currencies_var_pop_fields
  var_samp: store_currencies_var_samp_fields
  variance: store_currencies_variance_fields
}

"""aggregate avg on columns"""
type store_currencies_avg_fields {
  exchange_rate: Float
}

"""
Boolean expression to filter rows from the table "store_currencies". All fields are combined with a logical 'AND'.
"""
input store_currencies_bool_exp {
  _and: [store_currencies_bool_exp!]
  _not: store_currencies_bool_exp
  _or: [store_currencies_bool_exp!]
  created_at: timestamptz_comparison_exp
  currency_id: uuid_comparison_exp
  deleted_at: timestamptz_comparison_exp
  exchange_rate: numeric_comparison_exp
  id: uuid_comparison_exp
  is_default: Boolean_comparison_exp
  store_id: uuid_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "store_currencies"
"""
enum store_currencies_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  store_currencies_pkey
}

"""
input type for incrementing numeric columns in table "store_currencies"
"""
input store_currencies_inc_input {
  exchange_rate: numeric
}

"""
input type for inserting data into table "store_currencies"
"""
input store_currencies_insert_input {
  created_at: timestamptz
  currency_id: uuid
  deleted_at: timestamptz
  exchange_rate: numeric
  id: uuid
  is_default: Boolean
  store_id: uuid
  updated_at: timestamptz
}

"""aggregate max on columns"""
type store_currencies_max_fields {
  created_at: timestamptz
  currency_id: uuid
  deleted_at: timestamptz
  exchange_rate: numeric
  id: uuid
  store_id: uuid
  updated_at: timestamptz
}

"""aggregate min on columns"""
type store_currencies_min_fields {
  created_at: timestamptz
  currency_id: uuid
  deleted_at: timestamptz
  exchange_rate: numeric
  id: uuid
  store_id: uuid
  updated_at: timestamptz
}

"""
response of any mutation on the table "store_currencies"
"""
type store_currencies_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [store_currencies!]!
}

"""
on_conflict condition type for table "store_currencies"
"""
input store_currencies_on_conflict {
  constraint: store_currencies_constraint!
  update_columns: [store_currencies_update_column!]! = []
  where: store_currencies_bool_exp
}

"""Ordering options when selecting data from "store_currencies"."""
input store_currencies_order_by {
  created_at: order_by
  currency_id: order_by
  deleted_at: order_by
  exchange_rate: order_by
  id: order_by
  is_default: order_by
  store_id: order_by
  updated_at: order_by
}

"""primary key columns input for table: store_currencies"""
input store_currencies_pk_columns_input {
  id: uuid!
}

"""
select columns of table "store_currencies"
"""
enum store_currencies_select_column {
  """column name"""
  created_at

  """column name"""
  currency_id

  """column name"""
  deleted_at

  """column name"""
  exchange_rate

  """column name"""
  id

  """column name"""
  is_default

  """column name"""
  store_id

  """column name"""
  updated_at
}

"""
input type for updating data in table "store_currencies"
"""
input store_currencies_set_input {
  created_at: timestamptz
  currency_id: uuid
  deleted_at: timestamptz
  exchange_rate: numeric
  id: uuid
  is_default: Boolean
  store_id: uuid
  updated_at: timestamptz
}

"""aggregate stddev on columns"""
type store_currencies_stddev_fields {
  exchange_rate: Float
}

"""aggregate stddev_pop on columns"""
type store_currencies_stddev_pop_fields {
  exchange_rate: Float
}

"""aggregate stddev_samp on columns"""
type store_currencies_stddev_samp_fields {
  exchange_rate: Float
}

"""
Streaming cursor of the table "store_currencies"
"""
input store_currencies_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: store_currencies_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input store_currencies_stream_cursor_value_input {
  created_at: timestamptz
  currency_id: uuid
  deleted_at: timestamptz
  exchange_rate: numeric
  id: uuid
  is_default: Boolean
  store_id: uuid
  updated_at: timestamptz
}

"""aggregate sum on columns"""
type store_currencies_sum_fields {
  exchange_rate: numeric
}

"""
update columns of table "store_currencies"
"""
enum store_currencies_update_column {
  """column name"""
  created_at

  """column name"""
  currency_id

  """column name"""
  deleted_at

  """column name"""
  exchange_rate

  """column name"""
  id

  """column name"""
  is_default

  """column name"""
  store_id

  """column name"""
  updated_at
}

input store_currencies_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: store_currencies_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: store_currencies_set_input

  """filter the rows which have to be updated"""
  where: store_currencies_bool_exp!
}

"""aggregate var_pop on columns"""
type store_currencies_var_pop_fields {
  exchange_rate: Float
}

"""aggregate var_samp on columns"""
type store_currencies_var_samp_fields {
  exchange_rate: Float
}

"""aggregate variance on columns"""
type store_currencies_variance_fields {
  exchange_rate: Float
}

"""
columns and relationships of "store_payment_methods"
"""
type store_payment_methods {
  config(
    """JSON select path"""
    path: String
  ): jsonb
  created_at: timestamptz!
  deleted_at: timestamptz
  id: uuid!
  is_enabled: Boolean!
  payment_method_id: uuid
  store_id: uuid
  updated_at: timestamptz!
}

"""
aggregated selection of "store_payment_methods"
"""
type store_payment_methods_aggregate {
  aggregate: store_payment_methods_aggregate_fields
  nodes: [store_payment_methods!]!
}

"""
aggregate fields of "store_payment_methods"
"""
type store_payment_methods_aggregate_fields {
  count(columns: [store_payment_methods_select_column!], distinct: Boolean): Int!
  max: store_payment_methods_max_fields
  min: store_payment_methods_min_fields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input store_payment_methods_append_input {
  config: jsonb
}

"""
Boolean expression to filter rows from the table "store_payment_methods". All fields are combined with a logical 'AND'.
"""
input store_payment_methods_bool_exp {
  _and: [store_payment_methods_bool_exp!]
  _not: store_payment_methods_bool_exp
  _or: [store_payment_methods_bool_exp!]
  config: jsonb_comparison_exp
  created_at: timestamptz_comparison_exp
  deleted_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  is_enabled: Boolean_comparison_exp
  payment_method_id: uuid_comparison_exp
  store_id: uuid_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "store_payment_methods"
"""
enum store_payment_methods_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  store_payment_methods_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input store_payment_methods_delete_at_path_input {
  config: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input store_payment_methods_delete_elem_input {
  config: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input store_payment_methods_delete_key_input {
  config: String
}

"""
input type for inserting data into table "store_payment_methods"
"""
input store_payment_methods_insert_input {
  config: jsonb
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  is_enabled: Boolean
  payment_method_id: uuid
  store_id: uuid
  updated_at: timestamptz
}

"""aggregate max on columns"""
type store_payment_methods_max_fields {
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  payment_method_id: uuid
  store_id: uuid
  updated_at: timestamptz
}

"""aggregate min on columns"""
type store_payment_methods_min_fields {
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  payment_method_id: uuid
  store_id: uuid
  updated_at: timestamptz
}

"""
response of any mutation on the table "store_payment_methods"
"""
type store_payment_methods_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [store_payment_methods!]!
}

"""
on_conflict condition type for table "store_payment_methods"
"""
input store_payment_methods_on_conflict {
  constraint: store_payment_methods_constraint!
  update_columns: [store_payment_methods_update_column!]! = []
  where: store_payment_methods_bool_exp
}

"""Ordering options when selecting data from "store_payment_methods"."""
input store_payment_methods_order_by {
  config: order_by
  created_at: order_by
  deleted_at: order_by
  id: order_by
  is_enabled: order_by
  payment_method_id: order_by
  store_id: order_by
  updated_at: order_by
}

"""primary key columns input for table: store_payment_methods"""
input store_payment_methods_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input store_payment_methods_prepend_input {
  config: jsonb
}

"""
select columns of table "store_payment_methods"
"""
enum store_payment_methods_select_column {
  """column name"""
  config

  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  is_enabled

  """column name"""
  payment_method_id

  """column name"""
  store_id

  """column name"""
  updated_at
}

"""
input type for updating data in table "store_payment_methods"
"""
input store_payment_methods_set_input {
  config: jsonb
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  is_enabled: Boolean
  payment_method_id: uuid
  store_id: uuid
  updated_at: timestamptz
}

"""
Streaming cursor of the table "store_payment_methods"
"""
input store_payment_methods_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: store_payment_methods_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input store_payment_methods_stream_cursor_value_input {
  config: jsonb
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  is_enabled: Boolean
  payment_method_id: uuid
  store_id: uuid
  updated_at: timestamptz
}

"""
update columns of table "store_payment_methods"
"""
enum store_payment_methods_update_column {
  """column name"""
  config

  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  is_enabled

  """column name"""
  payment_method_id

  """column name"""
  store_id

  """column name"""
  updated_at
}

input store_payment_methods_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: store_payment_methods_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: store_payment_methods_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: store_payment_methods_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: store_payment_methods_delete_key_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: store_payment_methods_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: store_payment_methods_set_input

  """filter the rows which have to be updated"""
  where: store_payment_methods_bool_exp!
}

"""
columns and relationships of "store_shipping_carriers"
"""
type store_shipping_carriers {
  carrier_id: uuid
  config(
    """JSON select path"""
    path: String
  ): jsonb
  created_at: timestamptz!
  deleted_at: timestamptz
  id: uuid!
  is_enabled: Boolean!
  store_id: uuid
  updated_at: timestamptz!
}

"""
aggregated selection of "store_shipping_carriers"
"""
type store_shipping_carriers_aggregate {
  aggregate: store_shipping_carriers_aggregate_fields
  nodes: [store_shipping_carriers!]!
}

"""
aggregate fields of "store_shipping_carriers"
"""
type store_shipping_carriers_aggregate_fields {
  count(columns: [store_shipping_carriers_select_column!], distinct: Boolean): Int!
  max: store_shipping_carriers_max_fields
  min: store_shipping_carriers_min_fields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input store_shipping_carriers_append_input {
  config: jsonb
}

"""
Boolean expression to filter rows from the table "store_shipping_carriers". All fields are combined with a logical 'AND'.
"""
input store_shipping_carriers_bool_exp {
  _and: [store_shipping_carriers_bool_exp!]
  _not: store_shipping_carriers_bool_exp
  _or: [store_shipping_carriers_bool_exp!]
  carrier_id: uuid_comparison_exp
  config: jsonb_comparison_exp
  created_at: timestamptz_comparison_exp
  deleted_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  is_enabled: Boolean_comparison_exp
  store_id: uuid_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "store_shipping_carriers"
"""
enum store_shipping_carriers_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  store_shipping_carriers_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input store_shipping_carriers_delete_at_path_input {
  config: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input store_shipping_carriers_delete_elem_input {
  config: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input store_shipping_carriers_delete_key_input {
  config: String
}

"""
input type for inserting data into table "store_shipping_carriers"
"""
input store_shipping_carriers_insert_input {
  carrier_id: uuid
  config: jsonb
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  is_enabled: Boolean
  store_id: uuid
  updated_at: timestamptz
}

"""aggregate max on columns"""
type store_shipping_carriers_max_fields {
  carrier_id: uuid
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  store_id: uuid
  updated_at: timestamptz
}

"""aggregate min on columns"""
type store_shipping_carriers_min_fields {
  carrier_id: uuid
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  store_id: uuid
  updated_at: timestamptz
}

"""
response of any mutation on the table "store_shipping_carriers"
"""
type store_shipping_carriers_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [store_shipping_carriers!]!
}

"""
on_conflict condition type for table "store_shipping_carriers"
"""
input store_shipping_carriers_on_conflict {
  constraint: store_shipping_carriers_constraint!
  update_columns: [store_shipping_carriers_update_column!]! = []
  where: store_shipping_carriers_bool_exp
}

"""Ordering options when selecting data from "store_shipping_carriers"."""
input store_shipping_carriers_order_by {
  carrier_id: order_by
  config: order_by
  created_at: order_by
  deleted_at: order_by
  id: order_by
  is_enabled: order_by
  store_id: order_by
  updated_at: order_by
}

"""primary key columns input for table: store_shipping_carriers"""
input store_shipping_carriers_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input store_shipping_carriers_prepend_input {
  config: jsonb
}

"""
select columns of table "store_shipping_carriers"
"""
enum store_shipping_carriers_select_column {
  """column name"""
  carrier_id

  """column name"""
  config

  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  is_enabled

  """column name"""
  store_id

  """column name"""
  updated_at
}

"""
input type for updating data in table "store_shipping_carriers"
"""
input store_shipping_carriers_set_input {
  carrier_id: uuid
  config: jsonb
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  is_enabled: Boolean
  store_id: uuid
  updated_at: timestamptz
}

"""
Streaming cursor of the table "store_shipping_carriers"
"""
input store_shipping_carriers_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: store_shipping_carriers_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input store_shipping_carriers_stream_cursor_value_input {
  carrier_id: uuid
  config: jsonb
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  is_enabled: Boolean
  store_id: uuid
  updated_at: timestamptz
}

"""
update columns of table "store_shipping_carriers"
"""
enum store_shipping_carriers_update_column {
  """column name"""
  carrier_id

  """column name"""
  config

  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  is_enabled

  """column name"""
  store_id

  """column name"""
  updated_at
}

input store_shipping_carriers_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: store_shipping_carriers_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: store_shipping_carriers_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: store_shipping_carriers_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: store_shipping_carriers_delete_key_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: store_shipping_carriers_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: store_shipping_carriers_set_input

  """filter the rows which have to be updated"""
  where: store_shipping_carriers_bool_exp!
}

"""
columns and relationships of "stores"
"""
type stores {
  created_at: timestamptz!
  deleted_at: timestamptz
  description: String
  id: uuid!
  is_active: Boolean!
  name: String!
  slug: String!
  updated_at: timestamptz!
}

"""
aggregated selection of "stores"
"""
type stores_aggregate {
  aggregate: stores_aggregate_fields
  nodes: [stores!]!
}

"""
aggregate fields of "stores"
"""
type stores_aggregate_fields {
  count(columns: [stores_select_column!], distinct: Boolean): Int!
  max: stores_max_fields
  min: stores_min_fields
}

"""
Boolean expression to filter rows from the table "stores". All fields are combined with a logical 'AND'.
"""
input stores_bool_exp {
  _and: [stores_bool_exp!]
  _not: stores_bool_exp
  _or: [stores_bool_exp!]
  created_at: timestamptz_comparison_exp
  deleted_at: timestamptz_comparison_exp
  description: String_comparison_exp
  id: uuid_comparison_exp
  is_active: Boolean_comparison_exp
  name: String_comparison_exp
  slug: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "stores"
"""
enum stores_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  stores_pkey
}

"""
input type for inserting data into table "stores"
"""
input stores_insert_input {
  created_at: timestamptz
  deleted_at: timestamptz
  description: String
  id: uuid
  is_active: Boolean
  name: String
  slug: String
  updated_at: timestamptz
}

"""aggregate max on columns"""
type stores_max_fields {
  created_at: timestamptz
  deleted_at: timestamptz
  description: String
  id: uuid
  name: String
  slug: String
  updated_at: timestamptz
}

"""aggregate min on columns"""
type stores_min_fields {
  created_at: timestamptz
  deleted_at: timestamptz
  description: String
  id: uuid
  name: String
  slug: String
  updated_at: timestamptz
}

"""
response of any mutation on the table "stores"
"""
type stores_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [stores!]!
}

"""
on_conflict condition type for table "stores"
"""
input stores_on_conflict {
  constraint: stores_constraint!
  update_columns: [stores_update_column!]! = []
  where: stores_bool_exp
}

"""Ordering options when selecting data from "stores"."""
input stores_order_by {
  created_at: order_by
  deleted_at: order_by
  description: order_by
  id: order_by
  is_active: order_by
  name: order_by
  slug: order_by
  updated_at: order_by
}

"""primary key columns input for table: stores"""
input stores_pk_columns_input {
  id: uuid!
}

"""
select columns of table "stores"
"""
enum stores_select_column {
  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  description

  """column name"""
  id

  """column name"""
  is_active

  """column name"""
  name

  """column name"""
  slug

  """column name"""
  updated_at
}

"""
input type for updating data in table "stores"
"""
input stores_set_input {
  created_at: timestamptz
  deleted_at: timestamptz
  description: String
  id: uuid
  is_active: Boolean
  name: String
  slug: String
  updated_at: timestamptz
}

"""
Streaming cursor of the table "stores"
"""
input stores_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: stores_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input stores_stream_cursor_value_input {
  created_at: timestamptz
  deleted_at: timestamptz
  description: String
  id: uuid
  is_active: Boolean
  name: String
  slug: String
  updated_at: timestamptz
}

"""
update columns of table "stores"
"""
enum stores_update_column {
  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  description

  """column name"""
  id

  """column name"""
  is_active

  """column name"""
  name

  """column name"""
  slug

  """column name"""
  updated_at
}

input stores_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: stores_set_input

  """filter the rows which have to be updated"""
  where: stores_bool_exp!
}

"""
columns and relationships of "streets"
"""
type streets {
  created_at: timestamptz!
  deleted_at: timestamptz
  id: uuid!
  name: String!
  neighborhood_id: uuid
  postal_code: String
  updated_at: timestamptz!
}

"""
aggregated selection of "streets"
"""
type streets_aggregate {
  aggregate: streets_aggregate_fields
  nodes: [streets!]!
}

"""
aggregate fields of "streets"
"""
type streets_aggregate_fields {
  count(columns: [streets_select_column!], distinct: Boolean): Int!
  max: streets_max_fields
  min: streets_min_fields
}

"""
Boolean expression to filter rows from the table "streets". All fields are combined with a logical 'AND'.
"""
input streets_bool_exp {
  _and: [streets_bool_exp!]
  _not: streets_bool_exp
  _or: [streets_bool_exp!]
  created_at: timestamptz_comparison_exp
  deleted_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
  neighborhood_id: uuid_comparison_exp
  postal_code: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "streets"
"""
enum streets_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  streets_pkey
}

"""
input type for inserting data into table "streets"
"""
input streets_insert_input {
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  name: String
  neighborhood_id: uuid
  postal_code: String
  updated_at: timestamptz
}

"""aggregate max on columns"""
type streets_max_fields {
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  name: String
  neighborhood_id: uuid
  postal_code: String
  updated_at: timestamptz
}

"""aggregate min on columns"""
type streets_min_fields {
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  name: String
  neighborhood_id: uuid
  postal_code: String
  updated_at: timestamptz
}

"""
response of any mutation on the table "streets"
"""
type streets_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [streets!]!
}

"""
on_conflict condition type for table "streets"
"""
input streets_on_conflict {
  constraint: streets_constraint!
  update_columns: [streets_update_column!]! = []
  where: streets_bool_exp
}

"""Ordering options when selecting data from "streets"."""
input streets_order_by {
  created_at: order_by
  deleted_at: order_by
  id: order_by
  name: order_by
  neighborhood_id: order_by
  postal_code: order_by
  updated_at: order_by
}

"""primary key columns input for table: streets"""
input streets_pk_columns_input {
  id: uuid!
}

"""
select columns of table "streets"
"""
enum streets_select_column {
  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  name

  """column name"""
  neighborhood_id

  """column name"""
  postal_code

  """column name"""
  updated_at
}

"""
input type for updating data in table "streets"
"""
input streets_set_input {
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  name: String
  neighborhood_id: uuid
  postal_code: String
  updated_at: timestamptz
}

"""
Streaming cursor of the table "streets"
"""
input streets_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: streets_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input streets_stream_cursor_value_input {
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  name: String
  neighborhood_id: uuid
  postal_code: String
  updated_at: timestamptz
}

"""
update columns of table "streets"
"""
enum streets_update_column {
  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  name

  """column name"""
  neighborhood_id

  """column name"""
  postal_code

  """column name"""
  updated_at
}

input streets_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: streets_set_input

  """filter the rows which have to be updated"""
  where: streets_bool_exp!
}

type subscription_root {
  """
  fetch data from the table: "analytics_events"
  """
  analytics_events(
    """distinct select on columns"""
    distinct_on: [analytics_events_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [analytics_events_order_by!]

    """filter the rows returned"""
    where: analytics_events_bool_exp
  ): [analytics_events!]!

  """
  fetch aggregated fields from the table: "analytics_events"
  """
  analytics_events_aggregate(
    """distinct select on columns"""
    distinct_on: [analytics_events_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [analytics_events_order_by!]

    """filter the rows returned"""
    where: analytics_events_bool_exp
  ): analytics_events_aggregate!

  """
  fetch data from the table: "analytics_events" using primary key columns
  """
  analytics_events_by_pk(id: uuid!): analytics_events

  """
  fetch data from the table in a streaming manner: "analytics_events"
  """
  analytics_events_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [analytics_events_stream_cursor_input]!

    """filter the rows returned"""
    where: analytics_events_bool_exp
  ): [analytics_events!]!

  """
  fetch data from the table: "article_categories"
  """
  article_categories(
    """distinct select on columns"""
    distinct_on: [article_categories_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [article_categories_order_by!]

    """filter the rows returned"""
    where: article_categories_bool_exp
  ): [article_categories!]!

  """
  fetch aggregated fields from the table: "article_categories"
  """
  article_categories_aggregate(
    """distinct select on columns"""
    distinct_on: [article_categories_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [article_categories_order_by!]

    """filter the rows returned"""
    where: article_categories_bool_exp
  ): article_categories_aggregate!

  """
  fetch data from the table: "article_categories" using primary key columns
  """
  article_categories_by_pk(id: uuid!): article_categories

  """
  fetch data from the table in a streaming manner: "article_categories"
  """
  article_categories_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [article_categories_stream_cursor_input]!

    """filter the rows returned"""
    where: article_categories_bool_exp
  ): [article_categories!]!

  """
  fetch data from the table: "article_category_assignments"
  """
  article_category_assignments(
    """distinct select on columns"""
    distinct_on: [article_category_assignments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [article_category_assignments_order_by!]

    """filter the rows returned"""
    where: article_category_assignments_bool_exp
  ): [article_category_assignments!]!

  """
  fetch aggregated fields from the table: "article_category_assignments"
  """
  article_category_assignments_aggregate(
    """distinct select on columns"""
    distinct_on: [article_category_assignments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [article_category_assignments_order_by!]

    """filter the rows returned"""
    where: article_category_assignments_bool_exp
  ): article_category_assignments_aggregate!

  """
  fetch data from the table: "article_category_assignments" using primary key columns
  """
  article_category_assignments_by_pk(id: uuid!): article_category_assignments

  """
  fetch data from the table in a streaming manner: "article_category_assignments"
  """
  article_category_assignments_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [article_category_assignments_stream_cursor_input]!

    """filter the rows returned"""
    where: article_category_assignments_bool_exp
  ): [article_category_assignments!]!

  """
  fetch data from the table: "article_tags"
  """
  article_tags(
    """distinct select on columns"""
    distinct_on: [article_tags_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [article_tags_order_by!]

    """filter the rows returned"""
    where: article_tags_bool_exp
  ): [article_tags!]!

  """
  fetch aggregated fields from the table: "article_tags"
  """
  article_tags_aggregate(
    """distinct select on columns"""
    distinct_on: [article_tags_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [article_tags_order_by!]

    """filter the rows returned"""
    where: article_tags_bool_exp
  ): article_tags_aggregate!

  """fetch data from the table: "article_tags" using primary key columns"""
  article_tags_by_pk(id: uuid!): article_tags

  """
  fetch data from the table in a streaming manner: "article_tags"
  """
  article_tags_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [article_tags_stream_cursor_input]!

    """filter the rows returned"""
    where: article_tags_bool_exp
  ): [article_tags!]!

  """
  fetch data from the table: "articles"
  """
  articles(
    """distinct select on columns"""
    distinct_on: [articles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [articles_order_by!]

    """filter the rows returned"""
    where: articles_bool_exp
  ): [articles!]!

  """
  fetch aggregated fields from the table: "articles"
  """
  articles_aggregate(
    """distinct select on columns"""
    distinct_on: [articles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [articles_order_by!]

    """filter the rows returned"""
    where: articles_bool_exp
  ): articles_aggregate!

  """fetch data from the table: "articles" using primary key columns"""
  articles_by_pk(id: uuid!): articles

  """
  fetch data from the table in a streaming manner: "articles"
  """
  articles_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [articles_stream_cursor_input]!

    """filter the rows returned"""
    where: articles_bool_exp
  ): [articles!]!

  """
  fetch data from the table: "author_articles"
  """
  author_articles(
    """distinct select on columns"""
    distinct_on: [author_articles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [author_articles_order_by!]

    """filter the rows returned"""
    where: author_articles_bool_exp
  ): [author_articles!]!

  """
  fetch aggregated fields from the table: "author_articles"
  """
  author_articles_aggregate(
    """distinct select on columns"""
    distinct_on: [author_articles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [author_articles_order_by!]

    """filter the rows returned"""
    where: author_articles_bool_exp
  ): author_articles_aggregate!

  """fetch data from the table: "author_articles" using primary key columns"""
  author_articles_by_pk(id: uuid!): author_articles

  """
  fetch data from the table in a streaming manner: "author_articles"
  """
  author_articles_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [author_articles_stream_cursor_input]!

    """filter the rows returned"""
    where: author_articles_bool_exp
  ): [author_articles!]!

  """
  fetch data from the table: "authors"
  """
  authors(
    """distinct select on columns"""
    distinct_on: [authors_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authors_order_by!]

    """filter the rows returned"""
    where: authors_bool_exp
  ): [authors!]!

  """
  fetch aggregated fields from the table: "authors"
  """
  authors_aggregate(
    """distinct select on columns"""
    distinct_on: [authors_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authors_order_by!]

    """filter the rows returned"""
    where: authors_bool_exp
  ): authors_aggregate!

  """fetch data from the table: "authors" using primary key columns"""
  authors_by_pk(id: uuid!): authors

  """
  fetch data from the table in a streaming manner: "authors"
  """
  authors_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [authors_stream_cursor_input]!

    """filter the rows returned"""
    where: authors_bool_exp
  ): [authors!]!

  """
  fetch data from the table: "blocks"
  """
  blocks(
    """distinct select on columns"""
    distinct_on: [blocks_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [blocks_order_by!]

    """filter the rows returned"""
    where: blocks_bool_exp
  ): [blocks!]!

  """
  fetch aggregated fields from the table: "blocks"
  """
  blocks_aggregate(
    """distinct select on columns"""
    distinct_on: [blocks_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [blocks_order_by!]

    """filter the rows returned"""
    where: blocks_bool_exp
  ): blocks_aggregate!

  """fetch data from the table: "blocks" using primary key columns"""
  blocks_by_pk(id: uuid!): blocks

  """
  fetch data from the table in a streaming manner: "blocks"
  """
  blocks_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [blocks_stream_cursor_input]!

    """filter the rows returned"""
    where: blocks_bool_exp
  ): [blocks!]!

  """
  fetch data from the table: "bookmarks"
  """
  bookmarks(
    """distinct select on columns"""
    distinct_on: [bookmarks_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [bookmarks_order_by!]

    """filter the rows returned"""
    where: bookmarks_bool_exp
  ): [bookmarks!]!

  """
  fetch aggregated fields from the table: "bookmarks"
  """
  bookmarks_aggregate(
    """distinct select on columns"""
    distinct_on: [bookmarks_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [bookmarks_order_by!]

    """filter the rows returned"""
    where: bookmarks_bool_exp
  ): bookmarks_aggregate!

  """fetch data from the table: "bookmarks" using primary key columns"""
  bookmarks_by_pk(id: uuid!): bookmarks

  """
  fetch data from the table in a streaming manner: "bookmarks"
  """
  bookmarks_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [bookmarks_stream_cursor_input]!

    """filter the rows returned"""
    where: bookmarks_bool_exp
  ): [bookmarks!]!

  """
  fetch data from the table: "brands"
  """
  brands(
    """distinct select on columns"""
    distinct_on: [brands_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [brands_order_by!]

    """filter the rows returned"""
    where: brands_bool_exp
  ): [brands!]!

  """
  fetch aggregated fields from the table: "brands"
  """
  brands_aggregate(
    """distinct select on columns"""
    distinct_on: [brands_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [brands_order_by!]

    """filter the rows returned"""
    where: brands_bool_exp
  ): brands_aggregate!

  """fetch data from the table: "brands" using primary key columns"""
  brands_by_pk(id: uuid!): brands

  """
  fetch data from the table in a streaming manner: "brands"
  """
  brands_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [brands_stream_cursor_input]!

    """filter the rows returned"""
    where: brands_bool_exp
  ): [brands!]!

  """
  fetch data from the table: "cart_items"
  """
  cart_items(
    """distinct select on columns"""
    distinct_on: [cart_items_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [cart_items_order_by!]

    """filter the rows returned"""
    where: cart_items_bool_exp
  ): [cart_items!]!

  """
  fetch aggregated fields from the table: "cart_items"
  """
  cart_items_aggregate(
    """distinct select on columns"""
    distinct_on: [cart_items_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [cart_items_order_by!]

    """filter the rows returned"""
    where: cart_items_bool_exp
  ): cart_items_aggregate!

  """fetch data from the table: "cart_items" using primary key columns"""
  cart_items_by_pk(id: uuid!): cart_items

  """
  fetch data from the table in a streaming manner: "cart_items"
  """
  cart_items_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [cart_items_stream_cursor_input]!

    """filter the rows returned"""
    where: cart_items_bool_exp
  ): [cart_items!]!

  """
  fetch data from the table: "carts"
  """
  carts(
    """distinct select on columns"""
    distinct_on: [carts_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [carts_order_by!]

    """filter the rows returned"""
    where: carts_bool_exp
  ): [carts!]!

  """
  fetch aggregated fields from the table: "carts"
  """
  carts_aggregate(
    """distinct select on columns"""
    distinct_on: [carts_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [carts_order_by!]

    """filter the rows returned"""
    where: carts_bool_exp
  ): carts_aggregate!

  """fetch data from the table: "carts" using primary key columns"""
  carts_by_pk(id: uuid!): carts

  """
  fetch data from the table in a streaming manner: "carts"
  """
  carts_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [carts_stream_cursor_input]!

    """filter the rows returned"""
    where: carts_bool_exp
  ): [carts!]!

  """
  fetch data from the table: "cities"
  """
  cities(
    """distinct select on columns"""
    distinct_on: [cities_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [cities_order_by!]

    """filter the rows returned"""
    where: cities_bool_exp
  ): [cities!]!

  """
  fetch aggregated fields from the table: "cities"
  """
  cities_aggregate(
    """distinct select on columns"""
    distinct_on: [cities_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [cities_order_by!]

    """filter the rows returned"""
    where: cities_bool_exp
  ): cities_aggregate!

  """fetch data from the table: "cities" using primary key columns"""
  cities_by_pk(id: uuid!): cities

  """
  fetch data from the table in a streaming manner: "cities"
  """
  cities_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [cities_stream_cursor_input]!

    """filter the rows returned"""
    where: cities_bool_exp
  ): [cities!]!

  """
  fetch data from the table: "collections"
  """
  collections(
    """distinct select on columns"""
    distinct_on: [collections_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [collections_order_by!]

    """filter the rows returned"""
    where: collections_bool_exp
  ): [collections!]!

  """
  fetch aggregated fields from the table: "collections"
  """
  collections_aggregate(
    """distinct select on columns"""
    distinct_on: [collections_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [collections_order_by!]

    """filter the rows returned"""
    where: collections_bool_exp
  ): collections_aggregate!

  """fetch data from the table: "collections" using primary key columns"""
  collections_by_pk(id: uuid!): collections

  """
  fetch data from the table in a streaming manner: "collections"
  """
  collections_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [collections_stream_cursor_input]!

    """filter the rows returned"""
    where: collections_bool_exp
  ): [collections!]!

  """
  fetch data from the table: "colors"
  """
  colors(
    """distinct select on columns"""
    distinct_on: [colors_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [colors_order_by!]

    """filter the rows returned"""
    where: colors_bool_exp
  ): [colors!]!

  """
  fetch aggregated fields from the table: "colors"
  """
  colors_aggregate(
    """distinct select on columns"""
    distinct_on: [colors_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [colors_order_by!]

    """filter the rows returned"""
    where: colors_bool_exp
  ): colors_aggregate!

  """fetch data from the table: "colors" using primary key columns"""
  colors_by_pk(id: uuid!): colors

  """
  fetch data from the table in a streaming manner: "colors"
  """
  colors_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [colors_stream_cursor_input]!

    """filter the rows returned"""
    where: colors_bool_exp
  ): [colors!]!

  """
  fetch data from the table: "comments"
  """
  comments(
    """distinct select on columns"""
    distinct_on: [comments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [comments_order_by!]

    """filter the rows returned"""
    where: comments_bool_exp
  ): [comments!]!

  """
  fetch aggregated fields from the table: "comments"
  """
  comments_aggregate(
    """distinct select on columns"""
    distinct_on: [comments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [comments_order_by!]

    """filter the rows returned"""
    where: comments_bool_exp
  ): comments_aggregate!

  """fetch data from the table: "comments" using primary key columns"""
  comments_by_pk(id: uuid!): comments

  """
  fetch data from the table in a streaming manner: "comments"
  """
  comments_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [comments_stream_cursor_input]!

    """filter the rows returned"""
    where: comments_bool_exp
  ): [comments!]!

  """
  fetch data from the table: "conversation_participants"
  """
  conversation_participants(
    """distinct select on columns"""
    distinct_on: [conversation_participants_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [conversation_participants_order_by!]

    """filter the rows returned"""
    where: conversation_participants_bool_exp
  ): [conversation_participants!]!

  """
  fetch aggregated fields from the table: "conversation_participants"
  """
  conversation_participants_aggregate(
    """distinct select on columns"""
    distinct_on: [conversation_participants_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [conversation_participants_order_by!]

    """filter the rows returned"""
    where: conversation_participants_bool_exp
  ): conversation_participants_aggregate!

  """
  fetch data from the table: "conversation_participants" using primary key columns
  """
  conversation_participants_by_pk(id: uuid!): conversation_participants

  """
  fetch data from the table in a streaming manner: "conversation_participants"
  """
  conversation_participants_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [conversation_participants_stream_cursor_input]!

    """filter the rows returned"""
    where: conversation_participants_bool_exp
  ): [conversation_participants!]!

  """
  fetch data from the table: "conversations"
  """
  conversations(
    """distinct select on columns"""
    distinct_on: [conversations_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [conversations_order_by!]

    """filter the rows returned"""
    where: conversations_bool_exp
  ): [conversations!]!

  """
  fetch aggregated fields from the table: "conversations"
  """
  conversations_aggregate(
    """distinct select on columns"""
    distinct_on: [conversations_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [conversations_order_by!]

    """filter the rows returned"""
    where: conversations_bool_exp
  ): conversations_aggregate!

  """fetch data from the table: "conversations" using primary key columns"""
  conversations_by_pk(id: uuid!): conversations

  """
  fetch data from the table in a streaming manner: "conversations"
  """
  conversations_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [conversations_stream_cursor_input]!

    """filter the rows returned"""
    where: conversations_bool_exp
  ): [conversations!]!

  """
  fetch data from the table: "countries"
  """
  countries(
    """distinct select on columns"""
    distinct_on: [countries_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [countries_order_by!]

    """filter the rows returned"""
    where: countries_bool_exp
  ): [countries!]!

  """
  fetch aggregated fields from the table: "countries"
  """
  countries_aggregate(
    """distinct select on columns"""
    distinct_on: [countries_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [countries_order_by!]

    """filter the rows returned"""
    where: countries_bool_exp
  ): countries_aggregate!

  """fetch data from the table: "countries" using primary key columns"""
  countries_by_pk(id: uuid!): countries

  """
  fetch data from the table in a streaming manner: "countries"
  """
  countries_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [countries_stream_cursor_input]!

    """filter the rows returned"""
    where: countries_bool_exp
  ): [countries!]!

  """
  fetch data from the table: "coupons"
  """
  coupons(
    """distinct select on columns"""
    distinct_on: [coupons_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [coupons_order_by!]

    """filter the rows returned"""
    where: coupons_bool_exp
  ): [coupons!]!

  """
  fetch aggregated fields from the table: "coupons"
  """
  coupons_aggregate(
    """distinct select on columns"""
    distinct_on: [coupons_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [coupons_order_by!]

    """filter the rows returned"""
    where: coupons_bool_exp
  ): coupons_aggregate!

  """fetch data from the table: "coupons" using primary key columns"""
  coupons_by_pk(id: uuid!): coupons

  """
  fetch data from the table in a streaming manner: "coupons"
  """
  coupons_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [coupons_stream_cursor_input]!

    """filter the rows returned"""
    where: coupons_bool_exp
  ): [coupons!]!

  """
  fetch data from the table: "currencies"
  """
  currencies(
    """distinct select on columns"""
    distinct_on: [currencies_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [currencies_order_by!]

    """filter the rows returned"""
    where: currencies_bool_exp
  ): [currencies!]!

  """
  fetch aggregated fields from the table: "currencies"
  """
  currencies_aggregate(
    """distinct select on columns"""
    distinct_on: [currencies_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [currencies_order_by!]

    """filter the rows returned"""
    where: currencies_bool_exp
  ): currencies_aggregate!

  """fetch data from the table: "currencies" using primary key columns"""
  currencies_by_pk(id: uuid!): currencies

  """
  fetch data from the table in a streaming manner: "currencies"
  """
  currencies_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [currencies_stream_cursor_input]!

    """filter the rows returned"""
    where: currencies_bool_exp
  ): [currencies!]!

  """
  fetch data from the table: "customer_addresses"
  """
  customer_addresses(
    """distinct select on columns"""
    distinct_on: [customer_addresses_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [customer_addresses_order_by!]

    """filter the rows returned"""
    where: customer_addresses_bool_exp
  ): [customer_addresses!]!

  """
  fetch aggregated fields from the table: "customer_addresses"
  """
  customer_addresses_aggregate(
    """distinct select on columns"""
    distinct_on: [customer_addresses_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [customer_addresses_order_by!]

    """filter the rows returned"""
    where: customer_addresses_bool_exp
  ): customer_addresses_aggregate!

  """
  fetch data from the table: "customer_addresses" using primary key columns
  """
  customer_addresses_by_pk(id: uuid!): customer_addresses

  """
  fetch data from the table in a streaming manner: "customer_addresses"
  """
  customer_addresses_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [customer_addresses_stream_cursor_input]!

    """filter the rows returned"""
    where: customer_addresses_bool_exp
  ): [customer_addresses!]!

  """
  fetch data from the table: "customer_stores"
  """
  customer_stores(
    """distinct select on columns"""
    distinct_on: [customer_stores_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [customer_stores_order_by!]

    """filter the rows returned"""
    where: customer_stores_bool_exp
  ): [customer_stores!]!

  """
  fetch aggregated fields from the table: "customer_stores"
  """
  customer_stores_aggregate(
    """distinct select on columns"""
    distinct_on: [customer_stores_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [customer_stores_order_by!]

    """filter the rows returned"""
    where: customer_stores_bool_exp
  ): customer_stores_aggregate!

  """fetch data from the table: "customer_stores" using primary key columns"""
  customer_stores_by_pk(id: uuid!): customer_stores

  """
  fetch data from the table in a streaming manner: "customer_stores"
  """
  customer_stores_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [customer_stores_stream_cursor_input]!

    """filter the rows returned"""
    where: customer_stores_bool_exp
  ): [customer_stores!]!

  """
  fetch data from the table: "customers"
  """
  customers(
    """distinct select on columns"""
    distinct_on: [customers_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [customers_order_by!]

    """filter the rows returned"""
    where: customers_bool_exp
  ): [customers!]!

  """
  fetch aggregated fields from the table: "customers"
  """
  customers_aggregate(
    """distinct select on columns"""
    distinct_on: [customers_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [customers_order_by!]

    """filter the rows returned"""
    where: customers_bool_exp
  ): customers_aggregate!

  """fetch data from the table: "customers" using primary key columns"""
  customers_by_pk(id: uuid!): customers

  """
  fetch data from the table in a streaming manner: "customers"
  """
  customers_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [customers_stream_cursor_input]!

    """filter the rows returned"""
    where: customers_bool_exp
  ): [customers!]!

  """
  fetch data from the table: "districts"
  """
  districts(
    """distinct select on columns"""
    distinct_on: [districts_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [districts_order_by!]

    """filter the rows returned"""
    where: districts_bool_exp
  ): [districts!]!

  """
  fetch aggregated fields from the table: "districts"
  """
  districts_aggregate(
    """distinct select on columns"""
    distinct_on: [districts_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [districts_order_by!]

    """filter the rows returned"""
    where: districts_bool_exp
  ): districts_aggregate!

  """fetch data from the table: "districts" using primary key columns"""
  districts_by_pk(id: uuid!): districts

  """
  fetch data from the table in a streaming manner: "districts"
  """
  districts_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [districts_stream_cursor_input]!

    """filter the rows returned"""
    where: districts_bool_exp
  ): [districts!]!

  """
  fetch data from the table: "ec_categories"
  """
  ec_categories(
    """distinct select on columns"""
    distinct_on: [ec_categories_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [ec_categories_order_by!]

    """filter the rows returned"""
    where: ec_categories_bool_exp
  ): [ec_categories!]!

  """
  fetch aggregated fields from the table: "ec_categories"
  """
  ec_categories_aggregate(
    """distinct select on columns"""
    distinct_on: [ec_categories_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [ec_categories_order_by!]

    """filter the rows returned"""
    where: ec_categories_bool_exp
  ): ec_categories_aggregate!

  """fetch data from the table: "ec_categories" using primary key columns"""
  ec_categories_by_pk(id: uuid!): ec_categories

  """
  fetch data from the table in a streaming manner: "ec_categories"
  """
  ec_categories_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [ec_categories_stream_cursor_input]!

    """filter the rows returned"""
    where: ec_categories_bool_exp
  ): [ec_categories!]!

  """
  fetch data from the table: "follows"
  """
  follows(
    """distinct select on columns"""
    distinct_on: [follows_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [follows_order_by!]

    """filter the rows returned"""
    where: follows_bool_exp
  ): [follows!]!

  """
  fetch aggregated fields from the table: "follows"
  """
  follows_aggregate(
    """distinct select on columns"""
    distinct_on: [follows_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [follows_order_by!]

    """filter the rows returned"""
    where: follows_bool_exp
  ): follows_aggregate!

  """fetch data from the table: "follows" using primary key columns"""
  follows_by_pk(id: uuid!): follows

  """
  fetch data from the table in a streaming manner: "follows"
  """
  follows_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [follows_stream_cursor_input]!

    """filter the rows returned"""
    where: follows_bool_exp
  ): [follows!]!

  """
  fetch data from the table: "form_submissions"
  """
  form_submissions(
    """distinct select on columns"""
    distinct_on: [form_submissions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [form_submissions_order_by!]

    """filter the rows returned"""
    where: form_submissions_bool_exp
  ): [form_submissions!]!

  """
  fetch aggregated fields from the table: "form_submissions"
  """
  form_submissions_aggregate(
    """distinct select on columns"""
    distinct_on: [form_submissions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [form_submissions_order_by!]

    """filter the rows returned"""
    where: form_submissions_bool_exp
  ): form_submissions_aggregate!

  """
  fetch data from the table: "form_submissions" using primary key columns
  """
  form_submissions_by_pk(id: uuid!): form_submissions

  """
  fetch data from the table in a streaming manner: "form_submissions"
  """
  form_submissions_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [form_submissions_stream_cursor_input]!

    """filter the rows returned"""
    where: form_submissions_bool_exp
  ): [form_submissions!]!

  """
  fetch data from the table: "forms"
  """
  forms(
    """distinct select on columns"""
    distinct_on: [forms_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [forms_order_by!]

    """filter the rows returned"""
    where: forms_bool_exp
  ): [forms!]!

  """
  fetch aggregated fields from the table: "forms"
  """
  forms_aggregate(
    """distinct select on columns"""
    distinct_on: [forms_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [forms_order_by!]

    """filter the rows returned"""
    where: forms_bool_exp
  ): forms_aggregate!

  """fetch data from the table: "forms" using primary key columns"""
  forms_by_pk(id: uuid!): forms

  """
  fetch data from the table in a streaming manner: "forms"
  """
  forms_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [forms_stream_cursor_input]!

    """filter the rows returned"""
    where: forms_bool_exp
  ): [forms!]!

  """
  fetch data from the table: "hashtags"
  """
  hashtags(
    """distinct select on columns"""
    distinct_on: [hashtags_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [hashtags_order_by!]

    """filter the rows returned"""
    where: hashtags_bool_exp
  ): [hashtags!]!

  """
  fetch aggregated fields from the table: "hashtags"
  """
  hashtags_aggregate(
    """distinct select on columns"""
    distinct_on: [hashtags_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [hashtags_order_by!]

    """filter the rows returned"""
    where: hashtags_bool_exp
  ): hashtags_aggregate!

  """fetch data from the table: "hashtags" using primary key columns"""
  hashtags_by_pk(id: uuid!): hashtags

  """
  fetch data from the table in a streaming manner: "hashtags"
  """
  hashtags_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [hashtags_stream_cursor_input]!

    """filter the rows returned"""
    where: hashtags_bool_exp
  ): [hashtags!]!

  """
  fetch data from the table: "inventory_levels"
  """
  inventory_levels(
    """distinct select on columns"""
    distinct_on: [inventory_levels_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [inventory_levels_order_by!]

    """filter the rows returned"""
    where: inventory_levels_bool_exp
  ): [inventory_levels!]!

  """
  fetch aggregated fields from the table: "inventory_levels"
  """
  inventory_levels_aggregate(
    """distinct select on columns"""
    distinct_on: [inventory_levels_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [inventory_levels_order_by!]

    """filter the rows returned"""
    where: inventory_levels_bool_exp
  ): inventory_levels_aggregate!

  """
  fetch data from the table: "inventory_levels" using primary key columns
  """
  inventory_levels_by_pk(id: uuid!): inventory_levels

  """
  fetch data from the table in a streaming manner: "inventory_levels"
  """
  inventory_levels_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [inventory_levels_stream_cursor_input]!

    """filter the rows returned"""
    where: inventory_levels_bool_exp
  ): [inventory_levels!]!

  """
  fetch data from the table: "inventory_locations"
  """
  inventory_locations(
    """distinct select on columns"""
    distinct_on: [inventory_locations_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [inventory_locations_order_by!]

    """filter the rows returned"""
    where: inventory_locations_bool_exp
  ): [inventory_locations!]!

  """
  fetch aggregated fields from the table: "inventory_locations"
  """
  inventory_locations_aggregate(
    """distinct select on columns"""
    distinct_on: [inventory_locations_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [inventory_locations_order_by!]

    """filter the rows returned"""
    where: inventory_locations_bool_exp
  ): inventory_locations_aggregate!

  """
  fetch data from the table: "inventory_locations" using primary key columns
  """
  inventory_locations_by_pk(id: uuid!): inventory_locations

  """
  fetch data from the table in a streaming manner: "inventory_locations"
  """
  inventory_locations_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [inventory_locations_stream_cursor_input]!

    """filter the rows returned"""
    where: inventory_locations_bool_exp
  ): [inventory_locations!]!

  """
  fetch data from the table: "likes"
  """
  likes(
    """distinct select on columns"""
    distinct_on: [likes_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [likes_order_by!]

    """filter the rows returned"""
    where: likes_bool_exp
  ): [likes!]!

  """
  fetch aggregated fields from the table: "likes"
  """
  likes_aggregate(
    """distinct select on columns"""
    distinct_on: [likes_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [likes_order_by!]

    """filter the rows returned"""
    where: likes_bool_exp
  ): likes_aggregate!

  """fetch data from the table: "likes" using primary key columns"""
  likes_by_pk(id: uuid!): likes

  """
  fetch data from the table in a streaming manner: "likes"
  """
  likes_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [likes_stream_cursor_input]!

    """filter the rows returned"""
    where: likes_bool_exp
  ): [likes!]!

  """
  fetch data from the table: "media_files"
  """
  media_files(
    """distinct select on columns"""
    distinct_on: [media_files_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [media_files_order_by!]

    """filter the rows returned"""
    where: media_files_bool_exp
  ): [media_files!]!

  """
  fetch aggregated fields from the table: "media_files"
  """
  media_files_aggregate(
    """distinct select on columns"""
    distinct_on: [media_files_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [media_files_order_by!]

    """filter the rows returned"""
    where: media_files_bool_exp
  ): media_files_aggregate!

  """fetch data from the table: "media_files" using primary key columns"""
  media_files_by_pk(id: uuid!): media_files

  """
  fetch data from the table in a streaming manner: "media_files"
  """
  media_files_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [media_files_stream_cursor_input]!

    """filter the rows returned"""
    where: media_files_bool_exp
  ): [media_files!]!

  """
  fetch data from the table: "media_folders"
  """
  media_folders(
    """distinct select on columns"""
    distinct_on: [media_folders_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [media_folders_order_by!]

    """filter the rows returned"""
    where: media_folders_bool_exp
  ): [media_folders!]!

  """
  fetch aggregated fields from the table: "media_folders"
  """
  media_folders_aggregate(
    """distinct select on columns"""
    distinct_on: [media_folders_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [media_folders_order_by!]

    """filter the rows returned"""
    where: media_folders_bool_exp
  ): media_folders_aggregate!

  """fetch data from the table: "media_folders" using primary key columns"""
  media_folders_by_pk(id: uuid!): media_folders

  """
  fetch data from the table in a streaming manner: "media_folders"
  """
  media_folders_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [media_folders_stream_cursor_input]!

    """filter the rows returned"""
    where: media_folders_bool_exp
  ): [media_folders!]!

  """
  fetch data from the table: "mentions"
  """
  mentions(
    """distinct select on columns"""
    distinct_on: [mentions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [mentions_order_by!]

    """filter the rows returned"""
    where: mentions_bool_exp
  ): [mentions!]!

  """
  fetch aggregated fields from the table: "mentions"
  """
  mentions_aggregate(
    """distinct select on columns"""
    distinct_on: [mentions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [mentions_order_by!]

    """filter the rows returned"""
    where: mentions_bool_exp
  ): mentions_aggregate!

  """fetch data from the table: "mentions" using primary key columns"""
  mentions_by_pk(id: uuid!): mentions

  """
  fetch data from the table in a streaming manner: "mentions"
  """
  mentions_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [mentions_stream_cursor_input]!

    """filter the rows returned"""
    where: mentions_bool_exp
  ): [mentions!]!

  """
  fetch data from the table: "menu_items"
  """
  menu_items(
    """distinct select on columns"""
    distinct_on: [menu_items_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [menu_items_order_by!]

    """filter the rows returned"""
    where: menu_items_bool_exp
  ): [menu_items!]!

  """
  fetch aggregated fields from the table: "menu_items"
  """
  menu_items_aggregate(
    """distinct select on columns"""
    distinct_on: [menu_items_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [menu_items_order_by!]

    """filter the rows returned"""
    where: menu_items_bool_exp
  ): menu_items_aggregate!

  """fetch data from the table: "menu_items" using primary key columns"""
  menu_items_by_pk(id: uuid!): menu_items

  """
  fetch data from the table in a streaming manner: "menu_items"
  """
  menu_items_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [menu_items_stream_cursor_input]!

    """filter the rows returned"""
    where: menu_items_bool_exp
  ): [menu_items!]!

  """
  fetch data from the table: "menus"
  """
  menus(
    """distinct select on columns"""
    distinct_on: [menus_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [menus_order_by!]

    """filter the rows returned"""
    where: menus_bool_exp
  ): [menus!]!

  """
  fetch aggregated fields from the table: "menus"
  """
  menus_aggregate(
    """distinct select on columns"""
    distinct_on: [menus_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [menus_order_by!]

    """filter the rows returned"""
    where: menus_bool_exp
  ): menus_aggregate!

  """fetch data from the table: "menus" using primary key columns"""
  menus_by_pk(id: uuid!): menus

  """
  fetch data from the table in a streaming manner: "menus"
  """
  menus_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [menus_stream_cursor_input]!

    """filter the rows returned"""
    where: menus_bool_exp
  ): [menus!]!

  """
  fetch data from the table: "message_reactions"
  """
  message_reactions(
    """distinct select on columns"""
    distinct_on: [message_reactions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [message_reactions_order_by!]

    """filter the rows returned"""
    where: message_reactions_bool_exp
  ): [message_reactions!]!

  """
  fetch aggregated fields from the table: "message_reactions"
  """
  message_reactions_aggregate(
    """distinct select on columns"""
    distinct_on: [message_reactions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [message_reactions_order_by!]

    """filter the rows returned"""
    where: message_reactions_bool_exp
  ): message_reactions_aggregate!

  """
  fetch data from the table: "message_reactions" using primary key columns
  """
  message_reactions_by_pk(id: uuid!): message_reactions

  """
  fetch data from the table in a streaming manner: "message_reactions"
  """
  message_reactions_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [message_reactions_stream_cursor_input]!

    """filter the rows returned"""
    where: message_reactions_bool_exp
  ): [message_reactions!]!

  """
  fetch data from the table: "messages"
  """
  messages(
    """distinct select on columns"""
    distinct_on: [messages_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [messages_order_by!]

    """filter the rows returned"""
    where: messages_bool_exp
  ): [messages!]!

  """
  fetch aggregated fields from the table: "messages"
  """
  messages_aggregate(
    """distinct select on columns"""
    distinct_on: [messages_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [messages_order_by!]

    """filter the rows returned"""
    where: messages_bool_exp
  ): messages_aggregate!

  """fetch data from the table: "messages" using primary key columns"""
  messages_by_pk(id: uuid!): messages

  """
  fetch data from the table in a streaming manner: "messages"
  """
  messages_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [messages_stream_cursor_input]!

    """filter the rows returned"""
    where: messages_bool_exp
  ): [messages!]!

  """
  fetch data from the table: "neighborhoods"
  """
  neighborhoods(
    """distinct select on columns"""
    distinct_on: [neighborhoods_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [neighborhoods_order_by!]

    """filter the rows returned"""
    where: neighborhoods_bool_exp
  ): [neighborhoods!]!

  """
  fetch aggregated fields from the table: "neighborhoods"
  """
  neighborhoods_aggregate(
    """distinct select on columns"""
    distinct_on: [neighborhoods_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [neighborhoods_order_by!]

    """filter the rows returned"""
    where: neighborhoods_bool_exp
  ): neighborhoods_aggregate!

  """fetch data from the table: "neighborhoods" using primary key columns"""
  neighborhoods_by_pk(id: uuid!): neighborhoods

  """
  fetch data from the table in a streaming manner: "neighborhoods"
  """
  neighborhoods_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [neighborhoods_stream_cursor_input]!

    """filter the rows returned"""
    where: neighborhoods_bool_exp
  ): [neighborhoods!]!

  """
  fetch data from the table: "notifications"
  """
  notifications(
    """distinct select on columns"""
    distinct_on: [notifications_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notifications_order_by!]

    """filter the rows returned"""
    where: notifications_bool_exp
  ): [notifications!]!

  """
  fetch aggregated fields from the table: "notifications"
  """
  notifications_aggregate(
    """distinct select on columns"""
    distinct_on: [notifications_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notifications_order_by!]

    """filter the rows returned"""
    where: notifications_bool_exp
  ): notifications_aggregate!

  """fetch data from the table: "notifications" using primary key columns"""
  notifications_by_pk(id: uuid!): notifications

  """
  fetch data from the table in a streaming manner: "notifications"
  """
  notifications_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [notifications_stream_cursor_input]!

    """filter the rows returned"""
    where: notifications_bool_exp
  ): [notifications!]!

  """
  fetch data from the table: "order_coupons"
  """
  order_coupons(
    """distinct select on columns"""
    distinct_on: [order_coupons_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [order_coupons_order_by!]

    """filter the rows returned"""
    where: order_coupons_bool_exp
  ): [order_coupons!]!

  """
  fetch aggregated fields from the table: "order_coupons"
  """
  order_coupons_aggregate(
    """distinct select on columns"""
    distinct_on: [order_coupons_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [order_coupons_order_by!]

    """filter the rows returned"""
    where: order_coupons_bool_exp
  ): order_coupons_aggregate!

  """fetch data from the table: "order_coupons" using primary key columns"""
  order_coupons_by_pk(id: uuid!): order_coupons

  """
  fetch data from the table in a streaming manner: "order_coupons"
  """
  order_coupons_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [order_coupons_stream_cursor_input]!

    """filter the rows returned"""
    where: order_coupons_bool_exp
  ): [order_coupons!]!

  """
  fetch data from the table: "order_items"
  """
  order_items(
    """distinct select on columns"""
    distinct_on: [order_items_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [order_items_order_by!]

    """filter the rows returned"""
    where: order_items_bool_exp
  ): [order_items!]!

  """
  fetch aggregated fields from the table: "order_items"
  """
  order_items_aggregate(
    """distinct select on columns"""
    distinct_on: [order_items_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [order_items_order_by!]

    """filter the rows returned"""
    where: order_items_bool_exp
  ): order_items_aggregate!

  """fetch data from the table: "order_items" using primary key columns"""
  order_items_by_pk(id: uuid!): order_items

  """
  fetch data from the table in a streaming manner: "order_items"
  """
  order_items_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [order_items_stream_cursor_input]!

    """filter the rows returned"""
    where: order_items_bool_exp
  ): [order_items!]!

  """
  fetch data from the table: "order_statuses"
  """
  order_statuses(
    """distinct select on columns"""
    distinct_on: [order_statuses_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [order_statuses_order_by!]

    """filter the rows returned"""
    where: order_statuses_bool_exp
  ): [order_statuses!]!

  """
  fetch aggregated fields from the table: "order_statuses"
  """
  order_statuses_aggregate(
    """distinct select on columns"""
    distinct_on: [order_statuses_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [order_statuses_order_by!]

    """filter the rows returned"""
    where: order_statuses_bool_exp
  ): order_statuses_aggregate!

  """fetch data from the table: "order_statuses" using primary key columns"""
  order_statuses_by_pk(id: uuid!): order_statuses

  """
  fetch data from the table in a streaming manner: "order_statuses"
  """
  order_statuses_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [order_statuses_stream_cursor_input]!

    """filter the rows returned"""
    where: order_statuses_bool_exp
  ): [order_statuses!]!

  """
  fetch data from the table: "orders"
  """
  orders(
    """distinct select on columns"""
    distinct_on: [orders_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [orders_order_by!]

    """filter the rows returned"""
    where: orders_bool_exp
  ): [orders!]!

  """
  fetch aggregated fields from the table: "orders"
  """
  orders_aggregate(
    """distinct select on columns"""
    distinct_on: [orders_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [orders_order_by!]

    """filter the rows returned"""
    where: orders_bool_exp
  ): orders_aggregate!

  """fetch data from the table: "orders" using primary key columns"""
  orders_by_pk(id: uuid!): orders

  """
  fetch data from the table in a streaming manner: "orders"
  """
  orders_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [orders_stream_cursor_input]!

    """filter the rows returned"""
    where: orders_bool_exp
  ): [orders!]!

  """
  fetch data from the table: "page_templates"
  """
  page_templates(
    """distinct select on columns"""
    distinct_on: [page_templates_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [page_templates_order_by!]

    """filter the rows returned"""
    where: page_templates_bool_exp
  ): [page_templates!]!

  """
  fetch aggregated fields from the table: "page_templates"
  """
  page_templates_aggregate(
    """distinct select on columns"""
    distinct_on: [page_templates_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [page_templates_order_by!]

    """filter the rows returned"""
    where: page_templates_bool_exp
  ): page_templates_aggregate!

  """fetch data from the table: "page_templates" using primary key columns"""
  page_templates_by_pk(id: uuid!): page_templates

  """
  fetch data from the table in a streaming manner: "page_templates"
  """
  page_templates_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [page_templates_stream_cursor_input]!

    """filter the rows returned"""
    where: page_templates_bool_exp
  ): [page_templates!]!

  """
  fetch data from the table: "page_versions"
  """
  page_versions(
    """distinct select on columns"""
    distinct_on: [page_versions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [page_versions_order_by!]

    """filter the rows returned"""
    where: page_versions_bool_exp
  ): [page_versions!]!

  """
  fetch aggregated fields from the table: "page_versions"
  """
  page_versions_aggregate(
    """distinct select on columns"""
    distinct_on: [page_versions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [page_versions_order_by!]

    """filter the rows returned"""
    where: page_versions_bool_exp
  ): page_versions_aggregate!

  """fetch data from the table: "page_versions" using primary key columns"""
  page_versions_by_pk(id: uuid!): page_versions

  """
  fetch data from the table in a streaming manner: "page_versions"
  """
  page_versions_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [page_versions_stream_cursor_input]!

    """filter the rows returned"""
    where: page_versions_bool_exp
  ): [page_versions!]!

  """
  fetch data from the table: "pages"
  """
  pages(
    """distinct select on columns"""
    distinct_on: [pages_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [pages_order_by!]

    """filter the rows returned"""
    where: pages_bool_exp
  ): [pages!]!

  """
  fetch aggregated fields from the table: "pages"
  """
  pages_aggregate(
    """distinct select on columns"""
    distinct_on: [pages_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [pages_order_by!]

    """filter the rows returned"""
    where: pages_bool_exp
  ): pages_aggregate!

  """fetch data from the table: "pages" using primary key columns"""
  pages_by_pk(id: uuid!): pages

  """
  fetch data from the table in a streaming manner: "pages"
  """
  pages_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [pages_stream_cursor_input]!

    """filter the rows returned"""
    where: pages_bool_exp
  ): [pages!]!

  """
  fetch data from the table: "payment_methods"
  """
  payment_methods(
    """distinct select on columns"""
    distinct_on: [payment_methods_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payment_methods_order_by!]

    """filter the rows returned"""
    where: payment_methods_bool_exp
  ): [payment_methods!]!

  """
  fetch aggregated fields from the table: "payment_methods"
  """
  payment_methods_aggregate(
    """distinct select on columns"""
    distinct_on: [payment_methods_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payment_methods_order_by!]

    """filter the rows returned"""
    where: payment_methods_bool_exp
  ): payment_methods_aggregate!

  """fetch data from the table: "payment_methods" using primary key columns"""
  payment_methods_by_pk(id: uuid!): payment_methods

  """
  fetch data from the table in a streaming manner: "payment_methods"
  """
  payment_methods_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [payment_methods_stream_cursor_input]!

    """filter the rows returned"""
    where: payment_methods_bool_exp
  ): [payment_methods!]!

  """
  fetch data from the table: "payment_statuses"
  """
  payment_statuses(
    """distinct select on columns"""
    distinct_on: [payment_statuses_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payment_statuses_order_by!]

    """filter the rows returned"""
    where: payment_statuses_bool_exp
  ): [payment_statuses!]!

  """
  fetch aggregated fields from the table: "payment_statuses"
  """
  payment_statuses_aggregate(
    """distinct select on columns"""
    distinct_on: [payment_statuses_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payment_statuses_order_by!]

    """filter the rows returned"""
    where: payment_statuses_bool_exp
  ): payment_statuses_aggregate!

  """
  fetch data from the table: "payment_statuses" using primary key columns
  """
  payment_statuses_by_pk(id: uuid!): payment_statuses

  """
  fetch data from the table in a streaming manner: "payment_statuses"
  """
  payment_statuses_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [payment_statuses_stream_cursor_input]!

    """filter the rows returned"""
    where: payment_statuses_bool_exp
  ): [payment_statuses!]!

  """
  fetch data from the table: "payments"
  """
  payments(
    """distinct select on columns"""
    distinct_on: [payments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payments_order_by!]

    """filter the rows returned"""
    where: payments_bool_exp
  ): [payments!]!

  """
  fetch aggregated fields from the table: "payments"
  """
  payments_aggregate(
    """distinct select on columns"""
    distinct_on: [payments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payments_order_by!]

    """filter the rows returned"""
    where: payments_bool_exp
  ): payments_aggregate!

  """fetch data from the table: "payments" using primary key columns"""
  payments_by_pk(id: uuid!): payments

  """
  fetch data from the table in a streaming manner: "payments"
  """
  payments_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [payments_stream_cursor_input]!

    """filter the rows returned"""
    where: payments_bool_exp
  ): [payments!]!

  """
  fetch data from the table: "permissions"
  """
  permissions(
    """distinct select on columns"""
    distinct_on: [permissions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [permissions_order_by!]

    """filter the rows returned"""
    where: permissions_bool_exp
  ): [permissions!]!

  """
  fetch aggregated fields from the table: "permissions"
  """
  permissions_aggregate(
    """distinct select on columns"""
    distinct_on: [permissions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [permissions_order_by!]

    """filter the rows returned"""
    where: permissions_bool_exp
  ): permissions_aggregate!

  """fetch data from the table: "permissions" using primary key columns"""
  permissions_by_pk(id: uuid!): permissions

  """
  fetch data from the table in a streaming manner: "permissions"
  """
  permissions_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [permissions_stream_cursor_input]!

    """filter the rows returned"""
    where: permissions_bool_exp
  ): [permissions!]!

  """
  fetch data from the table: "post_hashtags"
  """
  post_hashtags(
    """distinct select on columns"""
    distinct_on: [post_hashtags_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [post_hashtags_order_by!]

    """filter the rows returned"""
    where: post_hashtags_bool_exp
  ): [post_hashtags!]!

  """
  fetch aggregated fields from the table: "post_hashtags"
  """
  post_hashtags_aggregate(
    """distinct select on columns"""
    distinct_on: [post_hashtags_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [post_hashtags_order_by!]

    """filter the rows returned"""
    where: post_hashtags_bool_exp
  ): post_hashtags_aggregate!

  """fetch data from the table: "post_hashtags" using primary key columns"""
  post_hashtags_by_pk(id: uuid!): post_hashtags

  """
  fetch data from the table in a streaming manner: "post_hashtags"
  """
  post_hashtags_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [post_hashtags_stream_cursor_input]!

    """filter the rows returned"""
    where: post_hashtags_bool_exp
  ): [post_hashtags!]!

  """
  fetch data from the table: "post_media"
  """
  post_media(
    """distinct select on columns"""
    distinct_on: [post_media_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [post_media_order_by!]

    """filter the rows returned"""
    where: post_media_bool_exp
  ): [post_media!]!

  """
  fetch aggregated fields from the table: "post_media"
  """
  post_media_aggregate(
    """distinct select on columns"""
    distinct_on: [post_media_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [post_media_order_by!]

    """filter the rows returned"""
    where: post_media_bool_exp
  ): post_media_aggregate!

  """fetch data from the table: "post_media" using primary key columns"""
  post_media_by_pk(id: uuid!): post_media

  """
  fetch data from the table in a streaming manner: "post_media"
  """
  post_media_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [post_media_stream_cursor_input]!

    """filter the rows returned"""
    where: post_media_bool_exp
  ): [post_media!]!

  """
  fetch data from the table: "posts"
  """
  posts(
    """distinct select on columns"""
    distinct_on: [posts_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [posts_order_by!]

    """filter the rows returned"""
    where: posts_bool_exp
  ): [posts!]!

  """
  fetch aggregated fields from the table: "posts"
  """
  posts_aggregate(
    """distinct select on columns"""
    distinct_on: [posts_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [posts_order_by!]

    """filter the rows returned"""
    where: posts_bool_exp
  ): posts_aggregate!

  """fetch data from the table: "posts" using primary key columns"""
  posts_by_pk(id: uuid!): posts

  """
  fetch data from the table in a streaming manner: "posts"
  """
  posts_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [posts_stream_cursor_input]!

    """filter the rows returned"""
    where: posts_bool_exp
  ): [posts!]!

  """
  fetch data from the table: "product_categories"
  """
  product_categories(
    """distinct select on columns"""
    distinct_on: [product_categories_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_categories_order_by!]

    """filter the rows returned"""
    where: product_categories_bool_exp
  ): [product_categories!]!

  """
  fetch aggregated fields from the table: "product_categories"
  """
  product_categories_aggregate(
    """distinct select on columns"""
    distinct_on: [product_categories_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_categories_order_by!]

    """filter the rows returned"""
    where: product_categories_bool_exp
  ): product_categories_aggregate!

  """
  fetch data from the table: "product_categories" using primary key columns
  """
  product_categories_by_pk(id: uuid!): product_categories

  """
  fetch data from the table in a streaming manner: "product_categories"
  """
  product_categories_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [product_categories_stream_cursor_input]!

    """filter the rows returned"""
    where: product_categories_bool_exp
  ): [product_categories!]!

  """
  fetch data from the table: "product_collections"
  """
  product_collections(
    """distinct select on columns"""
    distinct_on: [product_collections_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_collections_order_by!]

    """filter the rows returned"""
    where: product_collections_bool_exp
  ): [product_collections!]!

  """
  fetch aggregated fields from the table: "product_collections"
  """
  product_collections_aggregate(
    """distinct select on columns"""
    distinct_on: [product_collections_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_collections_order_by!]

    """filter the rows returned"""
    where: product_collections_bool_exp
  ): product_collections_aggregate!

  """
  fetch data from the table: "product_collections" using primary key columns
  """
  product_collections_by_pk(id: uuid!): product_collections

  """
  fetch data from the table in a streaming manner: "product_collections"
  """
  product_collections_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [product_collections_stream_cursor_input]!

    """filter the rows returned"""
    where: product_collections_bool_exp
  ): [product_collections!]!

  """
  fetch data from the table: "product_images"
  """
  product_images(
    """distinct select on columns"""
    distinct_on: [product_images_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_images_order_by!]

    """filter the rows returned"""
    where: product_images_bool_exp
  ): [product_images!]!

  """
  fetch aggregated fields from the table: "product_images"
  """
  product_images_aggregate(
    """distinct select on columns"""
    distinct_on: [product_images_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_images_order_by!]

    """filter the rows returned"""
    where: product_images_bool_exp
  ): product_images_aggregate!

  """fetch data from the table: "product_images" using primary key columns"""
  product_images_by_pk(id: uuid!): product_images

  """
  fetch data from the table in a streaming manner: "product_images"
  """
  product_images_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [product_images_stream_cursor_input]!

    """filter the rows returned"""
    where: product_images_bool_exp
  ): [product_images!]!

  """
  fetch data from the table: "product_variants"
  """
  product_variants(
    """distinct select on columns"""
    distinct_on: [product_variants_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_variants_order_by!]

    """filter the rows returned"""
    where: product_variants_bool_exp
  ): [product_variants!]!

  """
  fetch aggregated fields from the table: "product_variants"
  """
  product_variants_aggregate(
    """distinct select on columns"""
    distinct_on: [product_variants_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_variants_order_by!]

    """filter the rows returned"""
    where: product_variants_bool_exp
  ): product_variants_aggregate!

  """
  fetch data from the table: "product_variants" using primary key columns
  """
  product_variants_by_pk(id: uuid!): product_variants

  """
  fetch data from the table in a streaming manner: "product_variants"
  """
  product_variants_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [product_variants_stream_cursor_input]!

    """filter the rows returned"""
    where: product_variants_bool_exp
  ): [product_variants!]!

  """
  fetch data from the table: "products"
  """
  products(
    """distinct select on columns"""
    distinct_on: [products_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [products_order_by!]

    """filter the rows returned"""
    where: products_bool_exp
  ): [products!]!

  """
  fetch aggregated fields from the table: "products"
  """
  products_aggregate(
    """distinct select on columns"""
    distinct_on: [products_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [products_order_by!]

    """filter the rows returned"""
    where: products_bool_exp
  ): products_aggregate!

  """fetch data from the table: "products" using primary key columns"""
  products_by_pk(id: uuid!): products

  """
  fetch data from the table in a streaming manner: "products"
  """
  products_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [products_stream_cursor_input]!

    """filter the rows returned"""
    where: products_bool_exp
  ): [products!]!

  """
  fetch data from the table: "redirects"
  """
  redirects(
    """distinct select on columns"""
    distinct_on: [redirects_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [redirects_order_by!]

    """filter the rows returned"""
    where: redirects_bool_exp
  ): [redirects!]!

  """
  fetch aggregated fields from the table: "redirects"
  """
  redirects_aggregate(
    """distinct select on columns"""
    distinct_on: [redirects_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [redirects_order_by!]

    """filter the rows returned"""
    where: redirects_bool_exp
  ): redirects_aggregate!

  """fetch data from the table: "redirects" using primary key columns"""
  redirects_by_pk(id: uuid!): redirects

  """
  fetch data from the table in a streaming manner: "redirects"
  """
  redirects_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [redirects_stream_cursor_input]!

    """filter the rows returned"""
    where: redirects_bool_exp
  ): [redirects!]!

  """
  fetch data from the table: "regions"
  """
  regions(
    """distinct select on columns"""
    distinct_on: [regions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [regions_order_by!]

    """filter the rows returned"""
    where: regions_bool_exp
  ): [regions!]!

  """
  fetch aggregated fields from the table: "regions"
  """
  regions_aggregate(
    """distinct select on columns"""
    distinct_on: [regions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [regions_order_by!]

    """filter the rows returned"""
    where: regions_bool_exp
  ): regions_aggregate!

  """fetch data from the table: "regions" using primary key columns"""
  regions_by_pk(id: uuid!): regions

  """
  fetch data from the table in a streaming manner: "regions"
  """
  regions_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [regions_stream_cursor_input]!

    """filter the rows returned"""
    where: regions_bool_exp
  ): [regions!]!

  """
  fetch data from the table: "related_products"
  """
  related_products(
    """distinct select on columns"""
    distinct_on: [related_products_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [related_products_order_by!]

    """filter the rows returned"""
    where: related_products_bool_exp
  ): [related_products!]!

  """
  fetch aggregated fields from the table: "related_products"
  """
  related_products_aggregate(
    """distinct select on columns"""
    distinct_on: [related_products_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [related_products_order_by!]

    """filter the rows returned"""
    where: related_products_bool_exp
  ): related_products_aggregate!

  """
  fetch data from the table: "related_products" using primary key columns
  """
  related_products_by_pk(id: uuid!): related_products

  """
  fetch data from the table in a streaming manner: "related_products"
  """
  related_products_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [related_products_stream_cursor_input]!

    """filter the rows returned"""
    where: related_products_bool_exp
  ): [related_products!]!

  """
  fetch data from the table: "report_statuses"
  """
  report_statuses(
    """distinct select on columns"""
    distinct_on: [report_statuses_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [report_statuses_order_by!]

    """filter the rows returned"""
    where: report_statuses_bool_exp
  ): [report_statuses!]!

  """
  fetch aggregated fields from the table: "report_statuses"
  """
  report_statuses_aggregate(
    """distinct select on columns"""
    distinct_on: [report_statuses_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [report_statuses_order_by!]

    """filter the rows returned"""
    where: report_statuses_bool_exp
  ): report_statuses_aggregate!

  """fetch data from the table: "report_statuses" using primary key columns"""
  report_statuses_by_pk(id: uuid!): report_statuses

  """
  fetch data from the table in a streaming manner: "report_statuses"
  """
  report_statuses_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [report_statuses_stream_cursor_input]!

    """filter the rows returned"""
    where: report_statuses_bool_exp
  ): [report_statuses!]!

  """
  fetch data from the table: "reports"
  """
  reports(
    """distinct select on columns"""
    distinct_on: [reports_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [reports_order_by!]

    """filter the rows returned"""
    where: reports_bool_exp
  ): [reports!]!

  """
  fetch aggregated fields from the table: "reports"
  """
  reports_aggregate(
    """distinct select on columns"""
    distinct_on: [reports_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [reports_order_by!]

    """filter the rows returned"""
    where: reports_bool_exp
  ): reports_aggregate!

  """fetch data from the table: "reports" using primary key columns"""
  reports_by_pk(id: uuid!): reports

  """
  fetch data from the table in a streaming manner: "reports"
  """
  reports_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [reports_stream_cursor_input]!

    """filter the rows returned"""
    where: reports_bool_exp
  ): [reports!]!

  """
  fetch data from the table: "return_requests"
  """
  return_requests(
    """distinct select on columns"""
    distinct_on: [return_requests_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [return_requests_order_by!]

    """filter the rows returned"""
    where: return_requests_bool_exp
  ): [return_requests!]!

  """
  fetch aggregated fields from the table: "return_requests"
  """
  return_requests_aggregate(
    """distinct select on columns"""
    distinct_on: [return_requests_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [return_requests_order_by!]

    """filter the rows returned"""
    where: return_requests_bool_exp
  ): return_requests_aggregate!

  """fetch data from the table: "return_requests" using primary key columns"""
  return_requests_by_pk(id: uuid!): return_requests

  """
  fetch data from the table in a streaming manner: "return_requests"
  """
  return_requests_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [return_requests_stream_cursor_input]!

    """filter the rows returned"""
    where: return_requests_bool_exp
  ): [return_requests!]!

  """
  fetch data from the table: "return_statuses"
  """
  return_statuses(
    """distinct select on columns"""
    distinct_on: [return_statuses_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [return_statuses_order_by!]

    """filter the rows returned"""
    where: return_statuses_bool_exp
  ): [return_statuses!]!

  """
  fetch aggregated fields from the table: "return_statuses"
  """
  return_statuses_aggregate(
    """distinct select on columns"""
    distinct_on: [return_statuses_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [return_statuses_order_by!]

    """filter the rows returned"""
    where: return_statuses_bool_exp
  ): return_statuses_aggregate!

  """fetch data from the table: "return_statuses" using primary key columns"""
  return_statuses_by_pk(id: uuid!): return_statuses

  """
  fetch data from the table in a streaming manner: "return_statuses"
  """
  return_statuses_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [return_statuses_stream_cursor_input]!

    """filter the rows returned"""
    where: return_statuses_bool_exp
  ): [return_statuses!]!

  """
  fetch data from the table: "reviews"
  """
  reviews(
    """distinct select on columns"""
    distinct_on: [reviews_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [reviews_order_by!]

    """filter the rows returned"""
    where: reviews_bool_exp
  ): [reviews!]!

  """
  fetch aggregated fields from the table: "reviews"
  """
  reviews_aggregate(
    """distinct select on columns"""
    distinct_on: [reviews_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [reviews_order_by!]

    """filter the rows returned"""
    where: reviews_bool_exp
  ): reviews_aggregate!

  """fetch data from the table: "reviews" using primary key columns"""
  reviews_by_pk(id: uuid!): reviews

  """
  fetch data from the table in a streaming manner: "reviews"
  """
  reviews_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [reviews_stream_cursor_input]!

    """filter the rows returned"""
    where: reviews_bool_exp
  ): [reviews!]!

  """
  fetch data from the table: "role_permissions"
  """
  role_permissions(
    """distinct select on columns"""
    distinct_on: [role_permissions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [role_permissions_order_by!]

    """filter the rows returned"""
    where: role_permissions_bool_exp
  ): [role_permissions!]!

  """
  fetch aggregated fields from the table: "role_permissions"
  """
  role_permissions_aggregate(
    """distinct select on columns"""
    distinct_on: [role_permissions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [role_permissions_order_by!]

    """filter the rows returned"""
    where: role_permissions_bool_exp
  ): role_permissions_aggregate!

  """
  fetch data from the table: "role_permissions" using primary key columns
  """
  role_permissions_by_pk(id: uuid!): role_permissions

  """
  fetch data from the table in a streaming manner: "role_permissions"
  """
  role_permissions_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [role_permissions_stream_cursor_input]!

    """filter the rows returned"""
    where: role_permissions_bool_exp
  ): [role_permissions!]!

  """
  fetch data from the table: "roles"
  """
  roles(
    """distinct select on columns"""
    distinct_on: [roles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [roles_order_by!]

    """filter the rows returned"""
    where: roles_bool_exp
  ): [roles!]!

  """
  fetch aggregated fields from the table: "roles"
  """
  roles_aggregate(
    """distinct select on columns"""
    distinct_on: [roles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [roles_order_by!]

    """filter the rows returned"""
    where: roles_bool_exp
  ): roles_aggregate!

  """fetch data from the table: "roles" using primary key columns"""
  roles_by_pk(id: uuid!): roles

  """
  fetch data from the table in a streaming manner: "roles"
  """
  roles_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [roles_stream_cursor_input]!

    """filter the rows returned"""
    where: roles_bool_exp
  ): [roles!]!

  """
  fetch data from the table: "seo_settings"
  """
  seo_settings(
    """distinct select on columns"""
    distinct_on: [seo_settings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [seo_settings_order_by!]

    """filter the rows returned"""
    where: seo_settings_bool_exp
  ): [seo_settings!]!

  """
  fetch aggregated fields from the table: "seo_settings"
  """
  seo_settings_aggregate(
    """distinct select on columns"""
    distinct_on: [seo_settings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [seo_settings_order_by!]

    """filter the rows returned"""
    where: seo_settings_bool_exp
  ): seo_settings_aggregate!

  """fetch data from the table: "seo_settings" using primary key columns"""
  seo_settings_by_pk(id: uuid!): seo_settings

  """
  fetch data from the table in a streaming manner: "seo_settings"
  """
  seo_settings_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [seo_settings_stream_cursor_input]!

    """filter the rows returned"""
    where: seo_settings_bool_exp
  ): [seo_settings!]!

  """
  fetch data from the table: "shipment_statuses"
  """
  shipment_statuses(
    """distinct select on columns"""
    distinct_on: [shipment_statuses_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [shipment_statuses_order_by!]

    """filter the rows returned"""
    where: shipment_statuses_bool_exp
  ): [shipment_statuses!]!

  """
  fetch aggregated fields from the table: "shipment_statuses"
  """
  shipment_statuses_aggregate(
    """distinct select on columns"""
    distinct_on: [shipment_statuses_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [shipment_statuses_order_by!]

    """filter the rows returned"""
    where: shipment_statuses_bool_exp
  ): shipment_statuses_aggregate!

  """
  fetch data from the table: "shipment_statuses" using primary key columns
  """
  shipment_statuses_by_pk(id: uuid!): shipment_statuses

  """
  fetch data from the table in a streaming manner: "shipment_statuses"
  """
  shipment_statuses_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [shipment_statuses_stream_cursor_input]!

    """filter the rows returned"""
    where: shipment_statuses_bool_exp
  ): [shipment_statuses!]!

  """
  fetch data from the table: "shipments"
  """
  shipments(
    """distinct select on columns"""
    distinct_on: [shipments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [shipments_order_by!]

    """filter the rows returned"""
    where: shipments_bool_exp
  ): [shipments!]!

  """
  fetch aggregated fields from the table: "shipments"
  """
  shipments_aggregate(
    """distinct select on columns"""
    distinct_on: [shipments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [shipments_order_by!]

    """filter the rows returned"""
    where: shipments_bool_exp
  ): shipments_aggregate!

  """fetch data from the table: "shipments" using primary key columns"""
  shipments_by_pk(id: uuid!): shipments

  """
  fetch data from the table in a streaming manner: "shipments"
  """
  shipments_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [shipments_stream_cursor_input]!

    """filter the rows returned"""
    where: shipments_bool_exp
  ): [shipments!]!

  """
  fetch data from the table: "shipping_carriers"
  """
  shipping_carriers(
    """distinct select on columns"""
    distinct_on: [shipping_carriers_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [shipping_carriers_order_by!]

    """filter the rows returned"""
    where: shipping_carriers_bool_exp
  ): [shipping_carriers!]!

  """
  fetch aggregated fields from the table: "shipping_carriers"
  """
  shipping_carriers_aggregate(
    """distinct select on columns"""
    distinct_on: [shipping_carriers_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [shipping_carriers_order_by!]

    """filter the rows returned"""
    where: shipping_carriers_bool_exp
  ): shipping_carriers_aggregate!

  """
  fetch data from the table: "shipping_carriers" using primary key columns
  """
  shipping_carriers_by_pk(id: uuid!): shipping_carriers

  """
  fetch data from the table in a streaming manner: "shipping_carriers"
  """
  shipping_carriers_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [shipping_carriers_stream_cursor_input]!

    """filter the rows returned"""
    where: shipping_carriers_bool_exp
  ): [shipping_carriers!]!

  """
  fetch data from the table: "site_authors"
  """
  site_authors(
    """distinct select on columns"""
    distinct_on: [site_authors_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [site_authors_order_by!]

    """filter the rows returned"""
    where: site_authors_bool_exp
  ): [site_authors!]!

  """
  fetch aggregated fields from the table: "site_authors"
  """
  site_authors_aggregate(
    """distinct select on columns"""
    distinct_on: [site_authors_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [site_authors_order_by!]

    """filter the rows returned"""
    where: site_authors_bool_exp
  ): site_authors_aggregate!

  """fetch data from the table: "site_authors" using primary key columns"""
  site_authors_by_pk(id: uuid!): site_authors

  """
  fetch data from the table in a streaming manner: "site_authors"
  """
  site_authors_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [site_authors_stream_cursor_input]!

    """filter the rows returned"""
    where: site_authors_bool_exp
  ): [site_authors!]!

  """
  fetch data from the table: "sites"
  """
  sites(
    """distinct select on columns"""
    distinct_on: [sites_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [sites_order_by!]

    """filter the rows returned"""
    where: sites_bool_exp
  ): [sites!]!

  """
  fetch aggregated fields from the table: "sites"
  """
  sites_aggregate(
    """distinct select on columns"""
    distinct_on: [sites_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [sites_order_by!]

    """filter the rows returned"""
    where: sites_bool_exp
  ): sites_aggregate!

  """fetch data from the table: "sites" using primary key columns"""
  sites_by_pk(id: uuid!): sites

  """
  fetch data from the table in a streaming manner: "sites"
  """
  sites_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [sites_stream_cursor_input]!

    """filter the rows returned"""
    where: sites_bool_exp
  ): [sites!]!

  """
  fetch data from the table: "sizes"
  """
  sizes(
    """distinct select on columns"""
    distinct_on: [sizes_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [sizes_order_by!]

    """filter the rows returned"""
    where: sizes_bool_exp
  ): [sizes!]!

  """
  fetch aggregated fields from the table: "sizes"
  """
  sizes_aggregate(
    """distinct select on columns"""
    distinct_on: [sizes_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [sizes_order_by!]

    """filter the rows returned"""
    where: sizes_bool_exp
  ): sizes_aggregate!

  """fetch data from the table: "sizes" using primary key columns"""
  sizes_by_pk(id: uuid!): sizes

  """
  fetch data from the table in a streaming manner: "sizes"
  """
  sizes_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [sizes_stream_cursor_input]!

    """filter the rows returned"""
    where: sizes_bool_exp
  ): [sizes!]!

  """
  fetch data from the table: "store_currencies"
  """
  store_currencies(
    """distinct select on columns"""
    distinct_on: [store_currencies_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [store_currencies_order_by!]

    """filter the rows returned"""
    where: store_currencies_bool_exp
  ): [store_currencies!]!

  """
  fetch aggregated fields from the table: "store_currencies"
  """
  store_currencies_aggregate(
    """distinct select on columns"""
    distinct_on: [store_currencies_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [store_currencies_order_by!]

    """filter the rows returned"""
    where: store_currencies_bool_exp
  ): store_currencies_aggregate!

  """
  fetch data from the table: "store_currencies" using primary key columns
  """
  store_currencies_by_pk(id: uuid!): store_currencies

  """
  fetch data from the table in a streaming manner: "store_currencies"
  """
  store_currencies_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [store_currencies_stream_cursor_input]!

    """filter the rows returned"""
    where: store_currencies_bool_exp
  ): [store_currencies!]!

  """
  fetch data from the table: "store_payment_methods"
  """
  store_payment_methods(
    """distinct select on columns"""
    distinct_on: [store_payment_methods_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [store_payment_methods_order_by!]

    """filter the rows returned"""
    where: store_payment_methods_bool_exp
  ): [store_payment_methods!]!

  """
  fetch aggregated fields from the table: "store_payment_methods"
  """
  store_payment_methods_aggregate(
    """distinct select on columns"""
    distinct_on: [store_payment_methods_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [store_payment_methods_order_by!]

    """filter the rows returned"""
    where: store_payment_methods_bool_exp
  ): store_payment_methods_aggregate!

  """
  fetch data from the table: "store_payment_methods" using primary key columns
  """
  store_payment_methods_by_pk(id: uuid!): store_payment_methods

  """
  fetch data from the table in a streaming manner: "store_payment_methods"
  """
  store_payment_methods_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [store_payment_methods_stream_cursor_input]!

    """filter the rows returned"""
    where: store_payment_methods_bool_exp
  ): [store_payment_methods!]!

  """
  fetch data from the table: "store_shipping_carriers"
  """
  store_shipping_carriers(
    """distinct select on columns"""
    distinct_on: [store_shipping_carriers_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [store_shipping_carriers_order_by!]

    """filter the rows returned"""
    where: store_shipping_carriers_bool_exp
  ): [store_shipping_carriers!]!

  """
  fetch aggregated fields from the table: "store_shipping_carriers"
  """
  store_shipping_carriers_aggregate(
    """distinct select on columns"""
    distinct_on: [store_shipping_carriers_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [store_shipping_carriers_order_by!]

    """filter the rows returned"""
    where: store_shipping_carriers_bool_exp
  ): store_shipping_carriers_aggregate!

  """
  fetch data from the table: "store_shipping_carriers" using primary key columns
  """
  store_shipping_carriers_by_pk(id: uuid!): store_shipping_carriers

  """
  fetch data from the table in a streaming manner: "store_shipping_carriers"
  """
  store_shipping_carriers_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [store_shipping_carriers_stream_cursor_input]!

    """filter the rows returned"""
    where: store_shipping_carriers_bool_exp
  ): [store_shipping_carriers!]!

  """
  fetch data from the table: "stores"
  """
  stores(
    """distinct select on columns"""
    distinct_on: [stores_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [stores_order_by!]

    """filter the rows returned"""
    where: stores_bool_exp
  ): [stores!]!

  """
  fetch aggregated fields from the table: "stores"
  """
  stores_aggregate(
    """distinct select on columns"""
    distinct_on: [stores_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [stores_order_by!]

    """filter the rows returned"""
    where: stores_bool_exp
  ): stores_aggregate!

  """fetch data from the table: "stores" using primary key columns"""
  stores_by_pk(id: uuid!): stores

  """
  fetch data from the table in a streaming manner: "stores"
  """
  stores_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [stores_stream_cursor_input]!

    """filter the rows returned"""
    where: stores_bool_exp
  ): [stores!]!

  """
  fetch data from the table: "streets"
  """
  streets(
    """distinct select on columns"""
    distinct_on: [streets_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [streets_order_by!]

    """filter the rows returned"""
    where: streets_bool_exp
  ): [streets!]!

  """
  fetch aggregated fields from the table: "streets"
  """
  streets_aggregate(
    """distinct select on columns"""
    distinct_on: [streets_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [streets_order_by!]

    """filter the rows returned"""
    where: streets_bool_exp
  ): streets_aggregate!

  """fetch data from the table: "streets" using primary key columns"""
  streets_by_pk(id: uuid!): streets

  """
  fetch data from the table in a streaming manner: "streets"
  """
  streets_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [streets_stream_cursor_input]!

    """filter the rows returned"""
    where: streets_bool_exp
  ): [streets!]!

  """
  fetch data from the table: "tags"
  """
  tags(
    """distinct select on columns"""
    distinct_on: [tags_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tags_order_by!]

    """filter the rows returned"""
    where: tags_bool_exp
  ): [tags!]!

  """
  fetch aggregated fields from the table: "tags"
  """
  tags_aggregate(
    """distinct select on columns"""
    distinct_on: [tags_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tags_order_by!]

    """filter the rows returned"""
    where: tags_bool_exp
  ): tags_aggregate!

  """fetch data from the table: "tags" using primary key columns"""
  tags_by_pk(id: uuid!): tags

  """
  fetch data from the table in a streaming manner: "tags"
  """
  tags_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [tags_stream_cursor_input]!

    """filter the rows returned"""
    where: tags_bool_exp
  ): [tags!]!

  """
  fetch data from the table: "user_profiles"
  """
  user_profiles(
    """distinct select on columns"""
    distinct_on: [user_profiles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_profiles_order_by!]

    """filter the rows returned"""
    where: user_profiles_bool_exp
  ): [user_profiles!]!

  """
  fetch aggregated fields from the table: "user_profiles"
  """
  user_profiles_aggregate(
    """distinct select on columns"""
    distinct_on: [user_profiles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_profiles_order_by!]

    """filter the rows returned"""
    where: user_profiles_bool_exp
  ): user_profiles_aggregate!

  """fetch data from the table: "user_profiles" using primary key columns"""
  user_profiles_by_pk(id: uuid!): user_profiles

  """
  fetch data from the table in a streaming manner: "user_profiles"
  """
  user_profiles_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [user_profiles_stream_cursor_input]!

    """filter the rows returned"""
    where: user_profiles_bool_exp
  ): [user_profiles!]!

  """
  fetch data from the table: "user_roles"
  """
  user_roles(
    """distinct select on columns"""
    distinct_on: [user_roles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_roles_order_by!]

    """filter the rows returned"""
    where: user_roles_bool_exp
  ): [user_roles!]!

  """
  fetch aggregated fields from the table: "user_roles"
  """
  user_roles_aggregate(
    """distinct select on columns"""
    distinct_on: [user_roles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_roles_order_by!]

    """filter the rows returned"""
    where: user_roles_bool_exp
  ): user_roles_aggregate!

  """fetch data from the table: "user_roles" using primary key columns"""
  user_roles_by_pk(id: uuid!): user_roles

  """
  fetch data from the table in a streaming manner: "user_roles"
  """
  user_roles_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [user_roles_stream_cursor_input]!

    """filter the rows returned"""
    where: user_roles_bool_exp
  ): [user_roles!]!

  """
  fetch data from the table: "user_sessions"
  """
  user_sessions(
    """distinct select on columns"""
    distinct_on: [user_sessions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_sessions_order_by!]

    """filter the rows returned"""
    where: user_sessions_bool_exp
  ): [user_sessions!]!

  """
  fetch aggregated fields from the table: "user_sessions"
  """
  user_sessions_aggregate(
    """distinct select on columns"""
    distinct_on: [user_sessions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_sessions_order_by!]

    """filter the rows returned"""
    where: user_sessions_bool_exp
  ): user_sessions_aggregate!

  """fetch data from the table: "user_sessions" using primary key columns"""
  user_sessions_by_pk(id: uuid!): user_sessions

  """
  fetch data from the table in a streaming manner: "user_sessions"
  """
  user_sessions_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [user_sessions_stream_cursor_input]!

    """filter the rows returned"""
    where: user_sessions_bool_exp
  ): [user_sessions!]!

  """
  fetch data from the table: "user_settings"
  """
  user_settings(
    """distinct select on columns"""
    distinct_on: [user_settings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_settings_order_by!]

    """filter the rows returned"""
    where: user_settings_bool_exp
  ): [user_settings!]!

  """
  fetch aggregated fields from the table: "user_settings"
  """
  user_settings_aggregate(
    """distinct select on columns"""
    distinct_on: [user_settings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_settings_order_by!]

    """filter the rows returned"""
    where: user_settings_bool_exp
  ): user_settings_aggregate!

  """fetch data from the table: "user_settings" using primary key columns"""
  user_settings_by_pk(id: uuid!): user_settings

  """
  fetch data from the table in a streaming manner: "user_settings"
  """
  user_settings_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [user_settings_stream_cursor_input]!

    """filter the rows returned"""
    where: user_settings_bool_exp
  ): [user_settings!]!

  """
  fetch data from the table: "users"
  """
  users(
    """distinct select on columns"""
    distinct_on: [users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_order_by!]

    """filter the rows returned"""
    where: users_bool_exp
  ): [users!]!

  """
  fetch aggregated fields from the table: "users"
  """
  users_aggregate(
    """distinct select on columns"""
    distinct_on: [users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_order_by!]

    """filter the rows returned"""
    where: users_bool_exp
  ): users_aggregate!

  """fetch data from the table: "users" using primary key columns"""
  users_by_pk(id: uuid!): users

  """
  fetch data from the table in a streaming manner: "users"
  """
  users_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [users_stream_cursor_input]!

    """filter the rows returned"""
    where: users_bool_exp
  ): [users!]!

  """
  fetch data from the table: "wishlist_items"
  """
  wishlist_items(
    """distinct select on columns"""
    distinct_on: [wishlist_items_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [wishlist_items_order_by!]

    """filter the rows returned"""
    where: wishlist_items_bool_exp
  ): [wishlist_items!]!

  """
  fetch aggregated fields from the table: "wishlist_items"
  """
  wishlist_items_aggregate(
    """distinct select on columns"""
    distinct_on: [wishlist_items_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [wishlist_items_order_by!]

    """filter the rows returned"""
    where: wishlist_items_bool_exp
  ): wishlist_items_aggregate!

  """fetch data from the table: "wishlist_items" using primary key columns"""
  wishlist_items_by_pk(id: uuid!): wishlist_items

  """
  fetch data from the table in a streaming manner: "wishlist_items"
  """
  wishlist_items_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [wishlist_items_stream_cursor_input]!

    """filter the rows returned"""
    where: wishlist_items_bool_exp
  ): [wishlist_items!]!

  """
  fetch data from the table: "wishlists"
  """
  wishlists(
    """distinct select on columns"""
    distinct_on: [wishlists_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [wishlists_order_by!]

    """filter the rows returned"""
    where: wishlists_bool_exp
  ): [wishlists!]!

  """
  fetch aggregated fields from the table: "wishlists"
  """
  wishlists_aggregate(
    """distinct select on columns"""
    distinct_on: [wishlists_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [wishlists_order_by!]

    """filter the rows returned"""
    where: wishlists_bool_exp
  ): wishlists_aggregate!

  """fetch data from the table: "wishlists" using primary key columns"""
  wishlists_by_pk(id: uuid!): wishlists

  """
  fetch data from the table in a streaming manner: "wishlists"
  """
  wishlists_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [wishlists_stream_cursor_input]!

    """filter the rows returned"""
    where: wishlists_bool_exp
  ): [wishlists!]!
}

"""
columns and relationships of "tags"
"""
type tags {
  created_at: timestamptz!
  deleted_at: timestamptz
  id: uuid!
  name: String!
  site_id: uuid
  slug: String!
  updated_at: timestamptz!
}

"""
aggregated selection of "tags"
"""
type tags_aggregate {
  aggregate: tags_aggregate_fields
  nodes: [tags!]!
}

"""
aggregate fields of "tags"
"""
type tags_aggregate_fields {
  count(columns: [tags_select_column!], distinct: Boolean): Int!
  max: tags_max_fields
  min: tags_min_fields
}

"""
Boolean expression to filter rows from the table "tags". All fields are combined with a logical 'AND'.
"""
input tags_bool_exp {
  _and: [tags_bool_exp!]
  _not: tags_bool_exp
  _or: [tags_bool_exp!]
  created_at: timestamptz_comparison_exp
  deleted_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
  site_id: uuid_comparison_exp
  slug: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "tags"
"""
enum tags_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  tags_pkey
}

"""
input type for inserting data into table "tags"
"""
input tags_insert_input {
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  name: String
  site_id: uuid
  slug: String
  updated_at: timestamptz
}

"""aggregate max on columns"""
type tags_max_fields {
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  name: String
  site_id: uuid
  slug: String
  updated_at: timestamptz
}

"""aggregate min on columns"""
type tags_min_fields {
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  name: String
  site_id: uuid
  slug: String
  updated_at: timestamptz
}

"""
response of any mutation on the table "tags"
"""
type tags_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [tags!]!
}

"""
on_conflict condition type for table "tags"
"""
input tags_on_conflict {
  constraint: tags_constraint!
  update_columns: [tags_update_column!]! = []
  where: tags_bool_exp
}

"""Ordering options when selecting data from "tags"."""
input tags_order_by {
  created_at: order_by
  deleted_at: order_by
  id: order_by
  name: order_by
  site_id: order_by
  slug: order_by
  updated_at: order_by
}

"""primary key columns input for table: tags"""
input tags_pk_columns_input {
  id: uuid!
}

"""
select columns of table "tags"
"""
enum tags_select_column {
  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  name

  """column name"""
  site_id

  """column name"""
  slug

  """column name"""
  updated_at
}

"""
input type for updating data in table "tags"
"""
input tags_set_input {
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  name: String
  site_id: uuid
  slug: String
  updated_at: timestamptz
}

"""
Streaming cursor of the table "tags"
"""
input tags_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: tags_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input tags_stream_cursor_value_input {
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  name: String
  site_id: uuid
  slug: String
  updated_at: timestamptz
}

"""
update columns of table "tags"
"""
enum tags_update_column {
  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  name

  """column name"""
  site_id

  """column name"""
  slug

  """column name"""
  updated_at
}

input tags_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: tags_set_input

  """filter the rows which have to be updated"""
  where: tags_bool_exp!
}

scalar timestamptz

"""
Boolean expression to compare columns of type "timestamptz". All fields are combined with logical 'AND'.
"""
input timestamptz_comparison_exp {
  _eq: timestamptz
  _gt: timestamptz
  _gte: timestamptz
  _in: [timestamptz!]
  _is_null: Boolean
  _lt: timestamptz
  _lte: timestamptz
  _neq: timestamptz
  _nin: [timestamptz!]
}

"""
columns and relationships of "user_profiles"
"""
type user_profiles {
  birthday: date
  created_at: timestamptz!
  deleted_at: timestamptz
  id: uuid!
  is_private: Boolean!
  location: String
  updated_at: timestamptz!
  user_id: uuid
  website: String
}

"""
aggregated selection of "user_profiles"
"""
type user_profiles_aggregate {
  aggregate: user_profiles_aggregate_fields
  nodes: [user_profiles!]!
}

"""
aggregate fields of "user_profiles"
"""
type user_profiles_aggregate_fields {
  count(columns: [user_profiles_select_column!], distinct: Boolean): Int!
  max: user_profiles_max_fields
  min: user_profiles_min_fields
}

"""
Boolean expression to filter rows from the table "user_profiles". All fields are combined with a logical 'AND'.
"""
input user_profiles_bool_exp {
  _and: [user_profiles_bool_exp!]
  _not: user_profiles_bool_exp
  _or: [user_profiles_bool_exp!]
  birthday: date_comparison_exp
  created_at: timestamptz_comparison_exp
  deleted_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  is_private: Boolean_comparison_exp
  location: String_comparison_exp
  updated_at: timestamptz_comparison_exp
  user_id: uuid_comparison_exp
  website: String_comparison_exp
}

"""
unique or primary key constraints on table "user_profiles"
"""
enum user_profiles_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  user_profiles_pkey
}

"""
input type for inserting data into table "user_profiles"
"""
input user_profiles_insert_input {
  birthday: date
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  is_private: Boolean
  location: String
  updated_at: timestamptz
  user_id: uuid
  website: String
}

"""aggregate max on columns"""
type user_profiles_max_fields {
  birthday: date
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  location: String
  updated_at: timestamptz
  user_id: uuid
  website: String
}

"""aggregate min on columns"""
type user_profiles_min_fields {
  birthday: date
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  location: String
  updated_at: timestamptz
  user_id: uuid
  website: String
}

"""
response of any mutation on the table "user_profiles"
"""
type user_profiles_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [user_profiles!]!
}

"""
on_conflict condition type for table "user_profiles"
"""
input user_profiles_on_conflict {
  constraint: user_profiles_constraint!
  update_columns: [user_profiles_update_column!]! = []
  where: user_profiles_bool_exp
}

"""Ordering options when selecting data from "user_profiles"."""
input user_profiles_order_by {
  birthday: order_by
  created_at: order_by
  deleted_at: order_by
  id: order_by
  is_private: order_by
  location: order_by
  updated_at: order_by
  user_id: order_by
  website: order_by
}

"""primary key columns input for table: user_profiles"""
input user_profiles_pk_columns_input {
  id: uuid!
}

"""
select columns of table "user_profiles"
"""
enum user_profiles_select_column {
  """column name"""
  birthday

  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  is_private

  """column name"""
  location

  """column name"""
  updated_at

  """column name"""
  user_id

  """column name"""
  website
}

"""
input type for updating data in table "user_profiles"
"""
input user_profiles_set_input {
  birthday: date
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  is_private: Boolean
  location: String
  updated_at: timestamptz
  user_id: uuid
  website: String
}

"""
Streaming cursor of the table "user_profiles"
"""
input user_profiles_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: user_profiles_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input user_profiles_stream_cursor_value_input {
  birthday: date
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  is_private: Boolean
  location: String
  updated_at: timestamptz
  user_id: uuid
  website: String
}

"""
update columns of table "user_profiles"
"""
enum user_profiles_update_column {
  """column name"""
  birthday

  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  is_private

  """column name"""
  location

  """column name"""
  updated_at

  """column name"""
  user_id

  """column name"""
  website
}

input user_profiles_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: user_profiles_set_input

  """filter the rows which have to be updated"""
  where: user_profiles_bool_exp!
}

"""
columns and relationships of "user_roles"
"""
type user_roles {
  created_at: timestamptz!
  deleted_at: timestamptz
  id: uuid!
  role_id: uuid
  updated_at: timestamptz!
  user_id: uuid
}

"""
aggregated selection of "user_roles"
"""
type user_roles_aggregate {
  aggregate: user_roles_aggregate_fields
  nodes: [user_roles!]!
}

"""
aggregate fields of "user_roles"
"""
type user_roles_aggregate_fields {
  count(columns: [user_roles_select_column!], distinct: Boolean): Int!
  max: user_roles_max_fields
  min: user_roles_min_fields
}

"""
Boolean expression to filter rows from the table "user_roles". All fields are combined with a logical 'AND'.
"""
input user_roles_bool_exp {
  _and: [user_roles_bool_exp!]
  _not: user_roles_bool_exp
  _or: [user_roles_bool_exp!]
  created_at: timestamptz_comparison_exp
  deleted_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  role_id: uuid_comparison_exp
  updated_at: timestamptz_comparison_exp
  user_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "user_roles"
"""
enum user_roles_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  user_roles_pkey
}

"""
input type for inserting data into table "user_roles"
"""
input user_roles_insert_input {
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  role_id: uuid
  updated_at: timestamptz
  user_id: uuid
}

"""aggregate max on columns"""
type user_roles_max_fields {
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  role_id: uuid
  updated_at: timestamptz
  user_id: uuid
}

"""aggregate min on columns"""
type user_roles_min_fields {
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  role_id: uuid
  updated_at: timestamptz
  user_id: uuid
}

"""
response of any mutation on the table "user_roles"
"""
type user_roles_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [user_roles!]!
}

"""
on_conflict condition type for table "user_roles"
"""
input user_roles_on_conflict {
  constraint: user_roles_constraint!
  update_columns: [user_roles_update_column!]! = []
  where: user_roles_bool_exp
}

"""Ordering options when selecting data from "user_roles"."""
input user_roles_order_by {
  created_at: order_by
  deleted_at: order_by
  id: order_by
  role_id: order_by
  updated_at: order_by
  user_id: order_by
}

"""primary key columns input for table: user_roles"""
input user_roles_pk_columns_input {
  id: uuid!
}

"""
select columns of table "user_roles"
"""
enum user_roles_select_column {
  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  role_id

  """column name"""
  updated_at

  """column name"""
  user_id
}

"""
input type for updating data in table "user_roles"
"""
input user_roles_set_input {
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  role_id: uuid
  updated_at: timestamptz
  user_id: uuid
}

"""
Streaming cursor of the table "user_roles"
"""
input user_roles_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: user_roles_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input user_roles_stream_cursor_value_input {
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  role_id: uuid
  updated_at: timestamptz
  user_id: uuid
}

"""
update columns of table "user_roles"
"""
enum user_roles_update_column {
  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  role_id

  """column name"""
  updated_at

  """column name"""
  user_id
}

input user_roles_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: user_roles_set_input

  """filter the rows which have to be updated"""
  where: user_roles_bool_exp!
}

"""
columns and relationships of "user_sessions"
"""
type user_sessions {
  created_at: timestamptz!
  deleted_at: timestamptz
  device_info: String
  expires_at: timestamptz!
  id: uuid!
  ip_address: String
  last_active_at: timestamptz!
  token: String!
  updated_at: timestamptz!
  user_id: uuid
}

"""
aggregated selection of "user_sessions"
"""
type user_sessions_aggregate {
  aggregate: user_sessions_aggregate_fields
  nodes: [user_sessions!]!
}

"""
aggregate fields of "user_sessions"
"""
type user_sessions_aggregate_fields {
  count(columns: [user_sessions_select_column!], distinct: Boolean): Int!
  max: user_sessions_max_fields
  min: user_sessions_min_fields
}

"""
Boolean expression to filter rows from the table "user_sessions". All fields are combined with a logical 'AND'.
"""
input user_sessions_bool_exp {
  _and: [user_sessions_bool_exp!]
  _not: user_sessions_bool_exp
  _or: [user_sessions_bool_exp!]
  created_at: timestamptz_comparison_exp
  deleted_at: timestamptz_comparison_exp
  device_info: String_comparison_exp
  expires_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  ip_address: String_comparison_exp
  last_active_at: timestamptz_comparison_exp
  token: String_comparison_exp
  updated_at: timestamptz_comparison_exp
  user_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "user_sessions"
"""
enum user_sessions_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  user_sessions_pkey
}

"""
input type for inserting data into table "user_sessions"
"""
input user_sessions_insert_input {
  created_at: timestamptz
  deleted_at: timestamptz
  device_info: String
  expires_at: timestamptz
  id: uuid
  ip_address: String
  last_active_at: timestamptz
  token: String
  updated_at: timestamptz
  user_id: uuid
}

"""aggregate max on columns"""
type user_sessions_max_fields {
  created_at: timestamptz
  deleted_at: timestamptz
  device_info: String
  expires_at: timestamptz
  id: uuid
  ip_address: String
  last_active_at: timestamptz
  token: String
  updated_at: timestamptz
  user_id: uuid
}

"""aggregate min on columns"""
type user_sessions_min_fields {
  created_at: timestamptz
  deleted_at: timestamptz
  device_info: String
  expires_at: timestamptz
  id: uuid
  ip_address: String
  last_active_at: timestamptz
  token: String
  updated_at: timestamptz
  user_id: uuid
}

"""
response of any mutation on the table "user_sessions"
"""
type user_sessions_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [user_sessions!]!
}

"""
on_conflict condition type for table "user_sessions"
"""
input user_sessions_on_conflict {
  constraint: user_sessions_constraint!
  update_columns: [user_sessions_update_column!]! = []
  where: user_sessions_bool_exp
}

"""Ordering options when selecting data from "user_sessions"."""
input user_sessions_order_by {
  created_at: order_by
  deleted_at: order_by
  device_info: order_by
  expires_at: order_by
  id: order_by
  ip_address: order_by
  last_active_at: order_by
  token: order_by
  updated_at: order_by
  user_id: order_by
}

"""primary key columns input for table: user_sessions"""
input user_sessions_pk_columns_input {
  id: uuid!
}

"""
select columns of table "user_sessions"
"""
enum user_sessions_select_column {
  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  device_info

  """column name"""
  expires_at

  """column name"""
  id

  """column name"""
  ip_address

  """column name"""
  last_active_at

  """column name"""
  token

  """column name"""
  updated_at

  """column name"""
  user_id
}

"""
input type for updating data in table "user_sessions"
"""
input user_sessions_set_input {
  created_at: timestamptz
  deleted_at: timestamptz
  device_info: String
  expires_at: timestamptz
  id: uuid
  ip_address: String
  last_active_at: timestamptz
  token: String
  updated_at: timestamptz
  user_id: uuid
}

"""
Streaming cursor of the table "user_sessions"
"""
input user_sessions_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: user_sessions_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input user_sessions_stream_cursor_value_input {
  created_at: timestamptz
  deleted_at: timestamptz
  device_info: String
  expires_at: timestamptz
  id: uuid
  ip_address: String
  last_active_at: timestamptz
  token: String
  updated_at: timestamptz
  user_id: uuid
}

"""
update columns of table "user_sessions"
"""
enum user_sessions_update_column {
  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  device_info

  """column name"""
  expires_at

  """column name"""
  id

  """column name"""
  ip_address

  """column name"""
  last_active_at

  """column name"""
  token

  """column name"""
  updated_at

  """column name"""
  user_id
}

input user_sessions_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: user_sessions_set_input

  """filter the rows which have to be updated"""
  where: user_sessions_bool_exp!
}

"""
columns and relationships of "user_settings"
"""
type user_settings {
  created_at: timestamptz!
  deleted_at: timestamptz
  id: uuid!
  language: String!
  notification_email: Boolean!
  notification_push: Boolean!
  notification_sms: Boolean!
  theme: String!
  updated_at: timestamptz!
  user_id: uuid
}

"""
aggregated selection of "user_settings"
"""
type user_settings_aggregate {
  aggregate: user_settings_aggregate_fields
  nodes: [user_settings!]!
}

"""
aggregate fields of "user_settings"
"""
type user_settings_aggregate_fields {
  count(columns: [user_settings_select_column!], distinct: Boolean): Int!
  max: user_settings_max_fields
  min: user_settings_min_fields
}

"""
Boolean expression to filter rows from the table "user_settings". All fields are combined with a logical 'AND'.
"""
input user_settings_bool_exp {
  _and: [user_settings_bool_exp!]
  _not: user_settings_bool_exp
  _or: [user_settings_bool_exp!]
  created_at: timestamptz_comparison_exp
  deleted_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  language: String_comparison_exp
  notification_email: Boolean_comparison_exp
  notification_push: Boolean_comparison_exp
  notification_sms: Boolean_comparison_exp
  theme: String_comparison_exp
  updated_at: timestamptz_comparison_exp
  user_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "user_settings"
"""
enum user_settings_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  user_settings_pkey
}

"""
input type for inserting data into table "user_settings"
"""
input user_settings_insert_input {
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  language: String
  notification_email: Boolean
  notification_push: Boolean
  notification_sms: Boolean
  theme: String
  updated_at: timestamptz
  user_id: uuid
}

"""aggregate max on columns"""
type user_settings_max_fields {
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  language: String
  theme: String
  updated_at: timestamptz
  user_id: uuid
}

"""aggregate min on columns"""
type user_settings_min_fields {
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  language: String
  theme: String
  updated_at: timestamptz
  user_id: uuid
}

"""
response of any mutation on the table "user_settings"
"""
type user_settings_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [user_settings!]!
}

"""
on_conflict condition type for table "user_settings"
"""
input user_settings_on_conflict {
  constraint: user_settings_constraint!
  update_columns: [user_settings_update_column!]! = []
  where: user_settings_bool_exp
}

"""Ordering options when selecting data from "user_settings"."""
input user_settings_order_by {
  created_at: order_by
  deleted_at: order_by
  id: order_by
  language: order_by
  notification_email: order_by
  notification_push: order_by
  notification_sms: order_by
  theme: order_by
  updated_at: order_by
  user_id: order_by
}

"""primary key columns input for table: user_settings"""
input user_settings_pk_columns_input {
  id: uuid!
}

"""
select columns of table "user_settings"
"""
enum user_settings_select_column {
  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  language

  """column name"""
  notification_email

  """column name"""
  notification_push

  """column name"""
  notification_sms

  """column name"""
  theme

  """column name"""
  updated_at

  """column name"""
  user_id
}

"""
input type for updating data in table "user_settings"
"""
input user_settings_set_input {
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  language: String
  notification_email: Boolean
  notification_push: Boolean
  notification_sms: Boolean
  theme: String
  updated_at: timestamptz
  user_id: uuid
}

"""
Streaming cursor of the table "user_settings"
"""
input user_settings_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: user_settings_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input user_settings_stream_cursor_value_input {
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  language: String
  notification_email: Boolean
  notification_push: Boolean
  notification_sms: Boolean
  theme: String
  updated_at: timestamptz
  user_id: uuid
}

"""
update columns of table "user_settings"
"""
enum user_settings_update_column {
  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  language

  """column name"""
  notification_email

  """column name"""
  notification_push

  """column name"""
  notification_sms

  """column name"""
  theme

  """column name"""
  updated_at

  """column name"""
  user_id
}

input user_settings_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: user_settings_set_input

  """filter the rows which have to be updated"""
  where: user_settings_bool_exp!
}

"""
columns and relationships of "users"
"""
type users {
  avatar_url: String
  bio: String
  created_at: timestamptz!
  deleted_at: timestamptz
  display_name: String!
  email: String!
  id: uuid!
  is_verified: Boolean!
  updated_at: timestamptz!
  username: String!
}

"""
aggregated selection of "users"
"""
type users_aggregate {
  aggregate: users_aggregate_fields
  nodes: [users!]!
}

"""
aggregate fields of "users"
"""
type users_aggregate_fields {
  count(columns: [users_select_column!], distinct: Boolean): Int!
  max: users_max_fields
  min: users_min_fields
}

"""
Boolean expression to filter rows from the table "users". All fields are combined with a logical 'AND'.
"""
input users_bool_exp {
  _and: [users_bool_exp!]
  _not: users_bool_exp
  _or: [users_bool_exp!]
  avatar_url: String_comparison_exp
  bio: String_comparison_exp
  created_at: timestamptz_comparison_exp
  deleted_at: timestamptz_comparison_exp
  display_name: String_comparison_exp
  email: String_comparison_exp
  id: uuid_comparison_exp
  is_verified: Boolean_comparison_exp
  updated_at: timestamptz_comparison_exp
  username: String_comparison_exp
}

"""
unique or primary key constraints on table "users"
"""
enum users_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  users_pkey
}

"""
input type for inserting data into table "users"
"""
input users_insert_input {
  avatar_url: String
  bio: String
  created_at: timestamptz
  deleted_at: timestamptz
  display_name: String
  email: String
  id: uuid
  is_verified: Boolean
  updated_at: timestamptz
  username: String
}

"""aggregate max on columns"""
type users_max_fields {
  avatar_url: String
  bio: String
  created_at: timestamptz
  deleted_at: timestamptz
  display_name: String
  email: String
  id: uuid
  updated_at: timestamptz
  username: String
}

"""aggregate min on columns"""
type users_min_fields {
  avatar_url: String
  bio: String
  created_at: timestamptz
  deleted_at: timestamptz
  display_name: String
  email: String
  id: uuid
  updated_at: timestamptz
  username: String
}

"""
response of any mutation on the table "users"
"""
type users_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [users!]!
}

"""
on_conflict condition type for table "users"
"""
input users_on_conflict {
  constraint: users_constraint!
  update_columns: [users_update_column!]! = []
  where: users_bool_exp
}

"""Ordering options when selecting data from "users"."""
input users_order_by {
  avatar_url: order_by
  bio: order_by
  created_at: order_by
  deleted_at: order_by
  display_name: order_by
  email: order_by
  id: order_by
  is_verified: order_by
  updated_at: order_by
  username: order_by
}

"""primary key columns input for table: users"""
input users_pk_columns_input {
  id: uuid!
}

"""
select columns of table "users"
"""
enum users_select_column {
  """column name"""
  avatar_url

  """column name"""
  bio

  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  display_name

  """column name"""
  email

  """column name"""
  id

  """column name"""
  is_verified

  """column name"""
  updated_at

  """column name"""
  username
}

"""
input type for updating data in table "users"
"""
input users_set_input {
  avatar_url: String
  bio: String
  created_at: timestamptz
  deleted_at: timestamptz
  display_name: String
  email: String
  id: uuid
  is_verified: Boolean
  updated_at: timestamptz
  username: String
}

"""
Streaming cursor of the table "users"
"""
input users_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: users_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input users_stream_cursor_value_input {
  avatar_url: String
  bio: String
  created_at: timestamptz
  deleted_at: timestamptz
  display_name: String
  email: String
  id: uuid
  is_verified: Boolean
  updated_at: timestamptz
  username: String
}

"""
update columns of table "users"
"""
enum users_update_column {
  """column name"""
  avatar_url

  """column name"""
  bio

  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  display_name

  """column name"""
  email

  """column name"""
  id

  """column name"""
  is_verified

  """column name"""
  updated_at

  """column name"""
  username
}

input users_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: users_set_input

  """filter the rows which have to be updated"""
  where: users_bool_exp!
}

scalar uuid

"""
Boolean expression to compare columns of type "uuid". All fields are combined with logical 'AND'.
"""
input uuid_comparison_exp {
  _eq: uuid
  _gt: uuid
  _gte: uuid
  _in: [uuid!]
  _is_null: Boolean
  _lt: uuid
  _lte: uuid
  _neq: uuid
  _nin: [uuid!]
}

"""
columns and relationships of "wishlist_items"
"""
type wishlist_items {
  added_at: timestamptz!
  created_at: timestamptz!
  deleted_at: timestamptz
  id: uuid!
  product_id: uuid
  updated_at: timestamptz!
  wishlist_id: uuid
}

"""
aggregated selection of "wishlist_items"
"""
type wishlist_items_aggregate {
  aggregate: wishlist_items_aggregate_fields
  nodes: [wishlist_items!]!
}

"""
aggregate fields of "wishlist_items"
"""
type wishlist_items_aggregate_fields {
  count(columns: [wishlist_items_select_column!], distinct: Boolean): Int!
  max: wishlist_items_max_fields
  min: wishlist_items_min_fields
}

"""
Boolean expression to filter rows from the table "wishlist_items". All fields are combined with a logical 'AND'.
"""
input wishlist_items_bool_exp {
  _and: [wishlist_items_bool_exp!]
  _not: wishlist_items_bool_exp
  _or: [wishlist_items_bool_exp!]
  added_at: timestamptz_comparison_exp
  created_at: timestamptz_comparison_exp
  deleted_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  product_id: uuid_comparison_exp
  updated_at: timestamptz_comparison_exp
  wishlist_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "wishlist_items"
"""
enum wishlist_items_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  wishlist_items_pkey
}

"""
input type for inserting data into table "wishlist_items"
"""
input wishlist_items_insert_input {
  added_at: timestamptz
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  product_id: uuid
  updated_at: timestamptz
  wishlist_id: uuid
}

"""aggregate max on columns"""
type wishlist_items_max_fields {
  added_at: timestamptz
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  product_id: uuid
  updated_at: timestamptz
  wishlist_id: uuid
}

"""aggregate min on columns"""
type wishlist_items_min_fields {
  added_at: timestamptz
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  product_id: uuid
  updated_at: timestamptz
  wishlist_id: uuid
}

"""
response of any mutation on the table "wishlist_items"
"""
type wishlist_items_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [wishlist_items!]!
}

"""
on_conflict condition type for table "wishlist_items"
"""
input wishlist_items_on_conflict {
  constraint: wishlist_items_constraint!
  update_columns: [wishlist_items_update_column!]! = []
  where: wishlist_items_bool_exp
}

"""Ordering options when selecting data from "wishlist_items"."""
input wishlist_items_order_by {
  added_at: order_by
  created_at: order_by
  deleted_at: order_by
  id: order_by
  product_id: order_by
  updated_at: order_by
  wishlist_id: order_by
}

"""primary key columns input for table: wishlist_items"""
input wishlist_items_pk_columns_input {
  id: uuid!
}

"""
select columns of table "wishlist_items"
"""
enum wishlist_items_select_column {
  """column name"""
  added_at

  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  product_id

  """column name"""
  updated_at

  """column name"""
  wishlist_id
}

"""
input type for updating data in table "wishlist_items"
"""
input wishlist_items_set_input {
  added_at: timestamptz
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  product_id: uuid
  updated_at: timestamptz
  wishlist_id: uuid
}

"""
Streaming cursor of the table "wishlist_items"
"""
input wishlist_items_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: wishlist_items_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input wishlist_items_stream_cursor_value_input {
  added_at: timestamptz
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  product_id: uuid
  updated_at: timestamptz
  wishlist_id: uuid
}

"""
update columns of table "wishlist_items"
"""
enum wishlist_items_update_column {
  """column name"""
  added_at

  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  product_id

  """column name"""
  updated_at

  """column name"""
  wishlist_id
}

input wishlist_items_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: wishlist_items_set_input

  """filter the rows which have to be updated"""
  where: wishlist_items_bool_exp!
}

"""
columns and relationships of "wishlists"
"""
type wishlists {
  created_at: timestamptz!
  customer_id: uuid
  deleted_at: timestamptz
  id: uuid!
  name: String!
  updated_at: timestamptz!
}

"""
aggregated selection of "wishlists"
"""
type wishlists_aggregate {
  aggregate: wishlists_aggregate_fields
  nodes: [wishlists!]!
}

"""
aggregate fields of "wishlists"
"""
type wishlists_aggregate_fields {
  count(columns: [wishlists_select_column!], distinct: Boolean): Int!
  max: wishlists_max_fields
  min: wishlists_min_fields
}

"""
Boolean expression to filter rows from the table "wishlists". All fields are combined with a logical 'AND'.
"""
input wishlists_bool_exp {
  _and: [wishlists_bool_exp!]
  _not: wishlists_bool_exp
  _or: [wishlists_bool_exp!]
  created_at: timestamptz_comparison_exp
  customer_id: uuid_comparison_exp
  deleted_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "wishlists"
"""
enum wishlists_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  wishlists_pkey
}

"""
input type for inserting data into table "wishlists"
"""
input wishlists_insert_input {
  created_at: timestamptz
  customer_id: uuid
  deleted_at: timestamptz
  id: uuid
  name: String
  updated_at: timestamptz
}

"""aggregate max on columns"""
type wishlists_max_fields {
  created_at: timestamptz
  customer_id: uuid
  deleted_at: timestamptz
  id: uuid
  name: String
  updated_at: timestamptz
}

"""aggregate min on columns"""
type wishlists_min_fields {
  created_at: timestamptz
  customer_id: uuid
  deleted_at: timestamptz
  id: uuid
  name: String
  updated_at: timestamptz
}

"""
response of any mutation on the table "wishlists"
"""
type wishlists_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [wishlists!]!
}

"""
on_conflict condition type for table "wishlists"
"""
input wishlists_on_conflict {
  constraint: wishlists_constraint!
  update_columns: [wishlists_update_column!]! = []
  where: wishlists_bool_exp
}

"""Ordering options when selecting data from "wishlists"."""
input wishlists_order_by {
  created_at: order_by
  customer_id: order_by
  deleted_at: order_by
  id: order_by
  name: order_by
  updated_at: order_by
}

"""primary key columns input for table: wishlists"""
input wishlists_pk_columns_input {
  id: uuid!
}

"""
select columns of table "wishlists"
"""
enum wishlists_select_column {
  """column name"""
  created_at

  """column name"""
  customer_id

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  name

  """column name"""
  updated_at
}

"""
input type for updating data in table "wishlists"
"""
input wishlists_set_input {
  created_at: timestamptz
  customer_id: uuid
  deleted_at: timestamptz
  id: uuid
  name: String
  updated_at: timestamptz
}

"""
Streaming cursor of the table "wishlists"
"""
input wishlists_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: wishlists_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input wishlists_stream_cursor_value_input {
  created_at: timestamptz
  customer_id: uuid
  deleted_at: timestamptz
  id: uuid
  name: String
  updated_at: timestamptz
}

"""
update columns of table "wishlists"
"""
enum wishlists_update_column {
  """column name"""
  created_at

  """column name"""
  customer_id

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  name

  """column name"""
  updated_at
}

input wishlists_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: wishlists_set_input

  """filter the rows which have to be updated"""
  where: wishlists_bool_exp!
}